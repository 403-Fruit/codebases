'use strict';

var _regeneratorRuntime = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/asyncToGenerator");

var _slicedToArray = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/slicedToArray");

var _defineProperty = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/defineProperty");

var _classCallCheck = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/createClass");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MapGenerator = require('./map-generator');

var _require = require('./symbols'),
    isClean = _require.isClean;

var _stringify = require('./stringify');

var warnOnce = require('./warn-once');

var Result = require('./result');

var parse = require('./parse');

var Root = require('./root');

var TYPE_TO_CLASS_NAME = {
  root: 'Root',
  atrule: 'AtRule',
  rule: 'Rule',
  decl: 'Declaration',
  comment: 'Comment'
};
var PLUGIN_PROPS = {
  postcssPlugin: true,
  prepare: true,
  Once: true,
  Root: true,
  Declaration: true,
  Rule: true,
  AtRule: true,
  Comment: true,
  DeclarationExit: true,
  RuleExit: true,
  AtRuleExit: true,
  CommentExit: true,
  RootExit: true,
  OnceExit: true
};
var NOT_VISITORS = {
  postcssPlugin: true,
  prepare: true,
  Once: true
};
var CHILDREN = 0;

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function';
}

function getEvents(node) {
  var key = false;
  var type = TYPE_TO_CLASS_NAME[node.type];

  if (node.type === 'decl') {
    key = node.prop.toLowerCase();
  } else if (node.type === 'atrule') {
    key = node.name.toLowerCase();
  }

  if (key && node.append) {
    return [type, type + '-' + key, CHILDREN, type + 'Exit', type + 'Exit-' + key];
  } else if (key) {
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key];
  } else if (node.append) {
    return [type, CHILDREN, type + 'Exit'];
  } else {
    return [type, type + 'Exit'];
  }
}

function toStack(node) {
  var events;

  if (node.type === 'root') {
    events = ['Root', CHILDREN, 'RootExit'];
  } else {
    events = getEvents(node);
  }

  return {
    node: node,
    events: events,
    eventIndex: 0,
    visitors: [],
    visitorIndex: 0,
    iterator: 0
  };
}

function cleanMarks(node) {
  node[isClean] = false;
  if (node.nodes) node.nodes.forEach(function (i) {
    return cleanMarks(i);
  });
  return node;
}

var postcss = {};

var LazyResult = /*#__PURE__*/function () {
  function LazyResult(processor, css, opts) {
    var _this = this;

    _classCallCheck(this, LazyResult);

    this.stringified = false;
    this.processed = false;
    var root;

    if (typeof css === 'object' && css !== null && css.type === 'root') {
      root = cleanMarks(css);
    } else if (css instanceof LazyResult || css instanceof Result) {
      root = cleanMarks(css.root);

      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      var parser = parse;
      if (opts.syntax) parser = opts.syntax.parse;
      if (opts.parser) parser = opts.parser;
      if (parser.parse) parser = parser.parse;

      try {
        root = parser(css, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
    }

    this.result = new Result(processor, root, opts);
    this.helpers = _objectSpread(_objectSpread({}, postcss), {}, {
      result: this.result,
      postcss: postcss
    });
    this.plugins = this.processor.plugins.map(function (plugin) {
      if (typeof plugin === 'object' && plugin.prepare) {
        return _objectSpread(_objectSpread({}, plugin), plugin.prepare(_this.result));
      } else {
        return plugin;
      }
    });
  }

  _createClass(LazyResult, [{
    key: Symbol.toStringTag,
    get: function get() {
      return 'LazyResult';
    }
  }, {
    key: "processor",
    get: function get() {
      return this.result.processor;
    }
  }, {
    key: "opts",
    get: function get() {
      return this.result.opts;
    }
  }, {
    key: "css",
    get: function get() {
      return this.stringify().css;
    }
  }, {
    key: "content",
    get: function get() {
      return this.stringify().content;
    }
  }, {
    key: "map",
    get: function get() {
      return this.stringify().map;
    }
  }, {
    key: "root",
    get: function get() {
      return this.sync().root;
    }
  }, {
    key: "messages",
    get: function get() {
      return this.sync().messages;
    }
  }, {
    key: "warnings",
    value: function warnings() {
      return this.sync().warnings();
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.css;
    }
  }, {
    key: "then",
    value: function then(onFulfilled, onRejected) {
      if (process.env.NODE_ENV !== 'production') {
        if (!('from' in this.opts)) {
          warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');
        }
      }

      return this.async().then(onFulfilled, onRejected);
    }
  }, {
    key: "catch",
    value: function _catch(onRejected) {
      return this.async().catch(onRejected);
    }
  }, {
    key: "finally",
    value: function _finally(onFinally) {
      return this.async().then(onFinally, onFinally);
    }
  }, {
    key: "async",
    value: function async() {
      if (this.error) return Promise.reject(this.error);
      if (this.processed) return Promise.resolve(this.result);

      if (!this.processing) {
        this.processing = this.runAsync();
      }

      return this.processing;
    }
  }, {
    key: "sync",
    value: function sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      this.processed = true;

      if (this.processing) {
        throw this.getAsyncError();
      }

      var _iterator = _createForOfIteratorHelper(this.plugins),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var plugin = _step.value;
          var promise = this.runOnRoot(plugin);

          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.prepareVisitors();

      if (this.hasListener) {
        var root = this.result.root;

        while (!root[isClean]) {
          root[isClean] = true;
          this.walkSync(root);
        }

        if (this.listeners.OnceExit) {
          this.visitSync(this.listeners.OnceExit, root);
        }
      }

      return this.result;
    }
  }, {
    key: "stringify",
    value: function stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = true;
      this.sync();
      var opts = this.result.opts;
      var str = _stringify;
      if (opts.syntax) str = opts.syntax.stringify;
      if (opts.stringifier) str = opts.stringifier;
      if (str.stringify) str = str.stringify;
      var map = new MapGenerator(str, this.result.root, this.result.opts);
      var data = map.generate();
      this.result.css = data[0];
      this.result.map = data[1];
      return this.result;
    }
  }, {
    key: "walkSync",
    value: function walkSync(node) {
      var _this2 = this;

      node[isClean] = true;
      var events = getEvents(node);

      var _iterator2 = _createForOfIteratorHelper(events),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var event = _step2.value;

          if (event === CHILDREN) {
            if (node.nodes) {
              node.each(function (child) {
                if (!child[isClean]) _this2.walkSync(child);
              });
            }
          } else {
            var visitors = this.listeners[event];

            if (visitors) {
              if (this.visitSync(visitors, node.toProxy())) return;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "visitSync",
    value: function visitSync(visitors, node) {
      var _iterator3 = _createForOfIteratorHelper(visitors),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              plugin = _step3$value[0],
              visitor = _step3$value[1];

          this.result.lastPlugin = plugin;
          var promise = void 0;

          try {
            promise = visitor(node, this.helpers);
          } catch (e) {
            throw this.handleError(e, node.proxyOf);
          }

          if (node.type !== 'root' && !node.parent) return true;

          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "runOnRoot",
    value: function runOnRoot(plugin) {
      this.result.lastPlugin = plugin;

      try {
        if (typeof plugin === 'object' && plugin.Once) {
          return plugin.Once(this.result.root, this.helpers);
        } else if (typeof plugin === 'function') {
          return plugin(this.result.root, this.result);
        }
      } catch (error) {
        throw this.handleError(error);
      }
    }
  }, {
    key: "getAsyncError",
    value: function getAsyncError() {
      throw new Error('Use process(css).then(cb) to work with async plugins');
    }
  }, {
    key: "handleError",
    value: function handleError(error, node) {
      var plugin = this.result.lastPlugin;

      try {
        if (node) node.addToError(error);
        this.error = error;

        if (error.name === 'CssSyntaxError' && !error.plugin) {
          error.plugin = plugin.postcssPlugin;
          error.setMessage();
        } else if (plugin.postcssVersion) {
          if (process.env.NODE_ENV !== 'production') {
            var pluginName = plugin.postcssPlugin;
            var pluginVer = plugin.postcssVersion;
            var runtimeVer = this.result.processor.version;
            var a = pluginVer.split('.');
            var b = runtimeVer.split('.');

            if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
              console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');
            }
          }
        }
      } catch (err) {
        // istanbul ignore next
        if (console && console.error) console.error(err);
      }

      return error;
    }
  }, {
    key: "runAsync",
    value: function () {
      var _runAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var i, plugin, promise, root, stack, _promise, node, _iterator4, _step4, _step4$value, _plugin, visitor;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.plugin = 0;
                i = 0;

              case 2:
                if (!(i < this.plugins.length)) {
                  _context.next = 17;
                  break;
                }

                plugin = this.plugins[i];
                promise = this.runOnRoot(plugin);

                if (!isPromise(promise)) {
                  _context.next = 14;
                  break;
                }

                _context.prev = 6;
                _context.next = 9;
                return promise;

              case 9:
                _context.next = 14;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](6);
                throw this.handleError(_context.t0);

              case 14:
                i++;
                _context.next = 2;
                break;

              case 17:
                this.prepareVisitors();

                if (!this.hasListener) {
                  _context.next = 64;
                  break;
                }

                root = this.result.root;

              case 20:
                if (root[isClean]) {
                  _context.next = 39;
                  break;
                }

                root[isClean] = true;
                stack = [toStack(root)];

              case 23:
                if (!(stack.length > 0)) {
                  _context.next = 37;
                  break;
                }

                _promise = this.visitTick(stack);

                if (!isPromise(_promise)) {
                  _context.next = 35;
                  break;
                }

                _context.prev = 26;
                _context.next = 29;
                return _promise;

              case 29:
                _context.next = 35;
                break;

              case 31:
                _context.prev = 31;
                _context.t1 = _context["catch"](26);
                node = stack[stack.length - 1].node;
                throw this.handleError(_context.t1, node);

              case 35:
                _context.next = 23;
                break;

              case 37:
                _context.next = 20;
                break;

              case 39:
                if (!this.listeners.OnceExit) {
                  _context.next = 64;
                  break;
                }

                _iterator4 = _createForOfIteratorHelper(this.listeners.OnceExit);
                _context.prev = 41;

                _iterator4.s();

              case 43:
                if ((_step4 = _iterator4.n()).done) {
                  _context.next = 56;
                  break;
                }

                _step4$value = _slicedToArray(_step4.value, 2), _plugin = _step4$value[0], visitor = _step4$value[1];
                this.result.lastPlugin = _plugin;
                _context.prev = 46;
                _context.next = 49;
                return visitor(root, this.helpers);

              case 49:
                _context.next = 54;
                break;

              case 51:
                _context.prev = 51;
                _context.t2 = _context["catch"](46);
                throw this.handleError(_context.t2);

              case 54:
                _context.next = 43;
                break;

              case 56:
                _context.next = 61;
                break;

              case 58:
                _context.prev = 58;
                _context.t3 = _context["catch"](41);

                _iterator4.e(_context.t3);

              case 61:
                _context.prev = 61;

                _iterator4.f();

                return _context.finish(61);

              case 64:
                this.processed = true;
                return _context.abrupt("return", this.stringify());

              case 66:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 11], [26, 31], [41, 58, 61, 64], [46, 51]]);
      }));

      function runAsync() {
        return _runAsync.apply(this, arguments);
      }

      return runAsync;
    }()
  }, {
    key: "prepareVisitors",
    value: function prepareVisitors() {
      var _this3 = this;

      this.listeners = {};

      var add = function add(plugin, type, cb) {
        if (!_this3.listeners[type]) _this3.listeners[type] = [];

        _this3.listeners[type].push([plugin, cb]);
      };

      var _iterator5 = _createForOfIteratorHelper(this.plugins),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var plugin = _step5.value;

          if (typeof plugin === 'object') {
            for (var event in plugin) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error("Unknown event ".concat(event, " in ").concat(plugin.postcssPlugin, ". ") + "Try to update PostCSS (".concat(this.processor.version, " now)."));
              }

              if (!NOT_VISITORS[event]) {
                if (typeof plugin[event] === 'object') {
                  for (var filter in plugin[event]) {
                    if (filter === '*') {
                      add(plugin, event, plugin[event][filter]);
                    } else {
                      add(plugin, event + '-' + filter.toLowerCase(), plugin[event][filter]);
                    }
                  }
                } else if (typeof plugin[event] === 'function') {
                  add(plugin, event, plugin[event]);
                }
              }
            }
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      this.hasListener = Object.keys(this.listeners).length > 0;
    }
  }, {
    key: "visitTick",
    value: function visitTick(stack) {
      var visit = stack[stack.length - 1];
      var node = visit.node,
          visitors = visit.visitors;

      if (node.type !== 'root' && !node.parent) {
        stack.pop();
        return;
      }

      if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
        var _visitors$visit$visit = _slicedToArray(visitors[visit.visitorIndex], 2),
            plugin = _visitors$visit$visit[0],
            visitor = _visitors$visit$visit[1];

        visit.visitorIndex += 1;

        if (visit.visitorIndex === visitors.length) {
          visit.visitors = [];
          visit.visitorIndex = 0;
        }

        this.result.lastPlugin = plugin;

        try {
          return visitor(node.toProxy(), this.helpers);
        } catch (e) {
          throw this.handleError(e, node);
        }
      }

      if (visit.iterator !== 0) {
        var iterator = visit.iterator;
        var child;

        while (child = node.nodes[node.indexes[iterator]]) {
          node.indexes[iterator] += 1;

          if (!child[isClean]) {
            child[isClean] = true;
            stack.push(toStack(child));
            return;
          }
        }

        visit.iterator = 0;
        delete node.indexes[iterator];
      }

      var events = visit.events;

      while (visit.eventIndex < events.length) {
        var event = events[visit.eventIndex];
        visit.eventIndex += 1;

        if (event === CHILDREN) {
          if (node.nodes && node.nodes.length) {
            node[isClean] = true;
            visit.iterator = node.getIterator();
          }

          return;
        } else if (this.listeners[event]) {
          visit.visitors = this.listeners[event];
          return;
        }
      }

      stack.pop();
    }
  }]);

  return LazyResult;
}();

LazyResult.registerPostcss = function (dependant) {
  postcss = dependant;
};

module.exports = LazyResult;
LazyResult.default = LazyResult;
Root.registerLazyResult(LazyResult);