'use strict';

var _classCallCheck = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/usr/src/app/www/cloud/gatsbyjs.com/node_modules/gatsby/node_modules/@babel/runtime/helpers/createClass");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require('path'),
    dirname = _require.dirname,
    resolve = _require.resolve,
    relative = _require.relative,
    sep = _require.sep;

var _require2 = require('url'),
    pathToFileURL = _require2.pathToFileURL;

var _require3 = require('source-map'),
    SourceMapConsumer = _require3.SourceMapConsumer,
    SourceMapGenerator = _require3.SourceMapGenerator;

var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
var pathAvailable = Boolean(dirname && resolve && relative && sep);

var MapGenerator = /*#__PURE__*/function () {
  function MapGenerator(stringify, root, opts) {
    _classCallCheck(this, MapGenerator);

    this.stringify = stringify;
    this.mapOpts = opts.map || {};
    this.root = root;
    this.opts = opts;
  }

  _createClass(MapGenerator, [{
    key: "isMap",
    value: function isMap() {
      if (typeof this.opts.map !== 'undefined') {
        return !!this.opts.map;
      }

      return this.previous().length > 0;
    }
  }, {
    key: "previous",
    value: function previous() {
      var _this = this;

      if (!this.previousMaps) {
        this.previousMaps = [];
        this.root.walk(function (node) {
          if (node.source && node.source.input.map) {
            var map = node.source.input.map;

            if (!_this.previousMaps.includes(map)) {
              _this.previousMaps.push(map);
            }
          }
        });
      }

      return this.previousMaps;
    }
  }, {
    key: "isInline",
    value: function isInline() {
      if (typeof this.mapOpts.inline !== 'undefined') {
        return this.mapOpts.inline;
      }

      var annotation = this.mapOpts.annotation;

      if (typeof annotation !== 'undefined' && annotation !== true) {
        return false;
      }

      if (this.previous().length) {
        return this.previous().some(function (i) {
          return i.inline;
        });
      }

      return true;
    }
  }, {
    key: "isSourcesContent",
    value: function isSourcesContent() {
      if (typeof this.mapOpts.sourcesContent !== 'undefined') {
        return this.mapOpts.sourcesContent;
      }

      if (this.previous().length) {
        return this.previous().some(function (i) {
          return i.withContent();
        });
      }

      return true;
    }
  }, {
    key: "clearAnnotation",
    value: function clearAnnotation() {
      if (this.mapOpts.annotation === false) return;
      var node;

      for (var i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i];
        if (node.type !== 'comment') continue;

        if (node.text.indexOf('# sourceMappingURL=') === 0) {
          this.root.removeChild(i);
        }
      }
    }
  }, {
    key: "setSourcesContent",
    value: function setSourcesContent() {
      var _this2 = this;

      var already = {};
      this.root.walk(function (node) {
        if (node.source) {
          var from = node.source.input.from;

          if (from && !already[from]) {
            already[from] = true;

            _this2.map.setSourceContent(_this2.toUrl(_this2.path(from)), node.source.input.css);
          }
        }
      });
    }
  }, {
    key: "applyPrevMaps",
    value: function applyPrevMaps() {
      var _iterator = _createForOfIteratorHelper(this.previous()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var prev = _step.value;
          var from = this.toUrl(this.path(prev.file));
          var root = prev.root || dirname(prev.file);
          var map = void 0;

          if (this.mapOpts.sourcesContent === false) {
            map = new SourceMapConsumer(prev.text);

            if (map.sourcesContent) {
              map.sourcesContent = map.sourcesContent.map(function () {
                return null;
              });
            }
          } else {
            map = prev.consumer();
          }

          this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "isAnnotation",
    value: function isAnnotation() {
      if (this.isInline()) {
        return true;
      }

      if (typeof this.mapOpts.annotation !== 'undefined') {
        return this.mapOpts.annotation;
      }

      if (this.previous().length) {
        return this.previous().some(function (i) {
          return i.annotation;
        });
      }

      return true;
    }
  }, {
    key: "toBase64",
    value: function toBase64(str) {
      if (Buffer) {
        return Buffer.from(str).toString('base64');
      } else {
        // istanbul ignore next
        return window.btoa(unescape(encodeURIComponent(str)));
      }
    }
  }, {
    key: "addAnnotation",
    value: function addAnnotation() {
      var content;

      if (this.isInline()) {
        content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
      } else if (typeof this.mapOpts.annotation === 'string') {
        content = this.mapOpts.annotation;
      } else if (typeof this.mapOpts.annotation === 'function') {
        content = this.mapOpts.annotation(this.opts.to, this.root);
      } else {
        content = this.outputFile() + '.map';
      }

      var eol = '\n';
      if (this.css.includes('\r\n')) eol = '\r\n';
      this.css += eol + '/*# sourceMappingURL=' + content + ' */';
    }
  }, {
    key: "outputFile",
    value: function outputFile() {
      if (this.opts.to) {
        return this.path(this.opts.to);
      }

      if (this.opts.from) {
        return this.path(this.opts.from);
      }

      return 'to.css';
    }
  }, {
    key: "generateMap",
    value: function generateMap() {
      this.generateString();
      if (this.isSourcesContent()) this.setSourcesContent();
      if (this.previous().length > 0) this.applyPrevMaps();
      if (this.isAnnotation()) this.addAnnotation();

      if (this.isInline()) {
        return [this.css];
      }

      return [this.css, this.map];
    }
  }, {
    key: "path",
    value: function path(file) {
      if (file.indexOf('<') === 0) return file;
      if (/^\w+:\/\//.test(file)) return file;
      if (this.mapOpts.absolute) return file;
      var from = this.opts.to ? dirname(this.opts.to) : '.';

      if (typeof this.mapOpts.annotation === 'string') {
        from = dirname(resolve(from, this.mapOpts.annotation));
      }

      file = relative(from, file);
      return file;
    }
  }, {
    key: "toUrl",
    value: function toUrl(path) {
      if (sep === '\\') {
        // istanbul ignore next
        path = path.replace(/\\/g, '/');
      }

      return encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    }
  }, {
    key: "sourcePath",
    value: function sourcePath(node) {
      if (this.mapOpts.from) {
        return this.toUrl(this.mapOpts.from);
      } else if (this.mapOpts.absolute) {
        if (pathToFileURL) {
          return pathToFileURL(node.source.input.from).toString();
        } else {
          // istanbul ignore next
          throw new Error('`map.absolute` option is not available in this PostCSS build');
        }
      } else {
        return this.toUrl(this.path(node.source.input.from));
      }
    }
  }, {
    key: "generateString",
    value: function generateString() {
      var _this3 = this;

      this.css = '';
      this.map = new SourceMapGenerator({
        file: this.outputFile()
      });
      var line = 1;
      var column = 1;
      var noSource = '<no source>';
      var mapping = {
        source: '',
        generated: {
          line: 0,
          column: 0
        },
        original: {
          line: 0,
          column: 0
        }
      };
      var lines, last;
      this.stringify(this.root, function (str, node, type) {
        _this3.css += str;

        if (node && type !== 'end') {
          mapping.generated.line = line;
          mapping.generated.column = column - 1;

          if (node.source && node.source.start) {
            mapping.source = _this3.sourcePath(node);
            mapping.original.line = node.source.start.line;
            mapping.original.column = node.source.start.column - 1;

            _this3.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;

            _this3.map.addMapping(mapping);
          }
        }

        lines = str.match(/\n/g);

        if (lines) {
          line += lines.length;
          last = str.lastIndexOf('\n');
          column = str.length - last;
        } else {
          column += str.length;
        }

        if (node && type !== 'start') {
          var p = node.parent || {
            raws: {}
          };

          if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {
            if (node.source && node.source.end) {
              mapping.source = _this3.sourcePath(node);
              mapping.original.line = node.source.end.line;
              mapping.original.column = node.source.end.column - 1;
              mapping.generated.line = line;
              mapping.generated.column = column - 2;

              _this3.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              mapping.generated.line = line;
              mapping.generated.column = column - 1;

              _this3.map.addMapping(mapping);
            }
          }
        }
      });
    }
  }, {
    key: "generate",
    value: function generate() {
      this.clearAnnotation();

      if (pathAvailable && sourceMapAvailable && this.isMap()) {
        return this.generateMap();
      }

      var result = '';
      this.stringify(this.root, function (i) {
        result += i;
      });
      return [result];
    }
  }]);

  return MapGenerator;
}();

module.exports = MapGenerator;