/* eslint-disable no-undef */
const Backbone = require('backbone');
const $ = require('jquery');
const _ = require('lodash');
const moment = require('moment');
const cookies = require('js-cookie');
const Logger = require('@pipedrive/logger-fe').default;
const logger = new Logger('webapp-core', 'model');

let apiPendingUpdates = [];
let apiPendingUpdateSyncs = [];

const reduceModelOrObjectAttributes = function(modelsOfType, model, id) {
	if (modelsOfType[id]) {
		const modelContent = model.attributes || model;

		// it is possible that we have JSON object or Backbone model
		if (_.isFunction(modelsOfType[id].set)) {
			modelsOfType[id].set(modelContent);
		} else {
			_.assignIn(modelsOfType[id], modelContent);
		}
	} else {
		modelsOfType[id] = model;
	}

	return modelsOfType;
};
	/**
	 * Pipedrive Model extends BackboneJS (see {@link http://backbonejs.org/#Model}).
	 * @name     Model
	 * @class    Pipedrive Model class
	 * @extends  Backbone.Model
	 * @memberOf module:Pipedrive
	 */
const PipedriveModel = Backbone.Model.extend({
	ownerKey: 'owner_id',

	relatedModels: null,

	/**
		 * Allows socket events be mimiced by responses of the server.
		 * @type {Boolean}
		 */
	allowDirectSync: false,

	/**
		 * Custom get method to get attribute or fallback attribute
		 */
	get: function(attribute) {
		if (this.fallback) {
			const value = Backbone.Model.prototype.get.call(this, attribute);

			return (!value && this.fallback.hasOwnProperty(attribute) ? this.fallback[attribute] : value);
		}

		return Backbone.Model.prototype.get.call(this, attribute);
	},

	/**
		 * Set value of a model
		 *
		 * Custom set handler. This handles read-only attributes used in
		 * Pipedrive API.
		 *
		 * @param {mixed} key
		 * @param {mixed} value
		 * @param {object} options
		 */
	// eslint-disable-next-line complexity
	set: function(key, value, options) {
		let attrs, attr;

		if (_.isObject(key) || !key) {
			attrs = key;
			options = value;
		} else {
			attrs = {};
			attrs[key] = value;
		}

		options = options || (options = {});

		if (!attrs) {
			return this;
		}

		if (attrs instanceof Backbone.Model) {
			attrs = _.clone(attrs.attributes);
		}

		if (options.unset) {
			for (attr in attrs) {
				// eslint-disable-next-line no-void
				attrs[attr] = void 0;
			}
		}

		if (!this._previousAttributes) {
			this._previousAttributes = {};
		}

		if (_.isArray(this.readonly) && !options.updateReadonly) {
			const attrKeys = _.keys(attrs);
			const roKeys = _.intersection(attrKeys, this.readonly);
			const rwKeys = _.difference(attrKeys, roKeys);

			if (!rwKeys.length) {
				options.silent = true;
			}

			const self = this;

			_.forEach(roKeys, (k) => {
				self._previousAttributes[k] = self.attributes[k] = attrs[k];
				delete attrs[k];
			});
		}

		if (!options.unset) {
			attrs = _.assignIn(this.hasChanged() ? _.clone(this.changed) : {}, attrs);
		}

		const origSet = Backbone.Model.prototype.set.call(this, attrs, options);

		this.triggerChangeOnCollection();

		return origSet;
	},

	triggerChangeOnCollection: function() {
		if (this.collection) {
			this.collection.trigger('modelChange');
		} else if (this.parentModel && this.parentModel.collection) {
			this.parentModel.collection.trigger('modelChange');
		}
	},

	parse: function(response, options) {
		this.additionalData = response && response.additional_data;
		this.updateRelatedObjects(response, options);

		if (_.isObject(response.data)) {
			return response.data;
		}

		// old format api
		return response;
	},

	updateRelatedObjects: function(response, options) {
		const relatedObjects = (response && response.related_objects) || {};

		if (options && options.reset) {
			this.relatedObjects = relatedObjects;
		} else {
			this.relatedObjects = _.transform(relatedObjects, (relatedObjects, relatedModelsSet, modelType) => {
				relatedObjects[modelType] = _.transform(relatedModelsSet,
					reduceModelOrObjectAttributes,
					relatedObjects[modelType] || {});

				return relatedObjects;
			}, this.relatedObjects || {});
		}
	},

	getRelatedObjects: function() {
		let relatedObjects;

		if (this.collection && _.isObject(this.collection.relatedObjects)) {
			relatedObjects = this.collection.relatedObjects;
		} else if (_.isObject(this.relatedObjects)) {
			relatedObjects = this.relatedObjects;
		}

		return relatedObjects;
	},

	getRelatedData: function(type, id) {
		let data = null;

		if (id) {
			if (this.collection && this.collection.relatedObjects && this.collection.relatedObjects[type]) {
				data = this.collection.relatedObjects[type][id];
			}

			if (!data && this.relatedObjects && this.relatedObjects[type]) {
				data = this.relatedObjects[type][id];
			}
		}

		return data;
	},

	setRelatedData: function(type, id, data) {
		let relatedObjects;

		if (this.collection) {
			if (_.isObject(this.collection.relatedObjects)) {
				relatedObjects = this.collection.relatedObjects;
			} else {
				this.collection.relatedObjects = relatedObjects = {};
			}
		} else if (_.isObject(this.relatedObjects)) {
			relatedObjects = this.relatedObjects;
		} else {
			this.relatedObjects = relatedObjects = {};
		}

		if (!_.isObject(relatedObjects[type])) {
			relatedObjects[type] = {};
		}

		relatedObjects[type][id] = data;
	},

	getRelatedModel: function(modelType, id) {
		if (!id) {
			return null;
		}

		let model = this.getCachedRelatedModel(modelType, id);

		if (!model) {
			// also get any data available through related objects...
			const data = _.assignIn({}, this.get(modelType), this.getRelatedData(modelType, id));

			if (_.isEmpty(data)) {
				return null;
			}

			this.set(modelType, null, { silent: true });

			// get model class from fieldModelMap
			if (_.isFunction(this.fieldModelMap) && this.fieldModelMap(modelType)) {
				const ModelConstructor = this.fieldModelMap(modelType);

				model = new ModelConstructor(data);
			} else {
				model = new PipedriveModel(data);
			}

			// connect _this_ model to the new model as a parent model
			model.parentModel = this;

			// connect relatedObjects to new model
			model.relatedObjects = this.getRelatedObjects();
			model.relatedModels = this.getRelatedModelsObject();

			this.setCachedRelatedModel(modelType, id, model);
		}

		return model;
	},

	getRelatedModelsObject: function() {
		let relatedModels = {};

		if (this.collection) {
			relatedModels = this.collection.getRelatedModelsObject();
		} else {
			if (!this.relatedModels) {
				this.relatedModels = {};
			}

			relatedModels = this.relatedModels;
		}

		return relatedModels;
	},

	setCachedRelatedModel: function(type, id, model) {
		const relatedModels = this.getRelatedModelsObject();

		if (!relatedModels[type]) {
			relatedModels[type] = {};
		}

		if (relatedModels[type][id]) {
			relatedModels[type][id].set(model);
		} else {
			relatedModels[type][id] = model;
		}
	},

	getCachedRelatedModel: function(type, id) {
		const relatedModels = this.getRelatedModelsObject();

		if (relatedModels[type] && relatedModels[type][id]) {
			return relatedModels[type][id];
		}
	},

	getRelationKeyByType: function(type) {
		let relationKey = null;

		if (_.isFunction(this.fieldModelMap) && this.fieldModelMap(type)) {
			const ModelConstructor = this.fieldModelMap(type);

			relationKey = ModelConstructor.prototype.relationKey;
		}

		return relationKey;
	},

	getContext: function() {
		const contexts = {
			pipeline: 'pipeline',
			timeline: 'timeline',
			mailbox: 'mail_page',
			deals: 'deal_list',
			persons: 'person_list',
			organizations: 'org_list',
			deal: 'deal_details',
			person: 'person_details',
			organization: 'org_details',
		};
		const currentPath = Backbone.History.started ? Backbone.history.getFragment().split('/')[0] : '';

		let context;

		if (typeof app.context === 'undefined') {
			context = 'external';
			app.context = contexts[currentPath];
		} else if (app.context === contexts[currentPath]) {
			context = contexts[currentPath];
		} else {
			context = app.context;
			app.context = contexts[currentPath];
		}

		return context;
	},

	destroy: function(options) {
		this.set('active_flag', false);

		return Backbone.Model.prototype.destroy.call(this, options);
	},

	limitedPull: function(options, beforeStart) {
		if (!this.limiter) {
			this.limiter = new Limiter(this);
		}

		this.limiter.pull(options, beforeStart);
	},

	stopQuery: function() {
		if (this.limiter) {
			this.limiter.cancel();
		}
	},

	isRecentlyCreated: function() {
		return this.isNew() || this.recentlyCreated;
	},

	getOwnerId: function() {
		return this.get(this.ownerKey);
	},

	getOwnerKey: function() {
		return this.ownerKey;
	},

	isDeleted: function() {
		return !this.get('active_flag');
	},

	pull: function(options) {
		let errorCallback;

		if (!options || !_.isObject(options)) {
			options = {};
		}

		if (options.error) {
			errorCallback = options.error;
			delete options.error;
		}

		const defaultOptions = {
			cache: false,
			error: function(model, xhr) {
				if (xhr.statusText === 'abort') {
					if (_.isFunction(options.abort)) {
						options.abort(this);
					}

					return;
				}

				// Let the connectivity-checker check if the network connection is ok
				app.global.fire('app.network.status.ping');

				let errorMessage = xhr.statusText;

				let data = {};

				try {
					data = JSON.parse(xhr.responseText);
				} catch (jsonErr) {
					data = {
						error: `Could not parse API response upon pull (${options.url})` +
								` | clientOnlineStatus = ${navigator && navigator.onLine}`,
					};

					errorMessage = data.error;
				}

				if (xhr.status === 401) {
					location.href = app.config.login;
				} else if (xhr.status === 402) {
					if ('redirect_url' in data) {
						location.href = data.redirect_url;
					}
				}

				logPullError(errorMessage, data, xhr, options, 'get', logger);

				if (_.isFunction(errorCallback)) {
					errorCallback(model, xhr, data ? data : errorMessage);
				}
			},
			data: {
				session_token: cookies.get('pipe-session-token'),
				strict_mode: true,
			},
			xhrFields: {
				withCredentials: true,
			},
		};

			// To enable testing slow connections, uncomment the following line
			// to slow down API responses by X milliseconds (works in dev only):
			// defaultOptions.data._debug_slow_response = 600;

		if ('data' in options) {
			options.data = _.assignIn({}, defaultOptions.data, options.data);
		}

		options.beforeSend = _.bind(this.beforeSend, this);
		options = _.assignIn(defaultOptions, options);
		options.url = _.isFunction(this.url) ? this.url() : this.url;

		this.trigger('afterPull');

		this.lastFetchRequest = this.fetch(options);

		return this.lastFetchRequest;
	},

	/**
		 * Is fetch request not complete
		 * @return {boolean}
		 */
	pulling: function() {
		return this.lastFetchRequest && this.lastFetchRequest.state() === 'pending';
	},

	save: function(key, val, options) {
		let attrs;

		if (!key || typeof key === 'object') {
			attrs = key;
			options = val;
		} else {
			(attrs = {})[key] = val;
		}

		if (!_.isEmpty(attrs)) {
			const oldData = this.toJSON();

			options = options || {};

			// update model
			if (options.wait) {
				options.data = _.assignIn({}, options.data, attrs);
			} else {
				this.set(attrs, options);
			}

			if (options.optimistic) {
				// custom save logic - restores model old state on error
				const error = options.error;

				options.error = function(model, resp, opts) {
					// restore old data
					model.set(oldData, options);

					if (error) {
						error(model, resp, opts);
					}
				};
			}
		}

		if (this.isNew()) {
			this.recentlyCreated = true;
		}

		// call as model.save(null, options);
		this.lastSaveRequest = Backbone.Model.prototype.save.call(this, null, options);

		return this.lastSaveRequest;
	},

	/**
		 * Is save request not complete
		 * @return {boolean}
		 */
	saving: function() {
		return this.lastSaveRequest && this.lastSaveRequest.state() === 'pending';
	},

	// eslint-disable-next-line complexity
	sync: function(method, model, options) {
		if (method === 'create' || method === 'update' || method === 'delete') {
			let successCb;

			if (options.success) {
				successCb = options.success;
				delete options.success;
			}

			let errorCb;

			if (options.error) {
				errorCb = options.error;
				delete options.error;
			}

			if (!options.url) {
				options.url = _.isFunction(model.url) ? model.url(method) : model.url;
			}

			options.contentType = 'application/json';

			if (model instanceof Backbone.Collection) {
				if (!_.isObject(options.data)) {
					options.data = model.toJSON(true);
				}
			} else {
				options.data = _.assignIn(
					options.data || {},
					model.isNew() ? model.toJSON() : (options.wait ? {} : model.changedAttributes())
				);
			}

			options.url += `${options.url.match(/\?/) ? '&' : '?'}session_token=${cookies.get('pipe-session-token')}&strict_mode=true`;

			if (options.query) {
				options.url += `&${options.query}`;
			}

			if (method === 'delete') {
				options.url += `&${$.param(options.data)}`;
				// if given ids, then set data to this, so selected items bulk delete can be performed
				options.data = options.ids || null;
			} else {
				const data = filterReadOnly(options.data, model);

				// Skip save when there's nothing to save
				if (_.isEmpty(data)) {
					return successCb && successCb({
						success: true,
						data: null,
					});
				}

				options.data = JSON.stringify(data);
			}

			options.cache = false;

			if (Backbone.emulateJSON) {
				options.contentType = 'application/x-www-form-urlencoded';
			} else {
				options.processData = false;
			}

			if (options.fileUpload) {
				options = this.fileUpload(options, model);
			}

			options.beforeSend = _.bind(this.beforeSend, this);
			options.xhrFields = { withCredentials: true };

			const callbackOpts = {
				method,
				model,
				options,
				successCb,
				errorCb,
			};

			options.success = _.bind(this.onSyncSuccess, this, callbackOpts);
			options.error = _.bind(this.onSyncError, this, callbackOpts, method);

			apiPendingUpdates.push(this.cid);
		}

		return Backbone.sync(method, model, options);
	},

	/**
		 * Does the file upload thing.
		 * @param  {Object} options 				The sync options
		 * @param  {module:Pipedrive.Model} model 	The model being synced
		 * @return {Object}							The sync options
		 */
	fileUpload: function(options, model) {
		options.contentType = false; // 'multipart/form-data';
		options.processData = false;
		options.data = options.formData;
		options.xhr = function() {
			const xhr = $.ajaxSettings.xhr();

			xhr.withCredentials = true;

			if (xhr.upload) {
				xhr.upload.addEventListener('progress', (evt) => {
					if (evt.lengthComputable) {
						const percentDone = parseInt(100.0 * evt.loaded / evt.total, 10);

						model.set('loading', percentDone, { updateReadonly: true });
					}
				}, false);
			}

			return xhr;
		};

		return options;
	},

	onSyncSuccess: function(callbackOpts, response, statusText, xhr) {
		if (statusText !== 'success') {
			throw new Error(`XHR response: ${xhr.status} ${xhr.statusText}`);
		}

		const model = callbackOpts.model;
		const previousAttributes = model._previousAttributes;

		model.updateRelatedObjects(response);

		if (response.data) {
			model[model instanceof Backbone.Collection ? 'add' : 'set'](response.data, { updateReadonly: true, silent: callbackOpts.options.silent });
		}

		if (_.isFunction(callbackOpts.successCb)) {
			callbackOpts.successCb(response);
		}

		PipedriveModel.prototype.triggerPendingUpdateSyncs(model);
		this.fireGlobalUpdateEvent(model, callbackOpts.method, response, previousAttributes);
	},

	/**
		 * Fire global update event accordingly.
		 */
	fireGlobalUpdateEvent: function(model, method, response, previousAttributes) {
		if (model.type && model.allowDirectSync) {
			if (method === 'create') {
				method = 'add';
			}

			model.triggerSyncEvent(method, response, previousAttributes);
		}
	},

	onSyncError: function(callbackOpts, method, xhr, error) {
		if (xhr.statusText === 'abort') {
			return;
		}

		let errorMessage = xhr.statusText;
		let data = {};

		try {
			data = JSON.parse(xhr.responseText);
		} catch (jsonErr) {
			data = {
				error: `Could not parse API response (${callbackOpts.options.url}) | error = ${JSON.stringify(error)}`,
			};

			if (xhr.status !== 0) {
				logger.error(data.error);
			}

			errorMessage = data.error;
		}

		if (xhr.status === 401) {
			location.href = app.config.login;
		} else if (xhr.status === 402) {
			if ('redirect_url' in data) {
				location.href = data.redirect_url;

				return;
			}
		}

		logPullError(errorMessage, data, xhr, callbackOpts.options, method, logger);

		if (_.isFunction(callbackOpts.errorCb)) {
			callbackOpts.errorCb(xhr);
		}

		PipedriveModel.prototype.triggerPendingUpdateSyncs(callbackOpts.model);
	},

	/**
		 * Triggers pending update syncs that were added to the queue while api requests where being made.
		 * @param  {module:Pipedrive.Model} model
		 * @void
		 */
	triggerPendingUpdateSyncs: function(model) {
		if (_.includes(apiPendingUpdates, model.cid)) {
			apiPendingUpdates = _.without(apiPendingUpdates, model.cid);

			if (!apiPendingUpdates.length && apiPendingUpdateSyncs.length) {
				_.forEach(apiPendingUpdateSyncs, (data) => {
					data.cb.call(data.ctx);
				});
				apiPendingUpdates = [];
				apiPendingUpdateSyncs = [];
			}
		}
	},

	/**
		 * The AJAX beforeSend callback
		 * @param  {Object} xhr
		 * @void
		 */
	beforeSend: function(xhr) {
		if (app.config.version) {
			xhr.setRequestHeader('Js-Version', app.config.version);
		}

		const context = this.getContext();

		if (context) {
			xhr.setRequestHeader('X-Application-Context', context);
		}
	},

	/**
		 * Trigger global events that are mimicing socket events.
		 * @param  {String} method              Method called. Either delete, add or update.
		 * @param  {Object} response            Response object of the request
		 * @param  {Object} previousAttributes  Previous state of the model
		 */
	triggerSyncEvent: function(eventType, response, previousAttributes) {
		let eventData;

		if (eventType === 'delete') {
			eventData = this.id;
		} else {
			eventData = this.getSyncEventData(response, previousAttributes);
		}

		const eventName = `${this.type}.model.${this.get('id')}.${eventType}`;

		logger.log('Triggering sync event', eventName, eventData);
		app.global.fire(eventName, eventData);
	},

	/**
		 * Build the sync event meta data. Can be overridden to provide aditional data per model type.
		 * @param  {Object} response           Response from sync request.
		 * @param  {Object} previousAttributes Previous attributes of the model.
		 * @return {Object}                    Returns model with pervious and meta data.
		 */
	getSyncEventData: function(response, previousAttributes) {
		const self = this;
		const meta = {
			id: this.id,
			timestamp: moment().utc().format('X'),
			user_id: app.global.user_id,
		};

		self.previous = previousAttributes;
		self.meta = meta;

		return self;
	},

	globalSyncUpdate: function(callback, context) {
		if (apiPendingUpdates.length) {
			apiPendingUpdateSyncs.push({ cb: callback, ctx: context });
		} else {
			callback.call(context);
		}
	},

	selfUpdateFromSocket: function() {
		const bindUpdate = function() {
			let eventName = `${this.type}.model.${this.get('id')}.update`;

			app.global.bind(eventName, this.eventFromSocket, this);

			eventName = `${this.type}.model.${this.get('id')}.add`;
			app.global.bind(eventName, this.addEventFromSocket, this);
		};

		if (this.isNew()) {
			this.once('sync', bindUpdate);
		} else if (this.type) {
			bindUpdate.call(this);
		} else {
			logger.warn('Model type is missing in selfUpdateFromSocket');
		}
	},

	selfDeleteFromSocket: function() {
		const eventName = `${this.type}.model.${this.get('id')}.delete`;

		app.global.bind(eventName, this.deleteEventFromSocket, this);
	},

	onChange: function(props, callback, context) {
		if (_.isString(props)) {
			props = props.split(' ');
		}

		this.on('change', (m) => {
			const changedProps = _.keys(m.changedAttributes());

			if (_.intersection(changedProps, props).length) {
				callback.call(context, m);
			}
		}, context);
	},

	eventFromSocket: function(model) {
		const updateKey = 'update_time';
		const oldUpdatedTime = moment(this.get(updateKey)).unix();
		const newUpdatedTime = moment(model.get(updateKey)).unix();

		if (this.get(updateKey) && oldUpdatedTime > newUpdatedTime) {
			logger.log('Preventing model update! Incoming update time older than current model...');

			return;
		}

		if (model.hasOwnProperty('relatedObjects')) {
			this.setRelatedObjectsFromModel(model);
		}

		this.set(model.toJSON(), { updateReadonly: true });

		if (model.hasOwnProperty('meta')) {
			this.unset('_socketPending');
		}
	},

	setRelatedObjectsFromModel: function(model) {
		let relatedObjects;

		if (this.relatedObjects) {
			relatedObjects = this.relatedObjects;
		} else if (this.collection && this.collection.relatedObjects) {
			relatedObjects = this.collection.relatedObjects;
		} else {
			this.relatedObjects = relatedObjects = {};
		}

		_.merge(relatedObjects, model.relatedObjects);
	},

	addEventFromSocket: function(model) {
		if (model.hasOwnProperty('meta') && this.get('_socketPending')) {
			this.unset('_socketPending');
			const eventName = `${this.type}.model.${this.get('id')}.add`;

			app.global.unbind(eventName, this.addEventFromSocket, this);
		}
	},

	deleteEventFromSocket: function() {
		this.trigger('destroy', this, this.collection);
	},

	getDiff: function(newObj, full) {
		const n = newObj.toJSON();
		const o = this.toJSON();
		const extraKeys = _.difference(_.keys(n), _.keys(o));

		if (!full) {
			_.forEach(extraKeys, (key) => {
				delete n[key];
			});
		}

		const newData = _.assignIn({}, o, n);
		const diff = {};

		_.forEach(newData, (val, key) => {
			if (_.isObject(o[key])) {
				if (!_.isEqual(o[key], val)) {
					diff[key] = _.clone(val, true);
				}
			} else if (o[key] !== val) {
				diff[key] = val;
			}
		});

		return diff;
	},

	/**
		 * Remove all global event handlers for internal updates.
		 * Useful when model is not intended for reuse.
		 */
	unbindAllSocketEvents: function() {
		app.global.unbind(`${this.type}.model.${this.get('id')}.add`, this.addEventFromSocket, this);
		app.global.unbind(`${this.type}.model.${this.get('id')}.update`, this.eventFromSocket, this);
		app.global.unbind(`${this.type}.model.${this.get('id')}.delete`, this.deleteEventFromSocket, this);
	},
});

module.exports = PipedriveModel;

function getErrorData(data, xhr, options, method) {
	const err = new Error();

	// NOTE: Should be removed when @pipedrive/logger is upgraded to v8.0.0 in webapp.
	const contentType = xhr.getResponseHeader('content-type');

	if (contentType && contentType.startsWith('text/html')) {
		xhr.responseText = _.truncate(xhr.responseText, {
			length: 1000,
		});
	}

	const errorData = {
		response_text: data.statusText,
		x_correlation_id: xhr.getResponseHeader('x-correlation-id'),
		url: document.location,
		requestUrl: options.url,
		requestData: options.data,
		requestMethod: method,
		service: data.service,
		status_code: data.statusCode,
		stack: err.stack,
		xhr: JSON.stringify(xhr),
	};

	_.each(_.keys(errorData), (key) => {
		if (!errorData[key]) {
			delete errorData[key];
		}
	});

	return errorData;
}

// eslint-disable-next-line max-params
function logPullError(errorMessage, data, xhr, options, method, logger) {
	if (app.ENV === 'live') {
		const errorData = getErrorData(data, xhr, options, method);

		errorMessage = errorData.response_text || errorMessage;

		if (xhr.readyState !== 0) {
			logger.remote('warning', errorMessage, errorData);
		}
	} else {
		logger.log('API error', xhr.status, errorMessage);
	}
}

function filterReadOnly(attrs, model) {
	if (!model) {
		return attrs;
	}

	if (model instanceof Backbone.Collection) {
		return _.map(model.models, (m, i) => {
			return filterReadOnly(attrs[i], m);
		});
	}

	if (_.isArray(model.whitelist)) {
		_.forEach(model.whitelist, (k) => {
			attrs[k] = model.get(k);
		});
	}

	if (_.isArray(model.readonly)) {
		const roKeys = _.intersection(_.keys(attrs), model.readonly);

		_.forEach(roKeys, (k) => {
			delete attrs[k];
		});
	}

	// Remove all _helper fields
	_.forEach(attrs, (value, key) => {
		if (key.match(/_helper$/)) {
			delete attrs[key];
		}
	});

	return attrs;
}

function Limiter(collection, context) {
	let request = null;
	let sent = false;
	let started = false;
	let timer = null;
	let lastQuery = '';
	let lastResultSet = null;

	context = context || collection;

	const req = function(opts, startup) {
		const callback = opts.success;

		if (opts === lastQuery) {
			if (typeof callback === 'function') {
				callback.call(context, lastResultSet.a, lastResultSet.b, lastResultSet.c);
			}

			return;
		}

		if (collection.additional_parameters) {
			_.forEach(collection.additional_parameters, (val, key) => {
				opts.data[key] = val;
			});
		}

		if (_.isObject(collection.options) && _.isObject(collection.options.params)) {
			_.forEach(collection.options.params, (val, key) => {
				opts.data[key] = val;
			});
		}

		if (typeof startup === 'function') {
			startup.call(context);
		}

		lastQuery = _.clone(opts);

		opts.success = function(a, b, c) {
			sent = false;
			lastResultSet = {
				a, b, c,
			};

			if (typeof callback === 'function') {
				callback.call(context, lastResultSet.a, lastResultSet.b, lastResultSet.c);
			}
		};

		request = collection.pull(opts);
		sent = true;
	};

	return {
		pull: function(opts, startup) {
			if (sent) {
				request.abort();
				sent = false;

				return;
			} else if (started) {
				clearTimeout(timer);
				timer = null;
			}

			// Buffer for typing
			timer = setTimeout(() => {
				req(opts, startup);
			}, 350);
			started = true;
		},
		cancel: function() {
			if (sent) {
				request.abort();
				sent = false;

				if (started) {
					clearTimeout(timer);
					timer = null;
				}
			} else if (started) {
				clearTimeout(timer);
				timer = null;
			}
		},
	};
}
