const Backbone = require('backbone');
const $ = require('jquery');
const _ = require('lodash');
const eventHandlers = require('./events');
const Logger = require('@pipedrive/logger-fe').default;
const logger = new Logger('webapp-core', 'view');

let local;

/**
 * Pipedrive View extends BackboneJS (see {@link http://backbonejs.org/#View}).
 * @name     View
 * @class    Pipedrive View class
 * @extends  Backbone.View
 * @memberOf module:Pipedrive
 */
const View = Backbone.View.extend({
	bind: eventHandlers.bind,
	unbind: eventHandlers.unbind,
	fire: eventHandlers.fire,

	/**
	 * Override Backbone.View constructor to introduce load method.
	 * @param  {Options} options
	 * @return {Mixed}
	 */
	constructor: function(...args) {
		const result = Backbone.View.prototype.constructor.apply(this, args);

		this.load();

		return result;
	},

	/**
	 * Load the view. If onLoad is defined then call it.
	 * Load can be called multiple times and actions done in load and unLoad should be countered in unload.
	 */
	load: function() {
		if (_.isFunction(this.onLoad)) {
			this.onLoad();
		}
	},

	/**
	 * Pull method
	 *
	 * @param  {Pipedrive.Collection|Pipedrive.Model} collection Model or
	 *                                                Collection to pull
	 * @param  {Object} settings Pull settings
	 * @return {XMLHttpRequest}
	 */
	pull: function(collection, settings) {
		if (!this.requests) {
			this.requests = {};
		}

		if (!collection) {
			return;
		}

		if (!settings) {
			settings = {};
		}

		const self = this;
		const hash = _.makeid();

		settings.onSuccess = settings.success;
		settings.success = function(...args) {
			delete self.requests[hash];

			if (_.isFunction(settings.onSuccess)) {
				settings.onSuccess.apply(self, args);
			}
		};

		settings.onError = settings.error;
		settings.error = function(...args) {
			delete self.requests[hash];

			if (_.isFunction(settings.onError)) {
				settings.onError.apply(self, args);
			}
		};

		this.requests[hash] = collection.pull(settings); // not push but store with hash in an object

		return this.requests[hash];
	},

	/**
	 * Set timeout with automatic clearing when view is unloaded
	 * @param  {Function} callback
	 * @param  {number}   time
	 * @return {number}   timeoutId
	 */
	setTimeout: function(callback, time) {
		if (!this.timeouts) {
			this.timeouts = {};
		}

		if (!_.isFunction(callback)) {
			return;
		}

		if (!_.isInteger(time)) {
			time = 0;
		}

		const self = this;
		const hash = _.makeid();

		if (!this.timeouts[this.cid]) {
			this.timeouts[this.cid] = {};
		}

		this.timeouts[this.cid][hash] = setTimeout(() => {
			callback.call();
			delete self.timeouts[self.cid][hash];
		}, time);

		return this.timeouts[this.cid][hash];
	},

	/**
	 * Clears all timeouts
	 */
	clearTimeouts: function() {
		if (this.timeouts) {
			_.forEach(this.timeouts[this.cid], _.bind(function(timeout, hash) {
				clearTimeout(timeout);
				delete this.timeouts[this.cid][hash];
			}, this));
		}
	},

	/**
	 * Set interval with automatic clearing when view is unloaded
	 * @param  {Function} callback
	 * @param  {number}   time
	 * @return {number}   intervalId
	 */
	setInterval: function(callback, time) {
		if (!this.intervals) {
			this.intervals = {};
		}

		if (!_.isFunction(callback)) {
			return;
		}

		if (!_.isInteger(time)) {
			time = 0;
		}

		const hash = _.makeid();

		if (!this.intervals[this.cid]) {
			this.intervals[this.cid] = {};
		}

		this.intervals[this.cid][hash] = setInterval(() => {
			callback.call();
		}, time);

		return this.intervals[this.cid][hash];
	},

	/**
	 * Clears all intervals
	 */
	clearIntervals: function() {
		if (this.intervals) {
			_.forEach(this.intervals[this.cid], _.bind(function(interval, hash) {
				clearInterval(interval);
				delete this.intervals[this.cid][hash];
			}, this));
		}
	},

	/**
	 * add child view or views
	 * @example
	 * <caption>Example how to add one view or multiple</caption>
	 * // add one view to specific selector
	 * this.addView('.myComponentDiv', this.myComponentView);
	 *
	 * // or add as bulk
	 * this.addView({
	 *   '.flowCompose': this.compose,
	 *   '.pinnedNotes': this.pinnedNotesView
	 * });
	 *
	 *
	 * @param {Mixed} selector 				(jquery) selector or object
	 * @param {module:Pipedrive.View} view 	View to be added
	 * @void
	 */
	addView: function(selector, view) {
		let views = selector;

		const viewsToAttach = [];

		if (!_.isObject(views)) {
			views = {};
			views[selector] = view;
		}

		this.views = _.assignIn(this.views || {}, views);

		_.forEach(views, _.bind(function(view, selector) {
			if (view && (view.notifyDOM || view.onAttachedToDOM)) {
				view.notifyDOM = true;
				this.notifyDOM = true;
			}

			// Collect selectors of the views that can be attached
			if (this.toAttach(selector)) {
				viewsToAttach.push(selector);
			}
		}, this));

		this.detachViews(viewsToAttach);
		this.attachViews(viewsToAttach);
	},

	/**
	 * Checks, by the jQuery selector, whether the element is in the parent view's DOM element
	 * and whether the element is empty.
	 * @param  {String} selector 	jQuery selector
	 * @return {Boolean}
	 */
	toAttach: function(selector) {
		return this.$(selector).length && !this.$(selector).html();
	},

	/**
	 * Remove a view by given selector
	 * @param  {String} selector 	(jQuery) selector
	 * @param  {Boolean} toEmpty 	If "true", empties the view's container, without removing the container
	 *                            	Also, see method "destroy"
	 * @void
	 */
	removeView: function(selector, toEmpty) {
		if (_.isObject(this.views) && _.isString(selector)) {
			const view = this.views[selector];

			if (view) {
				view.destroy(toEmpty);
			}

			delete this.views[selector];
		}
	},

	/**
	 * get child view by selector
	 * @param  {string} selector
	 * @return {view}
	 */
	getView: function(selector) {
		return _.isObject(this.views) && this.views[selector];
	},

	/**
	 * Detach child views from DOM - must be called before major changes to this.$el (or childs components will break!)
	 * If no views passed in, will detach all views that are currently in this.views. The views that are passed in and are not
	 * in this.views, will simply be ignored.
	 *
	 * @param  {Array} views 			(optional) List of jquery selectors represtening the views to be detached
	 * @param  {Object} renderOptions 	(optional) Options to be passed on when calling onDetachedFromDOM
	 * @void
	 */
	detachViews: function(views, renderOptions) {
		if (!_.isObject(this.views)) {
			return;
		}

		views = _.isArray(views) ? views : _.keys(this.views);

		// detach subviews from DOM to prevent events getting lost
		_.forEach(views, _.bind(function(selector) {
			const subview = this.views[selector];

			if (subview) {
				// wrapped into to if for performance reasons
				if (subview.notifyDOM) {
					const isAttachedToDOM = this.$el.parents('body').length > 0;

					if (isAttachedToDOM) {
						notifyDetachedDOM(subview);
					}
				}

				subview.$el.detach();
			}
		}, this));

		function notifyDetachedDOM(view) {
			if (!view || !view.notifyDOM) {
				return;
			}

			if (view.views) {
				_.forEach(view.views, notifyDetachedDOM);
			}

			if (_.isFunction(view.onDetachedFromDOM)) {
				view.onDetachedFromDOM(renderOptions);
			}
		}

		return this;
	},

	/**
	 * Attach child views to right places in updated DOM. Call after making major changes to element (after template rendering).
	 * If no views passed in, will attach all views that are currently in this.views. The views that are passed in and are not
	 * in this.views, will simply be ignored.
	 *
	 * @param  {Array} views 			(optional) List of jquery selectors represtening the views to be attached
	 * @param  {Object} renderOptions 	(optional) Options to be passed on when calling onAttachedToDOM
	 * @void
	 */
	attachViews: function(views, renderOptions) {
		views = _.isArray(views) ? views : _.keys(this.views);

		// attach subviews back to their containers by selectors
		_.forEach(views, _.bind(function(selector) {
			const subview = this.views[selector];

			if (subview) {
				const $container = this.$(selector);

				if ($container.length) {
					$container.replaceWith(subview.$el);

					// Move all attributes to the new element
					const attrs = $container.get(0).attributes;

					for (let i = 0; i < attrs.length; i++) {
						// Merge class names between container and sub view
						if (attrs[i].name === 'class') {
							subview.$el.addClass(attrs[i].value);
						} else {
							subview.$el.attr(attrs[i].name, attrs[i].value);
						}
					}

					// wrapped into to if for performance reasons
					if (subview.notifyDOM) {
						const isAttachedToDOM = this.$el.parents('body').length > 0;

						if (isAttachedToDOM) {
							notifyAttachedDOM(subview);
						}
					}
				}
			}
		}, this));

		function notifyAttachedDOM(view) {
			if (!view || !view.notifyDOM) {
				return;
			}

			if (view.views) {
				_.forEach(view.views, notifyAttachedDOM);
			}

			if (_.isFunction(view.onAttachedToDOM)) {
				view.onAttachedToDOM(renderOptions);
			}

			view.trigger('attachedToDOM');
		}
	},

	/**
	 * Render method for updateing browser DOM with own template and subviews.
	 * Calls this.onRender method for view own template render.
	 *
	 * Next example is the most common way how to use rendering with subviews.
	 *
	 * @example
	 * <caption>This is example of view class called "Page" that has one child view called "Product"</caption>
	 *  define([
	 *      'pipedrive',
	 *      'views/product',
	 *      'text!templates/page.html',
	 *  ],
	 *  function(Pipedrive, ProductView, PageTemplate) {
	 *
	 *      // this is main page view class
	 *      return Pipedrive.View.extend({
	 *          template: _.template(PageTemplate),
	 *          productView: null,
	 *
	 *          initialize: function(options) {
	 *
	 *              // on page there is one product child view
	 *              // create it without element - render will attach it to right div
	 *              this.productView = new ProductView({
	 *                  id: 123,
	 *              });
	 *
	 *              // connect child view to one DOM element by css selector.
	 *              this.addView('.productDiv', this.productView);
	 *
	 *              //call render to run template and connect child views
	 *              //render method is already defined in Pipedrive.View base class
	 *              this.render();
	 *          },
	 *
	 *          onRender: function() {
	 *              this.$el.html(this.template(this));
	 *          }
	 *      });
	 *  });
	 *
	 * @param {object} options Options to pass to render methods
	 * @return {module:Pipedrive.View}
	 */
	render: function(options) {
		const focusEl = document.activeElement;

		if (_.isFunction(this.beforeRender)) {
			this.beforeRender(options);
		}

		this.trigger('beforeRender');

		this.detachViews(null, options);

		// this.onRender is defined in inherited view
		// must update innerHtml of view
		if (_.isFunction(this.onRender)) {
			logger.log('Deprecated: Use this.selfRender');
			this.onRender(options);
		}

		if (_.isFunction(this.selfRender)) {
			this.selfRender(options);
		}

		this.attachViews(null, options);

		if (_.isFunction(this.afterRender)) {
			this.afterRender(options);
		}

		this.trigger('afterRender');

		this.focusElementAfterRender(focusEl);

		this.focus();

		return this;
	},

	/**
	 * Renders current template with templatevariables
	 */
	selfRender: function() {
		const templateHelpers = this.getTemplateHelpers();

		if (_.isObject(templateHelpers)) {
			this.$el.html(this.template(templateHelpers));
		}
	},

	/**
	 * Variables required for rendering the template associated with the view.
	 * @type {object|function|null}
	 */
	templateHelpers: null,

	/**
	 * Parses templateHelpers and returns an object.
	 * @return {object} Parsed template helpers.
	 */
	getTemplateHelpers: function() {
		let helpers = this.templateHelpers;

		if (_.isFunction(helpers)) {
			helpers = helpers.call(this);
		}

		return helpers;
	},

	/**
	 * Unloads means removing removing all event listeners, timeouts, stopping requests that are connected to this view.
	 * @return {module:Pipedrive.View}
	 */
	unload: function() {
		this.undelegateEvents();

		this.clearTimeouts();
		this.clearIntervals();
		this.stopListening();

		// Abort all active requests when unloading view
		if (this.requests) {
			_.forEach(this.requests, (req) => {
				if (_.isObject(req) && _.isFunction(req.abort)) {
					req.abort();
				}
			});
		}

		if (_.isFunction(this.onUnload)) {
			this.onUnload();
		}

		this.blur();

		return this;
	},

	/**
	 * Destroys current view
	 * @param  {Boolean} toEmpty 		If "true", empties the view's container, without removing the container
	 * @return {module:Pipedrive.View} 	Returns current view
	 */
	destroy: function(toEmpty) {
		// clean child views
		_.forEach(this.views, (view) => {
			if (view) {
				view.destroy();
			}
		});

		// clean us also
		this.unload();
		this.$el[toEmpty ? 'empty' : 'remove']();

		if (_.isFunction(this.onDestroy)) {
			this.onDestroy();
		}

		return this;
	},
	onDocument: function(...args) {
		local.onGlobal.call(this, 'document', args);
	},
	offDocument: function(...args) {
		local.offGlobal.call(this, 'document', args);
	},
	onWindow: function(...args) {
		local.onGlobal.call(this, 'window', args);
	},
	offWindow: function(...args) {
		local.offGlobal.call(this, 'window', args);
	},
	focusElementAfterRender: function(el) {
		if (el && document.activeElement !== el) {
			$(el).focus();
		}
	},
	/**
	 * Focuses the current view (puts it to foreground from hibernation as well as activates it upon render)
	 * @return {module:Pipedrive.View}
	 */
	focus: function() {
		if (this.focused) {
			return;
		}

		this.focused = true;

		if (this.globalHandlers) {
			_.forEach(this.globalHandlers, (handlers, type) => {
				const target = local.getGlobalHandlerTarget(type);

				_.forEach(handlers, (args) => {
					target.on.apply(target, args);
				});
			});
		}

		_.forEach(this.views, (subview) => {
			if (subview) {
				subview.focus();
			}
		});

		if (_.isFunction(this.onFocus)) {
			this.onFocus();
		}

		if (this.focusQueue) {
			_.forEach(this.focusQueue, _.bind(function(callback, key) {
				// eslint-disable-next-line callback-return
				callback();
				delete this.focusQueue[key];
			}, this));
		}

		this.trigger('focus');
	},
	/**
	 * Blurs the current view (puts it to background for hibernation)
	 * @return {module:Pipedrive.View}
	 */
	blur: function() {
		if (!this.focused) {
			return;
		}

		this.focused = false;

		if (this.globalHandlers) {
			_.forEach(this.globalHandlers, (handlers, type) => {
				const target = local.getGlobalHandlerTarget(type);

				_.forEach(handlers, (args) => {
					target.off.apply(target, args);
				});
			});
		}

		_.forEach(this.views, (subview) => {
			if (subview) {
				subview.blur();
			}
		});

		if (_.isFunction(this.onBlur)) {
			this.onBlur();
		}

		if (this.blurQueue) {
			_.forEach(this.blurQueue, _.bind(function(callback, key) {
				// eslint-disable-next-line callback-return
				callback();
				delete this.blurQueue[key];
			}, this));
		}

		this.trigger('blur');
	},
	/**
	 * Queue callbacks that should only be run when the view is focused.
	 * The callbacks must have uniqueness defined by key.
	 * If view is focused then the callback is called instantly.
	 * @param  {String}   key
	 * @param  {Function} callback
	 */
	queueFocus: function(key, callback) {
		if (!_.isFunction(callback)) {
			return;
		}

		this.focusQueue = this.focusQueue || {};

		if (this.focused) {
			return callback();
		} else {
			this.focusQueue[key] = callback;
		}
	},
	/**
	 * Queue callbacks that should only be run when the view is blured.
	 * The callbacks must have uniqueness defined by key.
	 * If view is not focused then the callback is called instantly.
	 * @param  {String}   key
	 * @param  {Function} callback
	 */
	queueBlur: function(key, callback) {
		if (!_.isFunction(callback)) {
			return;
		}

		this.blurQueue = this.blurQueue || {};

		if (this.focused) {
			this.blurQueue[key] = callback;
		} else {
			return callback();
		}
	},
	done: function(callback) {
		if (_.isFunction(callback)) {
			// eslint-disable-next-line callback-return
			callback();
		}

		return this;
	},
});

local = {
	/**
	 * Possible global handler targets.
	 * @type {Object}
	 */
	globalHandlerTargets: {
		document: $(document),
		window: $(window),
	},

	/**
	 * Get a global handler target by types.
	 * @param  {String} type
	 * @return {Object}      An object with on and off methods.
	 */
	getGlobalHandlerTarget: function(type) {
		if (local.globalHandlerTargets.hasOwnProperty(type)) {
			return local.globalHandlerTargets[type];
		} else {
			throw new Error('Invalid global handler type');
		}
	},

	/**
	 * Returns the handler collection for specific type.
	 * @param  {String} type
	 * @return {Object}      Object containing handlers.
	 */
	getGlobalHandlerCollection: function(type) {
		if (!this.globalHandlers) {
			this.globalHandlers = {};
		}

		if (!this.globalHandlers.hasOwnProperty(type)) {
			this.globalHandlers[type] = {};
		}

		return this.globalHandlers[type];
	},

	/**
	 * Registers an event to be bound on specified scope.
	 * @param  {String} type
	 * @param  {Array}  args Arguments to be bound.
	 * @void
	 */
	onGlobal: function(type, args) {
		const target = local.getGlobalHandlerTarget.call(this, type);
		const collection = local.getGlobalHandlerCollection.call(this, type);

		if (collection[args[0]]) {
			logger.warn(`Registration of multiple ${type} handlers called ${args[0]} by the same view. Possible leak! ${new Error('').stack}`);
		}

		collection[args[0]] = args;

		if (this.focused) {
			target.on.apply(target, args);
		}
	},

	/**
	 * Registers an event to be unbound on specified scope.
	 * @param  {String} type
	 * @param  {Array}  args Arguments to be bound.
	 * @void
	 */
	offGlobal: function(type, args) {
		const target = local.getGlobalHandlerTarget.call(this, type);
		const collection = local.getGlobalHandlerCollection.call(this, type);

		if (collection[args[0]]) {
			delete collection[args[0]];
			target.off.apply(target, args);
		}
	},
};

module.exports = View;