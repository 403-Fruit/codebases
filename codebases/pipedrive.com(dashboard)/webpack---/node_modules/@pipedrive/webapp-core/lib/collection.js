/* eslint-disable no-undefined */
const Backbone = require('backbone');
const _ = require('lodash');
const PipedriveModel = require('./model');

/**
 * Pipedrive Collection extends BackboneJS (see {@link http://backbonejs.org/#Collection}).
 * @name     Collection
 * @class    Pipedrive Collection class
 * @extends  Backbone.Collection
 * @memberOf module:Pipedrive
 */
const PipedriveCollection = Backbone.Collection.extend(/** @lends Collection.prototype */ {
	// methods borrowed from model
	sync:                       PipedriveModel.prototype.sync,
	beforeSend:                 PipedriveModel.prototype.beforeSend,
	onSyncSuccess:              PipedriveModel.prototype.onSyncSuccess,
	onSyncError:                PipedriveModel.prototype.onSyncError,
	fireGlobalUpdateEvent:      PipedriveModel.prototype.fireGlobalUpdateEvent,
	triggerPendingUpdateSyncs:  PipedriveModel.prototype.triggerPendingUpdateSyncs,

	save:             PipedriveModel.prototype.save,
	destroy:          PipedriveModel.prototype.destroy,
	limitedPull:      PipedriveModel.prototype.limitedPull,
	globalSyncUpdate: PipedriveModel.prototype.globalSyncUpdate,
	stopQuery:        PipedriveModel.prototype.stopQuery,
	onChange:         PipedriveModel.prototype.onChange,
	pull:             PipedriveModel.prototype.pull,
	pulling:          PipedriveModel.prototype.pulling,

	// duplicate all related objects logic from model
	updateRelatedObjects: PipedriveModel.prototype.updateRelatedObjects,
	getRelatedData:       PipedriveModel.prototype.getRelatedData,
	setRelatedData:       PipedriveModel.prototype.setRelatedData,

	getRelatedModel:        PipedriveModel.prototype.getRelatedModel,
	getRelatedModelsObject: PipedriveModel.prototype.getRelatedModelsObject,
	getCachedRelatedModel:  PipedriveModel.prototype.getCachedRelatedModel,
	setCachedRelatedModel:  PipedriveModel.prototype.setCachedRelatedModel,

	getContext: PipedriveModel.prototype.getContext,

	pullLimit: 50,

	additionalData: null,

	requiredFields: ['id', 'active_flag'],

	add: function(models, options) {
		if (options && options.add && models) {
			for (let i = 0, length = models.length; i < length; i++) {
				const existing = this.where({ id: models[i].id });

				if (existing.length) {
					existing[0].set(models[i]);
				}
			}
		}

		return Backbone.Collection.prototype.add.call(this, models, options);
	},

	getNewModels: function() {
		return _.filter(this.models, (model) => {
			return model.isNew();
		});
	},

	isNew: function() {
		return this.getNewModels().length > 0;
	},

	parse: function(response, options) {
		this.additionalData = response && response.additional_data;
		this.updateRelatedObjects(response, options);

		return (response.hasOwnProperty('data') ? response.data : response);
	},

	toJSON: function(newModels) {
		if (newModels) {
			return _.map(this.getNewModels(), (model) => {
				return model.toJSON();
			});
		}

		return Backbone.Collection.prototype.toJSON.call(this);
	},

	/**
	 * Sets the comparator for the collection. By default does the same as
	 * setting this.comparator in a collection. However, it can also
	 * automatically create a comparator that compares the values of the
	 * collection models’ submodels. To sort by submodel, the model has to
	 * have a ‘submodel’ property, and the method attribute has to have
	 * submodel name as a prefix for the comparator.
	 *
	 * @example
	 * <caption>Usage of the comparators</caption>
	 * // Sets regular comparator, sorts by ‘name’
	 * collection.setComparator('name');
	 *
	 * // Sets method as a comparator
	 * collection.setComparator(myComparatorFunction);
	 *
	 * // Sorts collection by submodel ‘name’
	 * collection.setComparator('submodel.name');
	 *
	 * @param {String|function} comparator Comparator to set
	 * @param {boolean} reverse optional argument to reverse sorting order
	 */
	setComparator: function(comparator, reverse) {
		if (!comparator) {
			return;
		}

		this.comparator = comparator;

		// If collection models have submodels, and comparator is String
		if (_.isString(comparator)) {
			if (this.model.prototype.submodel && comparator.indexOf(`${this.model.prototype.submodel}.`) === 0) {
				// If comparator name contains submodel prefix,
				// e.g. ‘person.name’, and submodel value is ‘person’, then the
				// collection is sorted by submodel values
				this.comparator = createSubmodelComparator(this, comparator);
			} else {
				this.comparator = createComparator(this, comparator);
			}
		}

		this.reversed = reverse;
	},

	getCollectionModelType: function() {
		return (this.model.prototype.type || null);
	},

	sort: function(options) {
		// use original sort with silent: true
		Backbone.Collection.prototype.sort.call(this, { silent: true });

		if (this.reversed) {
			this.models.reverse();
		}

		if (!(options || {}).silent) {
			this.trigger('sort', this, options);
		}

		return this;
	},

	pullPage: function(options) {
		options = options || {};

		if (options.reset) {
			if (this.pulling()) {
				this.lastFetchRequest.abort();
			}
		} else {
			if (!this.hasMore() || this.pulling()) {
				return false;
			}

			_.assignIn(options, {
				update: true,
				remove: false,
			});
		}

		options.data = _.assignIn({
			start: options.reset ? 0 : this.nextStart(),
			limit: this.pullLimit,
		}, options.data);

		let pull;

		if (options.view) {
			pull = options.view.pull(this, options);
		} else {
			pull = this.pull(options);
		}

		return pull;
	},

	/**
	 * Are we on the first page
	 * @return {boolean}
	 */
	atStart: function() {
		return (this.additionalData && this.additionalData.pagination && this.additionalData.pagination.start === 0);
	},

	/**
	 * Are there more data?
	 * @return {boolean}
	 */
	hasMore: function() {
		return (
			this.additionalData && this.additionalData.pagination && this.additionalData.pagination.more_items_in_collection
		);
	},

	/**
	 * Has collection been pulled ever
	 * @return {Boolean}
	 */
	isPulled: function() {
		return !!this.additionalData;
	},

	/**
	 * Next start position of threads
	 * @return {integer}
	 */
	nextStart: function() {
		return this.additionalData ? this.additionalData.pagination.next_start : 0;
	},

	/**
	 * Get limit for pagination
	 * @return {integer}
	 */
	pageLimit: function() {
		return this.additionalData.pagination.limit;
	},

	getOwnerKey: function() {
		return this.model.prototype.getOwnerKey();
	},
});

module.exports = PipedriveCollection;

// Helper methods
/**
 * Creates a comparator for the collection which sorts by submodel
 * @param  {module:Pipedrive.Collection} collection Collection to create
 *                                                  the comparator function
 *                                                  for
 * @param  {String} field Field to sort the collection by
 * @return {function} comparator Returns the comparator method for the
 *                               collection
 */
function createSubmodelComparator(collection, field) {
	if (!collection.model || !collection.model.prototype.submodel) {
		return null;
	}

	const submodel = collection.model.prototype.submodel;

	field = field.replace(`${submodel}.`, '');

	/**
	 * Used as a default sorter for submodel ordering
	 *
	 * @private
	 * @param {Object} a The object to compare to `b`.
	 * @param {Object} b The object to compare to `a`.
	 * @returns {number} Returns the sort order indicator of `1` or `-1`.
	 */
	// eslint-disable-next-line complexity
	return function(a, b) {
		const am = a[submodel];
		const bm = b[submodel];

		let ac = am && am.get(field);
		let bc = bm && bm.get(field);

		// If submodel is undefined, push it to bottom
		if (!am) {
			return 1;
		}

		if (!bm) {
			return -1;
		}

		if (ac === undefined || ac === null) {
			ac = '';
		}

		if (bc === undefined || bc === null) {
			bc = '';
		}

		let index = -1;

		const length = ac.length;

		while (++index < length) {
			const value = ac[index];
			const other = bc[index];

			if (value !== other) {
				if (value > other || typeof value === 'undefined') {
					return 1;
				}

				if (value < other || typeof other === 'undefined') {
					return -1;
				}
			}
		}

		return ac - bc;
	};
}

function createComparator(collection, field) {
	// eslint-disable-next-line complexity
	return function(a, b) {
		let an = a.get(field);
		let bn = b.get(field);

		if (an === undefined || an === null) {
			an = '';
		}

		if (bn === undefined || bn === null) {
			bn = '';
		}

		if (_.isString(an) && _.isString(bn)) {
			an = an.toLowerCase();
			bn = bn.toLowerCase();
		}

		let index = -1;

		const length = an.length;

		while (++index < length) {
			const value = an[index];
			const other = bn[index];

			if (value !== other) {
				if (value > other || typeof value === 'undefined') {
					return 1;
				}

				if (value < other || typeof other === 'undefined') {
					return -1;
				}
			}
		}

		return an - bn;
	};
}