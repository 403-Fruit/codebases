import React__default, { Component, createElement, useRef, useState, useEffect, memo, useCallback, useMemo, createContext as createContext$1, useContext, forwardRef, useReducer, cloneElement, PureComponent, useImperativeHandle, Fragment } from 'react';
import PropTypes from 'prop-types';
import ReactDOM, { createPortal } from 'react-dom';

var config = {
  prefix: 'cui4'
};
var cuiClassName = function cuiClassName(className) {
  return "".concat(config.prefix, "-").concat(className.trim());
};

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

/**
 * Trigger multiple references for a single node.
 * It checks the type of the reference if it's either created by React.createRef() or simply a function.
 * Updates both types of references with the node.
 * You can pass as many references as you want.
 */
var triggerReferences = function triggerReferences(node) {
  for (var _len = arguments.length, references = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    references[_key - 1] = arguments[_key];
  }

  references.forEach(function (reference) {
    if (reference && reference.hasOwnProperty('current')) {
      reference.current = node;
    } else if (typeof reference === 'function') {
      reference(node);
    }
  });
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

var indexOf = [].indexOf;

var indexof = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

var ap      = Array.prototype;
var concat  = ap.concat;
var slice   = ap.slice;


function except(object) {
  var result = {};
  var keys = concat.apply(ap, slice.call(arguments, 1));

  for (var key in object) {
    if (indexof(keys, key) === -1) {
      result[key] = object[key];
    }
  }

  return result;
}

var except_1 = except;

var global$1 = (typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {});

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance$1 = global$1.performance || {};
var performanceNow =
  performance$1.now        ||
  performance$1.mozNow     ||
  performance$1.msNow      ||
  performance$1.oNow       ||
  performance$1.webkitNow  ||
  function(){ return (new Date()).getTime() };

var invariant = function(condition, format, a, b, c, d, e, f) {
  {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

var invariant_1 = invariant;

var passthrough_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = passthrough;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



var _except2 = _interopRequireDefault(except_1);



var _invariant2 = _interopRequireDefault(invariant_1);

function passthrough() {
  var _ref = arguments[0] === undefined ? {} : arguments[0];

  var _ref$force = _ref.force;
  var force = _ref$force === undefined ? [] : _ref$force;
  var _ref$omit = _ref.omit;
  var omit = _ref$omit === undefined ? ['children'] : _ref$omit;
  var _ref$omitKnownPropTypes = _ref.omitKnownPropTypes;
  var omitKnownPropTypes = _ref$omitKnownPropTypes === undefined ? true : _ref$omitKnownPropTypes;

  return function decorator(component) {
    (0, _invariant2['default'])(!component.prototype.passthrough, '@passthrough must be applied to a class with no `passthrough` property');

    if (omitKnownPropTypes) {
      omit.push.apply(omit, Object.keys(component.propTypes || {}));
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = force[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;

        var i = omit.indexOf(prop);
        if (i != -1) {
          omit.splice(i, 1);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    component.prototype.passthrough = function passthrough() {
      return (0, _except2['default'])(this.props, omit);
    };
  };
}

module.exports = exports['default'];
});

var passthrough = unwrapExports(passthrough_1);

var Icon = /*#__PURE__*/function (_Component) {
  _inherits(Icon, _Component);

  var _super = _createSuper(Icon);

  function Icon() {
    _classCallCheck(this, Icon);

    return _super.apply(this, arguments);
  }

  _createClass(Icon, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          color = _this$props.color,
          size = _this$props.size,
          icon = _this$props.icon,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('icon'), _defineProperty({}, cuiClassName("icon--".concat(color)), color), _defineProperty({}, cuiClassName("icon--".concat(size)), size), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var sizeMod = size === 's' ? 'sm-' : ''; // Deal with error case and size modifier

      var content = /*#__PURE__*/React__default.createElement("div", null, "Icon Address must be Specified "); // SVG Icons

      if (icon) {
        var iconID = "icon-".concat(sizeMod).concat(icon);
        var iconAddress = "#".concat(iconID);
        content = /*#__PURE__*/React__default.createElement("svg", props, /*#__PURE__*/React__default.createElement("use", {
          href: iconAddress,
          xlinkHref: iconAddress
        }));
      } // Return Icon Component


      return content;
    }
  }]);

  return Icon;
}(Component);
Icon.propTypes = {
  icon: PropTypes.string.isRequired,
  color: PropTypes.oneOf(['white', 'black', 'black-88', 'black-64', 'black-32', 'black-24', 'black-16', 'black-12', 'black-8', 'black-4', 'red-shade', 'red', 'red-tint', 'green-shade', 'green', 'green-tint', 'blue-shade', 'blue', 'blue-tint', 'yellow', 'yellow-tint', 'purple']),
  size: PropTypes.oneOf(['s']),
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
Icon.defaultProps = {};
passthrough()(Icon);

var Spinner = /*#__PURE__*/function (_Component) {
  _inherits(Spinner, _Component);

  var _super = _createSuper(Spinner);

  function Spinner() {
    _classCallCheck(this, Spinner);

    return _super.apply(this, arguments);
  }

  _createClass(Spinner, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          size = _this$props.size,
          light = _this$props.light,
          darkBackground = _this$props.darkBackground,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('spinner'), _defineProperty({}, cuiClassName("spinner--".concat(size)), size), _defineProperty({}, cuiClassName('spinner--light'), light), _defineProperty({}, cuiClassName('spinner--dark-background'), darkBackground), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      return /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('spinner__trail')
      }), this.props.size === 'xl' && /*#__PURE__*/React__default.createElement(Icon, {
        className: cuiClassName('spinner__icon'),
        icon: "logo-p"
      }));
    }
  }]);

  return Spinner;
}(Component);
Spinner.propTypes = {
  size: PropTypes.oneOf(['s', 'l', 'xl']),
  light: PropTypes.bool,
  darkBackground: PropTypes.bool,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Spinner);

var Button = /*#__PURE__*/function (_Component) {
  _inherits(Button, _Component);

  var _super = _createSuper(Button);

  function Button() {
    _classCallCheck(this, Button);

    return _super.apply(this, arguments);
  }

  _createClass(Button, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          color = _this$props.color,
          size = _this$props.size,
          children = _this$props.children,
          href = _this$props.href,
          active = _this$props.active,
          disabled = _this$props.disabled,
          loading = _this$props.loading,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('button'), _defineProperty({}, cuiClassName("button--".concat(color)), color), _defineProperty({}, cuiClassName('button--s'), size === 's'), _defineProperty({}, cuiClassName('button--active'), active), _defineProperty({}, cuiClassName('button--loading'), loading), givenClassName);

      var props = _objectSpread2(_objectSpread2(_objectSpread2({
        className: className
      }, (disabled || loading) && {
        disabled: true
      }), forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      if (props.disabled) {
        delete props.href;
        delete props.onClick;
      } else if (href) {
        props.href = href;
      }

      var hasColor = !!color && color !== 'ghost'; // Check if child is textNode and wrap it with span

      var content = React__default.Children.map(children, function (child) {
        if (child) {
          if (child.type) {
            // If child is an icon for a colored button change the icon to white
            if (hasColor && child.type === Icon && !child.props.color) {
              return /*#__PURE__*/React__default.cloneElement(child, {
                color: 'white'
              });
            }

            return child;
          }

          return /*#__PURE__*/React__default.createElement("span", null, child);
        }
      });

      if (this.props.loading) {
        content = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, content, /*#__PURE__*/React__default.createElement(Spinner, {
          light: active || hasColor,
          size: 's',
          darkBackground: hasColor
        }));
      }

      return /*#__PURE__*/React__default.createElement(href ? 'a' : 'button', props, content);
    }
  }]);

  return Button;
}(Component);
Button.propTypes = {
  color: PropTypes.oneOf(['blue', 'green', 'red', 'ghost', 'ghost-alternative']),
  size: PropTypes.oneOf(['s']),
  disabled: PropTypes.bool,
  active: PropTypes.bool,
  children: PropTypes.node.isRequired,
  href: PropTypes.string,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  loading: PropTypes.bool
};
passthrough()(Button);

var objectWithoutPropertiesLoose = createCommonjsModule(function (module) {
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _objectWithoutPropertiesLoose$1 = unwrapExports(objectWithoutPropertiesLoose);

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _extends$1 = unwrapExports(_extends_1);

var assertThisInitialized = createCommonjsModule(function (module) {
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _assertThisInitialized$1 = unwrapExports(assertThisInitialized);

var setPrototypeOf = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

unwrapExports(setPrototypeOf);

var inheritsLoose = createCommonjsModule(function (module) {
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf(subClass, superClass);
}

module.exports = _inheritsLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _inheritsLoose = unwrapExports(inheritsLoose);

var defineProperty = createCommonjsModule(function (module) {
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;
});

var _defineProperty$1 = unwrapExports(defineProperty);

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty$1 = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends$2 = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends$2({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends$2({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends$2({}, attributes, data.attributes);
  data.styles = _extends$2({}, styles, data.styles);
  data.arrowStyles = _extends$2({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$1(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$1(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends$2({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty$1({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty$1({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends$2({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty$1({}, side, reference[side]),
      end: defineProperty$1({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends$2({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends$2({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends$2({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends$2({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends$2({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global$1).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

var key = '__global_unique_id__';

var gud = function() {
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
};

var warning = function() {};

{
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

var warning_1 = warning;

var implementation = createCommonjsModule(function (module, exports) {

exports.__esModule = true;



var _react2 = _interopRequireDefault(React__default);



var _propTypes2 = _interopRequireDefault(PropTypes);



var _gud2 = _interopRequireDefault(gud);



var _warning2 = _interopRequireDefault(warning_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MAX_SIGNED_31_BIT_INT = 1073741823;

// Inlined Object.is polyfill.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + (0, _gud2.default)() + '__';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    function Provider() {
      var _temp, _this, _ret;

      _classCallCheck(this, Provider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
    }

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits = void 0;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0; // No change
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          {
            (0, _warning2.default)((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);
          }

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    Provider.prototype.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(React__default.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);

  var Consumer = function (_Component2) {
    _inherits(Consumer, _Component2);

    function Consumer() {
      var _temp2, _this2, _ret2;

      _classCallCheck(this, Consumer);

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
        value: _this2.getValue()
      }, _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({ value: _this2.getValue() });
        }
      }, _temp2), _possibleConstructorReturn(_this2, _ret2);
    }

    Consumer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;

      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    Consumer.prototype.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;

      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    Consumer.prototype.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    Consumer.prototype.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    Consumer.prototype.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(React__default.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);


  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

exports.default = createReactContext;
module.exports = exports['default'];
});

unwrapExports(implementation);

var lib = createCommonjsModule(function (module, exports) {

exports.__esModule = true;



var _react2 = _interopRequireDefault(React__default);



var _implementation2 = _interopRequireDefault(implementation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _react2.default.createContext || _implementation2.default;
module.exports = exports['default'];
});

var createContext = unwrapExports(lib);

var ManagerContext = createContext({
  setReferenceNode: undefined,
  referenceNode: undefined
});

var Manager =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Manager, _React$Component);

  function Manager() {
    var _this;

    _this = _React$Component.call(this) || this;

    _defineProperty$1(_assertThisInitialized$1(_this), "setReferenceNode", function (referenceNode) {
      if (!referenceNode || _this.state.context.referenceNode === referenceNode) {
        return;
      }

      _this.setState(function (_ref) {
        var context = _ref.context;
        return {
          context: _extends$1({}, context, {
            referenceNode: referenceNode
          })
        };
      });
    });

    _this.state = {
      context: {
        setReferenceNode: _this.setReferenceNode,
        referenceNode: undefined
      }
    };
    return _this;
  }

  var _proto = Manager.prototype;

  _proto.render = function render() {
    return createElement(ManagerContext.Provider, {
      value: this.state.context
    }, this.props.children);
  };

  return Manager;
}(Component);

/**
 * Takes an argument and if it's an array, returns the first item in the array,
 * otherwise returns the argument. Used for Preact compatibility.
 */
var unwrapArray = function unwrapArray(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
/**
 * Takes a maybe-undefined function and arbitrary args and invokes the function
 * only if it is defined.
 */

var safeInvoke = function safeInvoke(fn) {
  if (typeof fn === "function") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return fn.apply(void 0, args);
  }
};

var initialStyle = {
  position: 'absolute',
  top: 0,
  left: 0,
  opacity: 0,
  pointerEvents: 'none'
};
var initialArrowStyle = {};
var InnerPopper =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(InnerPopper, _React$Component);

  function InnerPopper() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _defineProperty$1(_assertThisInitialized$1(_this), "state", {
      data: undefined,
      placement: undefined
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "popperInstance", void 0);

    _defineProperty$1(_assertThisInitialized$1(_this), "popperNode", null);

    _defineProperty$1(_assertThisInitialized$1(_this), "arrowNode", null);

    _defineProperty$1(_assertThisInitialized$1(_this), "setPopperNode", function (popperNode) {
      if (!popperNode || _this.popperNode === popperNode) return;
      safeInvoke(_this.props.innerRef, popperNode);
      _this.popperNode = popperNode;

      _this.updatePopperInstance();
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "setArrowNode", function (arrowNode) {
      _this.arrowNode = arrowNode;
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "updateStateModifier", {
      enabled: true,
      order: 900,
      fn: function fn(data) {
        var placement = data.placement;

        _this.setState({
          data: data,
          placement: placement
        });

        return data;
      }
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "getOptions", function () {
      return {
        placement: _this.props.placement,
        eventsEnabled: _this.props.eventsEnabled,
        positionFixed: _this.props.positionFixed,
        modifiers: _extends$1({}, _this.props.modifiers, {
          arrow: _extends$1({}, _this.props.modifiers && _this.props.modifiers.arrow, {
            enabled: !!_this.arrowNode,
            element: _this.arrowNode
          }),
          applyStyle: {
            enabled: false
          },
          updateStateModifier: _this.updateStateModifier
        })
      };
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "getPopperStyle", function () {
      return !_this.popperNode || !_this.state.data ? initialStyle : _extends$1({
        position: _this.state.data.offsets.popper.position
      }, _this.state.data.styles);
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "getPopperPlacement", function () {
      return !_this.state.data ? undefined : _this.state.placement;
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "getArrowStyle", function () {
      return !_this.arrowNode || !_this.state.data ? initialArrowStyle : _this.state.data.arrowStyles;
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "getOutOfBoundariesState", function () {
      return _this.state.data ? _this.state.data.hide : undefined;
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "destroyPopperInstance", function () {
      if (!_this.popperInstance) return;

      _this.popperInstance.destroy();

      _this.popperInstance = null;
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "updatePopperInstance", function () {
      _this.destroyPopperInstance();

      var _assertThisInitialize = _assertThisInitialized$1(_this),
          popperNode = _assertThisInitialize.popperNode;

      var referenceElement = _this.props.referenceElement;
      if (!referenceElement || !popperNode) return;
      _this.popperInstance = new Popper(referenceElement, popperNode, _this.getOptions());
    });

    _defineProperty$1(_assertThisInitialized$1(_this), "scheduleUpdate", function () {
      if (_this.popperInstance) {
        _this.popperInstance.scheduleUpdate();
      }
    });

    return _this;
  }

  var _proto = InnerPopper.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    // If the Popper.js options have changed, update the instance (destroy + create)
    if (this.props.placement !== prevProps.placement || this.props.referenceElement !== prevProps.referenceElement || this.props.positionFixed !== prevProps.positionFixed) {
      this.updatePopperInstance();
    } else if (this.props.eventsEnabled !== prevProps.eventsEnabled && this.popperInstance) {
      this.props.eventsEnabled ? this.popperInstance.enableEventListeners() : this.popperInstance.disableEventListeners();
    } // A placement difference in state means popper determined a new placement
    // apart from the props value. By the time the popper element is rendered with
    // the new position Popper has already measured it, if the place change triggers
    // a size change it will result in a misaligned popper. So we schedule an update to be sure.


    if (prevState.placement !== this.state.placement) {
      this.scheduleUpdate();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    safeInvoke(this.props.innerRef, null);
    this.destroyPopperInstance();
  };

  _proto.render = function render() {
    return unwrapArray(this.props.children)({
      ref: this.setPopperNode,
      style: this.getPopperStyle(),
      placement: this.getPopperPlacement(),
      outOfBoundaries: this.getOutOfBoundariesState(),
      scheduleUpdate: this.scheduleUpdate,
      arrowProps: {
        ref: this.setArrowNode,
        style: this.getArrowStyle()
      }
    });
  };

  return InnerPopper;
}(Component);

_defineProperty$1(InnerPopper, "defaultProps", {
  placement: 'bottom',
  eventsEnabled: true,
  referenceElement: undefined,
  positionFixed: false
});
function Popper$1(_ref) {
  var referenceElement = _ref.referenceElement,
      props = _objectWithoutPropertiesLoose$1(_ref, ["referenceElement"]);

  return createElement(ManagerContext.Consumer, null, function (_ref2) {
    var referenceNode = _ref2.referenceNode;
    return createElement(InnerPopper, _extends$1({
      referenceElement: referenceElement !== undefined ? referenceElement : referenceNode
    }, props));
  });
}

var InnerReference =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(InnerReference, _React$Component);

  function InnerReference() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _defineProperty$1(_assertThisInitialized$1(_this), "refHandler", function (node) {
      safeInvoke(_this.props.innerRef, node);
      safeInvoke(_this.props.setReferenceNode, node);
    });

    return _this;
  }

  var _proto = InnerReference.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    safeInvoke(this.props.innerRef, null);
  };

  _proto.render = function render() {
    warning_1(Boolean(this.props.setReferenceNode), '`Reference` should not be used outside of a `Manager` component.');
    return unwrapArray(this.props.children)({
      ref: this.refHandler
    });
  };

  return InnerReference;
}(Component);

function Reference(props) {
  return createElement(ManagerContext.Consumer, null, function (_ref) {
    var setReferenceNode = _ref.setReferenceNode;
    return createElement(InnerReference, _extends$1({
      setReferenceNode: setReferenceNode
    }, props));
  });
}

var getDimensions = function getDimensions(_ref) {
  var top = _ref.top,
      right = _ref.right,
      bottom = _ref.bottom,
      left = _ref.left,
      horizontal = _ref.horizontal,
      vertical = _ref.vertical,
      all = _ref.all;
  return {
    top: top || vertical || all,
    right: right || horizontal || all,
    bottom: bottom || vertical || all,
    left: left || horizontal || all
  };
};

var isValidDimension = function isValidDimension(dimension) {
  var validDimensions = ['xs', 's', 'm', 'l', 'xl', 'xxl'];
  return dimension && validDimensions.includes(dimension);
};

var oneOfDimensionSizes = PropTypes.oneOf(['none', 'xs', 's', 'm', 'l', 'xl', 'xxl']);
var spacingPropTypes = {
  all: oneOfDimensionSizes,
  vertical: oneOfDimensionSizes,
  horizontal: oneOfDimensionSizes,
  top: oneOfDimensionSizes,
  bottom: oneOfDimensionSizes,
  left: oneOfDimensionSizes,
  right: oneOfDimensionSizes
};

var Spacing = /*#__PURE__*/function (_Component) {
  _inherits(Spacing, _Component);

  var _super = _createSuper(Spacing);

  function Spacing() {
    _classCallCheck(this, Spacing);

    return _super.apply(this, arguments);
  }

  _createClass(Spacing, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          display = _this$props.display,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;

      var _getDimensions = getDimensions(this.props),
          top = _getDimensions.top,
          right = _getDimensions.right,
          bottom = _getDimensions.bottom,
          left = _getDimensions.left;

      var className = classnames(cuiClassName('spacing'), _defineProperty({}, cuiClassName("spacing--top-".concat(top)), isValidDimension(top)), _defineProperty({}, cuiClassName("spacing--right-".concat(right)), isValidDimension(right)), _defineProperty({}, cuiClassName("spacing--bottom-".concat(bottom)), isValidDimension(bottom)), _defineProperty({}, cuiClassName("spacing--left-".concat(left)), isValidDimension(left)), _defineProperty({}, cuiClassName("spacing--".concat(display)), display), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      return /*#__PURE__*/React__default.createElement("div", props, children);
    }
  }]);

  return Spacing;
}(Component);
Spacing.propTypes = _objectSpread2(_objectSpread2({}, spacingPropTypes), {}, {
  display: PropTypes.oneOf(['inline', 'inline-block', 'flex', 'inline-flex']),
  children: PropTypes.node,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
});
passthrough()(Spacing);

function hasSpacing(children) {
  var spacing = [];
  React__default.Children.forEach(children, function (child) {
    if (child && child.type === Spacing) {
      spacing.push(child.type);
    }
  });
  return !!spacing.length;
}

function mutuallyExclusiveProp(propType) {
  for (var _len = arguments.length, exclusiveProps = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    exclusiveProps[_key - 1] = arguments[_key];
  }

  return function (props, propName, componentName) {
    var propValue = props[propName];

    if (typeof propValue !== 'undefined' && propValue !== null) {
      var exclusivePropMatches = exclusiveProps.filter(function (prop) {
        return typeof props[prop] !== 'undefined' && props[prop] !== null;
      });

      if (exclusivePropMatches.length) {
        var exclusivePropsList = exclusiveProps.join(', ');
        return new Error("".concat(propName, " and ").concat(exclusivePropsList, " cannot be used together"));
      }
    }

    return PropTypes.checkPropTypes(_defineProperty({}, propName, propType), props, propName, componentName);
  };
}

var getNodePath = function getNodePath(node) {
  var result = [node];
  var current = node;

  while (current && current.parentNode) {
    result.push(current.parentNode);
    current = current.parentNode;
  }

  return result;
};

var offsetSizes = {
  xs: 4,
  s: 8,
  m: 12,
  l: 24,
  xl: 32,
  xxl: 40
};

var Popover = /*#__PURE__*/function (_Component) {
  _inherits(Popover, _Component);

  var _super = _createSuper(Popover);

  function Popover(props) {
    var _this;

    _classCallCheck(this, Popover);

    _this = _super.call(this, props);
    _this.state = {
      visible: false,
      cursorXOverflowed: 0,
      cursorYOverflowed: 0
    };
    _this.cursorX = 0;
    _this.cursorY = 0;
    _this.getPopupElement = _this.getPopupElement.bind(_assertThisInitialized(_this));
    _this.onWindowClick = _this.onWindowClick.bind(_assertThisInitialized(_this));
    _this.onWindowBlur = _this.onWindowBlur.bind(_assertThisInitialized(_this));
    _this.onPopupVisibleChange = _this.onPopupVisibleChange.bind(_assertThisInitialized(_this));
    _this.close = _this.close.bind(_assertThisInitialized(_this));
    _this.popper;
    _this.mouseEnter = _this.mouseEnter.bind(_assertThisInitialized(_this));
    _this.mouseLeave = _this.mouseLeave.bind(_assertThisInitialized(_this));
    _this.mouseMove = _this.mouseMove.bind(_assertThisInitialized(_this));
    _this.checkInitialPlacementOverflow = _this.checkInitialPlacementOverflow.bind(_assertThisInitialized(_this));
    _this.resetInitialPositionOverflow = _this.resetInitialPositionOverflow.bind(_assertThisInitialized(_this));
    _this.scheduleUpdate = null;

    if (_this.props.referenceElement) {
      var referenceElement = _this.props.referenceElement;

      if (_this.isHoverable) {
        // add event handlers that non-referenceelements would get from getTriggerProps
        referenceElement.addEventListener('mousemove', _this.mouseMove);
        referenceElement.addEventListener('mouseenter', _this.mouseEnter);
        referenceElement.addEventListener('mouseleave', _this.mouseLeave);
        referenceElement.addEventListener('click', function (event) {
          var isPopper = getNodePath(event.target).includes(_this.popper);
          var isTrigger = Array.from(referenceElement.children).includes(event.target);

          if (!isPopper || isTrigger) {
            _this.queueVisibilityChange(false, 0.1);
          }
        });
      } else {
        referenceElement.addEventListener('mousemove', _this.mouseMove);
        referenceElement.addEventListener('click', function () {
          _this.onPopupVisibleChange(!_this.state.visible);
        });
      }
    }

    _this.visibilityChangeTimeout;
    return _this;
  }

  _createClass(Popover, [{
    key: "isHoverable",
    get: function get() {
      return this.props.trigger === 'hover';
    }
  }, {
    key: "getPortalTo",
    value: function getPortalTo() {
      var portalTo = this.props.portalTo;

      if (typeof portalTo === 'function') {
        return portalTo();
      }

      return portalTo;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.checkWindowEventListeners();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.referenceElement !== this.props.referenceElement) {
        this.removeReferenceElementEventListeners();
      }

      this.checkWindowEventListeners();

      if (typeof this.scheduleUpdate === 'function') {
        if (prevProps.content !== this.props.content) {
          this.scheduleUpdate();
        }
      }
    }
  }, {
    key: "removeReferenceElementEventListeners",
    value: function removeReferenceElementEventListeners() {
      var _this2 = this;

      this.props.referenceElement.removeEventListener('mousemove', this.mouseMove);
      this.props.referenceElement.removeEventListener('mouseenter', this.mouseEnter);
      this.props.referenceElement.removeEventListener('mouseleave', this.mouseLeave);
      this.props.referenceElement.removeEventListener('click', function () {
        if (!getNodePath(event.target).includes(_this2.popper)) {
          _this2.close();
        }
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.portalElement) {
        this.portalElement.remove();
      }

      if (this.props.referenceElement) {
        if (this.isHoverable) {
          this.removeReferenceElementEventListeners();
        } else {
          this.props.referenceElement.removeEventListener('click', this.onPopupVisibleChange(!this.state.visible));
        }
      }

      window.removeEventListener('resize', this.close);
      window.removeEventListener('click', this.onWindowClick);
    }
  }, {
    key: "baseClassName",
    get: function get() {
      return 'popover';
    }
  }, {
    key: "defaultSpacing",
    get: function get() {
      return {
        all: 'm'
      };
    }
  }, {
    key: "queueVisibilityChange",
    value: function queueVisibilityChange(visible) {
      var _this3 = this;

      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      clearTimeout(this.visibilityChangeTimeout);
      this.visibilityChangeTimeout = setTimeout(function () {
        _this3.onPopupVisibleChange(visible);
      }, delay * 1000);
    }
  }, {
    key: "mouseMove",
    value: function mouseMove(event) {
      var visible = this.state.visible;

      if (event && event.nativeEvent && !visible) {
        this.cursorX = event.nativeEvent.offsetX >= 0 ? event.nativeEvent.offsetX : 0;
        this.cursorY = event.nativeEvent.offsetY >= 0 ? event.nativeEvent.offsetY : 0;
      }
    }
  }, {
    key: "mouseEnter",
    value: function mouseEnter() {
      this.queueVisibilityChange(true, this.delays.mouseEnterDelay);
    }
  }, {
    key: "mouseLeave",
    value: function mouseLeave() {
      this.queueVisibilityChange(false, this.delays.mouseLeaveDelay);
    }
  }, {
    key: "getTriggerProps",
    value: function getTriggerProps(_ref, toggleOnTriggerClick) {
      var _this4 = this;

      var _onClick = _ref.onClick,
          _onMouseEnter = _ref.onMouseEnter,
          _onMouseLeave = _ref.onMouseLeave,
          onMouseMove = _ref.onMouseMove;
      var placement = this.props.placement;

      var mouseMoveCallback = function mouseMoveCallback(e) {
        if (placement === 'initial') {
          onMouseMove && onMouseMove(e);

          _this4.mouseMove(e);
        }
      };

      if (this.isHoverable) {
        return {
          onMouseMove: function onMouseMove(e) {
            mouseMoveCallback(e);
          },
          onMouseEnter: function onMouseEnter(e) {
            _onMouseEnter && _onMouseEnter(e);

            _this4.mouseEnter();
          },
          onMouseLeave: function onMouseLeave(e) {
            _onMouseLeave && _onMouseLeave(e);

            _this4.mouseLeave();
          },
          // in case trigger is clicked when popover is visible, close popover on click
          onClick: function onClick(e) {
            _onClick && _onClick(e);
            _this4.state.visible && _this4.onPopupVisibleChange(!_this4.state.visible);
          }
        };
      }

      return toggleOnTriggerClick ? {
        onMouseMove: function onMouseMove(e) {
          mouseMoveCallback(e);
        },
        onClick: function onClick(e) {
          _onClick && _onClick(e);

          _this4.onPopupVisibleChange(!_this4.state.visible);
        }
      } : {
        onMouseMove: function onMouseMove(e) {
          mouseMoveCallback(e);
        },
        onClick: function onClick(e) {
          _onClick && _onClick(e);
        }
      };
    }
  }, {
    key: "popperProps",
    get: function get() {
      if (this.isHoverable) {
        return {
          onMouseMove: this.mouseMove,
          onMouseEnter: this.mouseEnter,
          onMouseLeave: this.mouseLeave
        };
      }

      return null;
    }
  }, {
    key: "checkWindowEventListeners",
    value: function checkWindowEventListeners() {
      var _this5 = this;

      if (this.state.visible) {
        // Those event listeners should not be triggered asap.
        setTimeout(function () {
          window.addEventListener('resize', _this5.close);
          window.addEventListener('click', _this5.onWindowClick);
          window.addEventListener('blur', _this5.onWindowBlur);
        });
      } else {
        setTimeout(function () {
          window.removeEventListener('resize', _this5.close);
          window.removeEventListener('click', _this5.onWindowClick);
          window.removeEventListener('blur', _this5.onWindowBlur);
        });
      }
    }
  }, {
    key: "onPopupVisibleChange",
    value: function onPopupVisibleChange(visible) {
      var _this6 = this;

      if (this.isHoverable && !visible) {
        var hoveredElements = document.querySelectorAll(':hover');

        if (Array.from(hoveredElements).includes(this.popper)) {
          return;
        }
      }

      if (this.props.onVisibilityChange) {
        this.props.onVisibilityChange(visible);
      }

      if (this.props.onPopupVisibleChange) {
        this.resetInitialPositionOverflow();
        return this.props.onPopupVisibleChange(visible);
      }

      if (!(visible in this.props)) {
        this.setState({
          visible: visible
        }, function () {
          if (!visible) {
            _this6.resetInitialPositionOverflow();
          }
        });
      }
    }
  }, {
    key: "resetInitialPositionOverflow",
    value: function resetInitialPositionOverflow() {
      var _this$state = this.state,
          cursorXOverflowed = _this$state.cursorXOverflowed,
          cursorYOverflowed = _this$state.cursorYOverflowed;

      if (this.props.placement === 'initial' && (cursorXOverflowed !== 0 || cursorYOverflowed !== 0)) {
        this.setState({
          cursorXOverflowed: 0,
          cursorYOverflowed: 0
        });
      }
    }
  }, {
    key: "close",
    value: function close() {
      this.onPopupVisibleChange(false);
    }
  }, {
    key: "onWindowClick",
    value: function onWindowClick(event) {
      if (!getNodePath(event.target).includes(this.popper)) {
        this.close();
      }
    }
  }, {
    key: "onWindowBlur",
    value: function onWindowBlur() {
      var _this7 = this;

      // this will fire if user clicks into an iframe on the page
      // but check blur not caused by visibility change i.e. browser tab changing
      // query Document.hidden on next tick to get correct state
      setTimeout(function () {
        if (!document.hidden) {
          _this7.close();
        }
      }, 0);
    }
  }, {
    key: "getPopupElementContent",
    value: function getPopupElementContent(popupContent, scheduleUpdate) {
      var spacing = this.props.spacing;
      var content = typeof popupContent === 'function' ? popupContent({
        scheduleUpdate: scheduleUpdate
      }) : popupContent;
      var needsSpacing = spacing || !hasSpacing(content);
      var spacingProps = spacing ? typeof spacing === 'string' ? {
        all: spacing
      } : spacing : this.defaultSpacing;
      return needsSpacing ? /*#__PURE__*/React__default.createElement(Spacing, spacingProps, content) : content;
    }
  }, {
    key: "shouldRenderArrow",
    value: function shouldRenderArrow() {
      return this.props.arrow;
    }
  }, {
    key: "positionForInitialPlacement",
    get: function get() {
      var cursorX = this.cursorX,
          cursorY = this.cursorY;
      var _this$state2 = this.state,
          cursorXOverflowed = _this$state2.cursorXOverflowed,
          cursorYOverflowed = _this$state2.cursorYOverflowed;
      var fixedCursorX = cursorX + 16;
      var fixedCursorY = cursorY + 16;

      if (cursorXOverflowed !== 0) {
        fixedCursorX -= cursorXOverflowed;
      }

      if (cursorYOverflowed !== 0) {
        fixedCursorY -= cursorYOverflowed;
      }

      return {
        transform: "translate3d(".concat(fixedCursorX, "px, ").concat(fixedCursorY, "px, 0px)")
      };
    }
  }, {
    key: "checkInitialPlacementOverflow",
    value: function checkInitialPlacementOverflow(_ref2, placement) {
      var right = _ref2.right,
          bottom = _ref2.bottom;

      if (placement === 'initial') {
        var _this$state3 = this.state,
            cursorXOverflowed = _this$state3.cursorXOverflowed,
            cursorYOverflowed = _this$state3.cursorYOverflowed;
        var _window = window,
            innerWidth = _window.innerWidth,
            innerHeight = _window.innerHeight;
        var newCursorXOverflowed = 0;
        var newCursorYOverflowed = 0;

        if (right + 8 > innerWidth && cursorXOverflowed === 0) {
          newCursorXOverflowed = right + 8 - innerWidth;
        }

        if (bottom + 8 > innerHeight && cursorYOverflowed === 0) {
          newCursorYOverflowed = bottom + 8 - innerHeight;
        }

        if (newCursorXOverflowed !== 0 || newCursorYOverflowed !== 0) {
          this.setState({
            cursorXOverflowed: newCursorXOverflowed,
            cursorYOverflowed: newCursorYOverflowed
          });
        }
      }
    }
  }, {
    key: "getPopupElement",
    value: function getPopupElement(_ref3) {
      var _this8 = this;

      var _ref4 = _ref3.ref,
          style = _ref3.style,
          placement = _ref3.placement,
          scheduleUpdate = _ref3.scheduleUpdate;
      this.scheduleUpdate = scheduleUpdate;
      var _this$props = this.props,
          givenClassName = _this$props.className,
          content = _this$props.content,
          givenStyle = _this$props.style;
      var className = classnames(cuiClassName(this.baseClassName), _defineProperty({}, cuiClassName("".concat(this.baseClassName, "--placement-").concat(placement)), placement), givenClassName);
      delete style.left;
      delete style.top;
      return /*#__PURE__*/React__default.createElement("div", _extends({
        ref: function ref(props) {
          _ref4(props);

          if (props) {
            _this8.checkInitialPlacementOverflow(props.getBoundingClientRect(), placement);
          }
        },
        style: _objectSpread2(_objectSpread2(_objectSpread2({}, givenStyle), style), placement === 'initial' ? this.positionForInitialPlacement : {}),
        className: className
      }, this.passthrough(), this.popperProps), this.shouldRenderArrow() && /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName("".concat(this.baseClassName, "__arrow"))
      }, /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName("".concat(this.baseClassName, "__arrow-inner"))
      })), /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName("".concat(this.baseClassName, "__inner"))
      }, this.getPopupElementContent(content, scheduleUpdate)));
    }
  }, {
    key: "distanceFromPopper",
    get: function get() {
      return 4;
    }
  }, {
    key: "delays",
    get: function get() {
      var _this$props2 = this.props,
          mouseEnterDelay = _this$props2.mouseEnterDelay,
          mouseLeaveDelay = _this$props2.mouseLeaveDelay; // mouseLeaveDelay should only be used to turn off default delay.

      var isValidMouseLeaveDelay = function isValidMouseLeaveDelay(delay) {
        return delay === 0;
      };

      var isValidMouseEnterDelay = function isValidMouseEnterDelay(delay) {
        return typeof delay === 'number';
      };

      var defaultMouseEnterDelay = this.isHoverable ? 0.6 : 0;
      var defaultMouseLeaveDelay = this.isHoverable ? 0.4 : 0;
      return {
        mouseEnterDelay: isValidMouseEnterDelay(mouseEnterDelay) ? mouseEnterDelay : defaultMouseEnterDelay,
        mouseLeaveDelay: isValidMouseLeaveDelay(mouseLeaveDelay) ? mouseLeaveDelay : defaultMouseLeaveDelay
      };
    }
  }, {
    key: "getPopperOffset",
    value: function getPopperOffset() {
      var _this$props3 = this.props,
          placement = _this$props3.placement,
          offset = _this$props3.offset;

      if (offset && typeof offset === 'number') {
        return "".concat(offset, "px, ").concat(this.distanceFromPopper, "px");
      }

      var offsetNegative = offset && offset.startsWith('-');
      var offsetKey = offsetNegative ? offset.substring(1) : offset;

      if (offsetKey in offsetSizes) {
        var offsetPx = "".concat(offsetSizes[offsetKey]);
        var negative = offsetNegative;

        if (placement && placement.endsWith('start')) {
          negative = !negative;
        }

        return "".concat(offsetPx * (negative ? -1 : 1), "px, ").concat(this.distanceFromPopper, "px");
      }

      return "0, ".concat(this.distanceFromPopper, "px");
    }
  }, {
    key: "renderPopper",
    value: function renderPopper() {
      var _this9 = this;

      var _this$props4 = this.props,
          placement = _this$props4.placement,
          popperProps = _this$props4.popperProps,
          forwardRef = _this$props4.forwardRef,
          referenceElement = _this$props4.referenceElement;
      /**
       * Fix to prefer original placement if flipped placement doesn't have enough room either.
       * Related to Popper.js issue: https://github.com/FezVrasta/popper.js/issues/550
       */

      var behavior = ['bottom', 'top', 'bottom'];
      return /*#__PURE__*/React__default.createElement(Popper$1, _extends({}, popperProps, referenceElement ? {
        referenceElement: referenceElement
      } : {}, {
        innerRef: function innerRef(node) {
          _this9.popper = node;
          var popperInnerRef = popperProps && popperProps.innerRef;
          triggerReferences(node, popperInnerRef, forwardRef);
        },
        placement: placement,
        modifiers: _objectSpread2(_objectSpread2({
          preventOverflow: {
            enabled: false
          },
          hide: {
            enabled: false
          },
          flip: {
            behavior: behavior
          }
        }, popperProps && popperProps.modifiers), {}, {
          arrow: {
            enabled: false
          },
          offset: {
            offset: this.getPopperOffset()
          }
        })
      }), this.getPopupElement);
    }
  }, {
    key: "renderPopperIfVisible",
    value: function renderPopperIfVisible() {
      var visible = this.state.visible;

      if (!visible) {
        return null;
      }

      var portalTo = this.getPortalTo();

      if (portalTo) {
        if (!this.portalElement) {
          this.portalElement = document.createElement('div');
        }

        if (this.portalElement.parentNode !== portalTo) {
          portalTo.append(this.portalElement);
        }

        return /*#__PURE__*/ReactDOM.createPortal(this.renderPopper(), this.portalElement);
      } else if (this.portalElement) {
        this.portalElement.remove();
        this.portalElement = null;
      }

      return this.renderPopper();
    }
  }, {
    key: "popperElement",
    get: function get() {
      var _this$props5 = this.props,
          children = _this$props5.children,
          innerRefProp = _this$props5.innerRefProp,
          toggleOnTriggerClick = _this$props5.toggleOnTriggerClick;
      var childrenProps = children.props;

      var referenceProps = _objectSpread2({}, {
        innerRef: function innerRef(trigger) {
          return triggerReferences(trigger, childrenProps && childrenProps.forwardRef);
        }
      });

      var triggerProps = this.getTriggerProps(childrenProps, toggleOnTriggerClick);
      return /*#__PURE__*/React__default.createElement(Manager, null, /*#__PURE__*/React__default.createElement(Reference, referenceProps, function (_ref5) {
        var ref = _ref5.ref;

        /**
         * It is possible to say what prop will be called as ref.
         * If the child is a HTML node we can add the ref directly.
         * Otherwise forwardRef prop is sent as this is expected to be available for all CUI components.
         */
        var triggerRef;

        if (innerRefProp) {
          triggerRef = innerRefProp;
        } else if (typeof children.type === 'string') {
          triggerRef = 'ref';
        } else {
          triggerRef = 'forwardRef';
        }

        triggerProps[triggerRef] = ref;
        return /*#__PURE__*/React__default.cloneElement(children, triggerProps);
      }), this.renderPopperIfVisible());
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props,
          children = _this$props6.children,
          referenceElement = _this$props6.referenceElement,
          placement = _this$props6.placement;

      if (!referenceElement && !children) {
        return null;
      }

      if (referenceElement) {
        return /*#__PURE__*/React__default.createElement(Manager, null, this.renderPopperIfVisible());
      }

      if (placement === 'initial') {
        return /*#__PURE__*/React__default.createElement("div", {
          style: {
            position: 'relative'
          }
        }, this.popperElement);
      }

      return this.popperElement;
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if ('visible' in props && state.visible !== props.visible) {
        return {
          visible: props.visible
        };
      }

      return null;
    }
  }]);

  return Popover;
}(Component);
var referenceElementPropType = PropTypes.shape({
  getBoundingClientRect: PropTypes.func.isRequired,
  clientWidth: PropTypes.number.isRequired,
  clientHeight: PropTypes.number.isRequired
});
Popover.propTypes = {
  children: mutuallyExclusiveProp(PropTypes.node, 'referenceElement'),
  referenceElement: mutuallyExclusiveProp(PropTypes.oneOfType([].concat(_toConsumableArray(typeof Element === 'undefined' ? [] : [PropTypes.instanceOf(Element)]), [referenceElementPropType])), 'children'),
  portalTo: PropTypes.any,
  content: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  placement: PropTypes.string,
  visible: PropTypes.bool,
  onPopupVisibleChange: PropTypes.func,
  onVisibilityChange: PropTypes.func,
  innerRefProp: PropTypes.string,
  popperProps: PropTypes.object,
  className: PropTypes.string,
  style: PropTypes.object,
  toggleOnTriggerClick: PropTypes.bool,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  spacing: PropTypes.oneOfType([oneOfDimensionSizes, PropTypes.shape(spacingPropTypes)]),
  offset: PropTypes.oneOfType([PropTypes.oneOf([].concat(_toConsumableArray(Object.keys(offsetSizes).map(function (offset) {
    return "".concat(offset);
  })), _toConsumableArray(Object.keys(offsetSizes).map(function (offset) {
    return "-".concat(offset);
  })))), PropTypes.number]),
  arrow: PropTypes.bool,
  trigger: PropTypes.oneOf(['hover', 'click']),
  mouseEnterDelay: PropTypes.number,
  mouseLeaveDelay: PropTypes.number
};
Popover.defaultProps = {
  placement: 'bottom',
  arrow: true,
  toggleOnTriggerClick: true
};
passthrough()(Popover);

var Dropmenu = /*#__PURE__*/function (_Component) {
  _inherits(Dropmenu, _Component);

  var _super = _createSuper(Dropmenu);

  function Dropmenu(props) {
    var _this;

    _classCallCheck(this, Dropmenu);

    _this = _super.call(this, props);
    _this.state = {
      visible: props.popoverProps ? props.popoverProps.visible : false
    };
    _this.closePopover = _this.closePopover.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Dropmenu, [{
    key: "closePopover",
    value: function closePopover() {
      this.setState({
        visible: false
      });
    }
  }, {
    key: "getContent",
    value: function getContent(content, scheduleUpdate) {
      if (typeof content === 'function') {
        return content({
          closePopover: this.closePopover,
          scheduleUpdate: scheduleUpdate
        });
      }

      return content;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          _content = _this$props.content,
          header = _this$props.header,
          footer = _this$props.footer,
          closeOnClick = _this$props.closeOnClick,
          forwardRef = _this$props.forwardRef,
          children = _this$props.children,
          givenPopoverProps = _this$props.popoverProps,
          givenClassName = _this$props.className,
          headerRef = _this$props.headerRef,
          contentRef = _this$props.contentRef,
          onClick = _this$props.onClick,
          footerRef = _this$props.footerRef;
      var visible = this.state.visible;
      var className = classnames(cuiClassName('dropmenu'), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      if (closeOnClick) {
        props.onClick = function (event) {
          if (typeof onClick === 'function') {
            onClick(event);
          }

          _this2.closePopover();
        };
      }

      var popoverProps = _objectSpread2(_objectSpread2({
        placement: 'bottom'
      }, givenPopoverProps), {}, {
        onPopupVisibleChange: function onPopupVisibleChange(visible) {
          if (givenPopoverProps && givenPopoverProps.onPopupVisibleChange) {
            return givenPopoverProps.onPopupVisibleChange(visible);
          }

          if (!('popoverProps' in _this2.props && 'visible' in _this2.props.popoverProps)) {
            return _this2.setState({
              visible: visible
            });
          }
        },
        visible: visible,
        content: function content(_ref) {
          var scheduleUpdate = _ref.scheduleUpdate;
          return /*#__PURE__*/React__default.createElement(Spacing, null, /*#__PURE__*/React__default.createElement("div", props, header && /*#__PURE__*/React__default.createElement("div", {
            className: cuiClassName('dropmenu__header'),
            ref: headerRef
          }, _this2.getContent(header, scheduleUpdate)), /*#__PURE__*/React__default.createElement("div", {
            className: cuiClassName('dropmenu__content'),
            ref: contentRef
          }, _this2.getContent(_content, scheduleUpdate)), footer && /*#__PURE__*/React__default.createElement("div", {
            className: cuiClassName('dropmenu__footer'),
            ref: footerRef
          }, _this2.getContent(footer, scheduleUpdate))));
        }
      });

      return /*#__PURE__*/React__default.createElement(Popover, popoverProps, children);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if ('popoverProps' in props && 'visible' in props.popoverProps && state.visible !== props.popoverProps.visible) {
        return {
          visible: props.popoverProps.visible
        };
      }

      return null;
    }
  }]);

  return Dropmenu;
}(Component);
Dropmenu.propTypes = {
  children: PropTypes.node.isRequired,
  content: PropTypes.oneOfType([PropTypes.func, PropTypes.node]).isRequired,
  header: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
  footer: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
  popoverProps: PropTypes.object,
  className: PropTypes.string,
  closeOnClick: PropTypes.bool,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  headerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  contentRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  footerRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  onClick: PropTypes.func
};
passthrough()(Dropmenu);

var Option = /*#__PURE__*/function (_Component) {
  _inherits(Option, _Component);

  var _super = _createSuper(Option);

  function Option() {
    _classCallCheck(this, Option);

    return _super.apply(this, arguments);
  }

  _createClass(Option, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          selected = _this$props.selected,
          disabled = _this$props.disabled,
          highlighted = _this$props.highlighted,
          manualHighlight = _this$props.manualHighlight,
          noWrap = _this$props.noWrap,
          href = _this$props.href,
          children = _this$props.children,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('option'), _defineProperty({}, cuiClassName('option--selected'), selected), _defineProperty({}, cuiClassName('option--disabled'), disabled), _defineProperty({}, cuiClassName('option--highlighted'), highlighted), _defineProperty({}, cuiClassName('option--manual-highlight'), manualHighlight), _defineProperty({}, cuiClassName('option--nowrap'), noWrap), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className,
        href: href
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      if (disabled) {
        delete props.onClick;
        delete props.href;
      }

      var content = React__default.Children.map(children, function (child) {
        if (child) {
          if (child.type) {
            return child;
          }

          return /*#__PURE__*/React__default.createElement("span", null, child);
        }
      });
      return /*#__PURE__*/React__default.createElement(href ? 'a' : 'div', props, /*#__PURE__*/React__default.createElement(React__default.Fragment, null, content, selected && /*#__PURE__*/React__default.createElement(Icon, {
        className: cuiClassName('option-check'),
        icon: "check",
        size: "s"
      })));
    }
  }]);

  return Option;
}(Component);
Option.propTypes = {
  children: PropTypes.node.isRequired,
  selected: PropTypes.bool,
  highlighted: PropTypes.bool,
  manualHighlight: PropTypes.bool,
  disabled: PropTypes.bool,
  noWrap: PropTypes.bool,
  href: PropTypes.string,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Option);

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return _root.Date.now();
};

var now_1 = now;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

var _trimmedEndIndex = trimmedEndIndex;

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

var _baseTrim = baseTrim;

/** Built-in value references. */
var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag$1 && symToStringTag$1 in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
}

var isSymbol_1 = isSymbol;

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject_1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce$1(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber_1(wait) || 0;
  if (isObject_1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now_1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now_1());
  }

  function debounced() {
    var time = now_1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

var debounce_1 = debounce$1;

var _excluded = ["className", "forwardRef", "percentage"];

var Track = /*#__PURE__*/function (_Component) {
  _inherits(Track, _Component);

  var _super = _createSuper(Track);

  function Track(props) {
    var _this;

    _classCallCheck(this, Track);

    _this = _super.call(this, props);
    _this.track = /*#__PURE__*/React__default.createRef();
    _this.dot = /*#__PURE__*/React__default.createRef();
    _this.state = {
      mouseDown: false
    };
    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized(_this));
    _this.onMouseMove = _this.onMouseMove.bind(_assertThisInitialized(_this));
    _this.onMouseUp = _this.onMouseUp.bind(_assertThisInitialized(_this));
    _this.onChange = debounce_1(_this.onChange);
    return _this;
  }

  _createClass(Track, [{
    key: "onMouseDown",
    value: function onMouseDown(event) {
      var _this2 = this;

      if (event.nativeEvent.which !== 1) {
        return;
      }

      this.setState({
        mouseDown: true
      }, function () {
        document.addEventListener('mousemove', _this2.onMouseMove);
        document.addEventListener('mouseup', _this2.onMouseUp);
      });
      event.persist();
      this.onChange(event);
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      this.onChange(event);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(event) {
      var _this3 = this;

      this.setState({
        mouseDown: false
      }, function () {
        document.removeEventListener('mousemove', _this3.onMouseMove);
        document.removeEventListener('mouseup', _this3.onMouseUp);
      });
      this.onChange(event);
    }
  }, {
    key: "onChange",
    value: function onChange(event) {
      var _this$props = this.props,
          onChange = _this$props.onChange,
          percentage = _this$props.percentage;

      if (onChange && this.track.current) {
        var _this$track$current$g = this.track.current.getBoundingClientRect(),
            left = _this$track$current$g.left,
            max = _this$track$current$g.width;

        var position = event.clientX - left;
        var newPercentage = Math.max(Math.min(position / max * 100, 100), 0);

        if (percentage !== newPercentage) {
          onChange(newPercentage);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          givenClassName = _this$props2.className,
          forwardRef = _this$props2.forwardRef,
          percentage = _this$props2.percentage,
          rest = _objectWithoutProperties(_this$props2, _excluded);

      var className = classnames(cuiClassName('track'), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        ref: function ref(node) {
          return triggerReferences(node, forwardRef);
        }
      }, rest), {}, {
        className: className,
        onMouseDown: this.onMouseDown
      });

      return /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('track__track'),
        ref: this.track
      }, /*#__PURE__*/React__default.createElement("span", {
        ref: this.dot,
        className: cuiClassName('track__dot'),
        style: {
          left: "".concat(percentage, "%")
        }
      }), /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('track__progress'),
        style: {
          width: "".concat(percentage, "%")
        }
      })));
    }
  }]);

  return Track;
}(Component);
Track.propTypes = {
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  className: PropTypes.string,
  percentage: PropTypes.number.isRequired,
  onChange: PropTypes.func
};

var getDuration = function getDuration(time) {
  var seconds = "".concat(Math.ceil(time % 60)).padStart(2, '0');
  var minutes = "".concat(Math.floor(time / 60)).padStart(2, '0');
  return "".concat(minutes, ":").concat(seconds);
};

var AudioPlayer = /*#__PURE__*/function (_Component) {
  _inherits(AudioPlayer, _Component);

  var _super = _createSuper(AudioPlayer);

  function AudioPlayer(props) {
    var _this;

    _classCallCheck(this, AudioPlayer);

    _this = _super.call(this, props);
    _this.state = {
      mode: props.mode || 'placeholder',
      duration: props.duration || 0,
      currentTime: 0,
      playing: false,
      muted: false
    };
    _this.player = /*#__PURE__*/React__default.createRef();
    _this.onPlaceholderClick = _this.onPlaceholderClick.bind(_assertThisInitialized(_this));
    _this.onLoadedMetadata = _this.onLoadedMetadata.bind(_assertThisInitialized(_this));
    _this.onTimeUpdate = _this.onTimeUpdate.bind(_assertThisInitialized(_this));
    _this.onPlay = _this.onPlay.bind(_assertThisInitialized(_this));
    _this.onPause = _this.onPause.bind(_assertThisInitialized(_this));
    _this.onVolumeChange = _this.onVolumeChange.bind(_assertThisInitialized(_this));
    _this.listeners = [{
      name: 'loadedmetadata',
      handler: _this.onLoadedMetadata
    }, {
      name: 'timeupdate',
      handler: _this.onTimeUpdate
    }, {
      name: 'play',
      handler: _this.onPlay
    }, {
      name: 'pause',
      handler: _this.onPause
    }, {
      name: 'volumechange',
      handler: _this.onVolumeChange
    }];
    return _this;
  }

  _createClass(AudioPlayer, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.mode !== prevProps.mode) {
        this.setState({
          mode: this.props.mode
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var player = this.player.current;

      if (player) {
        this.listeners.forEach(function (_ref) {
          var name = _ref.name,
              handler = _ref.handler;
          player.addEventListener(name, handler);
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var player = this.player.current;

      if (player) {
        this.listeners.forEach(function (_ref2) {
          var name = _ref2.name,
              handler = _ref2.handler;
          player.removeEventListener(name, handler);
        });
      }
    }
  }, {
    key: "onLoadedMetadata",
    value: function onLoadedMetadata() {
      this.setState({
        duration: this.player.current.duration
      });
    }
  }, {
    key: "onTimeUpdate",
    value: function onTimeUpdate() {
      this.setState({
        currentTime: this.player.current.currentTime
      });
    }
  }, {
    key: "onPlay",
    value: function onPlay() {
      AudioPlayer.pauseAll(this.player.current);
      this.setState({
        playing: true
      });
    }
  }, {
    key: "onPause",
    value: function onPause() {
      this.setState({
        playing: false
      });
    }
  }, {
    key: "onVolumeChange",
    value: function onVolumeChange() {
      this.setState({
        muted: this.player.current.muted
      });
    }
  }, {
    key: "onPlaceholderClick",
    value: function onPlaceholderClick(event) {
      if (event.target.closest(".".concat(cuiClassName('audio-player__actions')))) {
        return;
      }

      var onModeChange = this.props.onModeChange;
      var mode = 'player';

      if (typeof onModeChange === 'function') {
        return onModeChange(mode);
      }

      var player = this.player.current;
      this.setState({
        mode: mode
      }, function () {
        return player && player.play();
      });
    }
  }, {
    key: "getTitle",
    value: function getTitle() {
      var _this$props = this.props,
          title = _this$props.title,
          source = _this$props.source;
      return title || (source === null || source === void 0 ? void 0 : source.split('/').pop());
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props2 = this.props,
          actions = _this$props2.actions,
          source = _this$props2.source,
          isDownloadable = _this$props2.isDownloadable,
          downloadActionText = _this$props2.downloadActionText;
      var hasActions = actions || isDownloadable;
      var isPlaceholder = this.state.mode === 'placeholder';

      if (!hasActions) {
        return null;
      }

      return /*#__PURE__*/React__default.createElement(Dropmenu, {
        content: /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isDownloadable && /*#__PURE__*/React__default.createElement(Option, {
          href: source,
          download: true
        }, downloadActionText), actions),
        popoverProps: {
          placement: 'bottom-end',
          offset: 'xs'
        }
      }, /*#__PURE__*/React__default.createElement(Button, {
        className: cuiClassName('audio-player__actions'),
        size: "s",
        color: isPlaceholder ? 'ghost' : 'ghost-alternative'
      }, /*#__PURE__*/React__default.createElement(Icon, {
        icon: "ellipsis"
      })));
    }
  }, {
    key: "renderPlayer",
    value: function renderPlayer() {
      var _this2 = this;

      var _this$state = this.state,
          duration = _this$state.duration,
          currentTime = _this$state.currentTime,
          playing = _this$state.playing,
          muted = _this$state.muted;
      return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button, {
        size: "s",
        color: "ghost-alternative",
        onClick: function onClick() {
          var player = _this2.player.current;

          if (player) {
            return playing ? player.pause() : player.play();
          }
        }
      }, /*#__PURE__*/React__default.createElement(Icon, {
        icon: playing ? 'pause' : 'play'
      })), /*#__PURE__*/React__default.createElement(Track, {
        className: cuiClassName('audio-player__track'),
        percentage: duration === 0 ? 0 : currentTime / duration * 100,
        onChange: function onChange(percentage) {
          var player = _this2.player.current;

          if (player) {
            player.currentTime = percentage / 100 * duration;
          }
        }
      }), /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('audio-player__duration')
      }, "\u2212", getDuration(duration - currentTime)), /*#__PURE__*/React__default.createElement(Button, {
        size: "s",
        color: "ghost-alternative",
        onClick: function onClick() {
          var player = _this2.player.current;

          if (player) {
            player.muted = !muted;
          }
        }
      }, /*#__PURE__*/React__default.createElement(Icon, {
        icon: muted ? 'volume-off' : 'volume-on'
      })), this.renderActions());
    }
  }, {
    key: "renderPlaceholder",
    value: function renderPlaceholder() {
      var duration = this.state.duration;
      return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button, {
        className: cuiClassName('audio-player__placeholder-play'),
        size: "s",
        color: "ghost-alternative"
      }, /*#__PURE__*/React__default.createElement(Icon, {
        icon: "play"
      })), /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('audio-player__title')
      }, this.getTitle()), /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('audio-player__duration')
      }, getDuration(duration)), this.renderActions());
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props3 = this.props,
          forwardRef = _this$props3.forwardRef,
          source = _this$props3.source,
          givenClassName = _this$props3.className;
      var isPlaceholder = this.state.mode === 'placeholder';
      var className = classnames(cuiClassName('audio-player'), _defineProperty({}, cuiClassName("audio-player--play-mode"), !isPlaceholder), givenClassName);

      var props = _objectSpread2({
        className: className
      }, this.passthrough());

      var playerProps = {
        ref: function ref(node) {
          return triggerReferences(node, _this3.player, forwardRef);
        }
      };

      if (isPlaceholder) {
        props.onClick = this.onPlaceholderClick;
      }

      return /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement("audio", playerProps, /*#__PURE__*/React__default.createElement("source", {
        src: source
      })), isPlaceholder ? this.renderPlaceholder() : this.renderPlayer());
    }
  }]);

  return AudioPlayer;
}(Component);

AudioPlayer.pauseAll = function (keepPlayingPlayerElement) {
  _toConsumableArray(document.querySelectorAll(".".concat(cuiClassName('audio-player'), " audio"))).forEach(function (player) {
    if (keepPlayingPlayerElement === player || player.paused) {
      return;
    }

    player.pause();
  });
};

AudioPlayer.propTypes = {
  source: PropTypes.string,
  title: PropTypes.string,
  mode: PropTypes.oneOf(['placeholder', 'player']),
  onModeChange: PropTypes.func,
  duration: PropTypes.number,
  actions: PropTypes.node,
  isDownloadable: PropTypes.bool,
  downloadActionText: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  className: PropTypes.string
};
AudioPlayer.defaultProps = {
  isDownloadable: true,
  downloadActionText: 'Download'
};
passthrough()(AudioPlayer);

var Avatar = /*#__PURE__*/function (_Component) {
  _inherits(Avatar, _Component);

  var _super = _createSuper(Avatar);

  function Avatar(props) {
    var _this;

    _classCallCheck(this, Avatar);

    _this = _super.call(this, props);
    _this.state = {
      imageLoaded: false
    };
    return _this;
  }

  _createClass(Avatar, [{
    key: "makeInitials",
    value: function makeInitials(name) {
      if (typeof name === 'string') {
        name = name.split(' ');

        if (name.length > 1) {
          name = name[0][0] + name[name.length - 1][0];
        } else {
          name = name[0][0];
        }
      }

      return name;
    }
  }, {
    key: "getIconProps",
    value: function getIconProps(type, size) {
      var iconProps;

      var iconSizeProps = _objectSpread2({}, size !== 'xl' && {
        size: 's'
      }); // Image type of organization always has icon when no image provided


      if (type === 'organization') {
        iconProps = _objectSpread2({
          icon: 'organization',
          color: 'blue'
        }, iconSizeProps); // Change the icon of the Avatar if its size is Tiny and has no image set.
      } else if (type === 'team') {
        iconProps = _objectSpread2({
          icon: 'ac-meeting',
          color: 'black-64'
        }, iconSizeProps);
      } else if (size === 'xs') {
        iconProps = {
          icon: 'person',
          size: 's'
        };

        if (type === 'user') {
          iconProps.color = 'black-64';
        } else {
          iconProps.color = 'blue';
        }
      } else if (type === 'user') {
        iconProps = _objectSpread2({
          icon: 'person',
          color: 'black-64'
        }, iconSizeProps);
      } else {
        iconProps = _objectSpread2({
          icon: 'person',
          color: 'blue'
        }, iconSizeProps);
      }

      return iconProps;
    }
  }, {
    key: "getImage",
    value: function getImage(img, name) {
      var _this2 = this;

      var imageLoaded = this.state.imageLoaded;
      var style = imageLoaded ? {} : {
        display: 'none'
      }; // In case image is not loaded, show the initials not the alt value

      return imageLoaded ? /*#__PURE__*/React__default.createElement("img", {
        style: style,
        className: cuiClassName('avatar__image'),
        alt: name,
        src: img
      }) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null, this.makeInitials(name), /*#__PURE__*/React__default.createElement("img", {
        style: style,
        onLoad: function onLoad() {
          return _this2.setState({
            imageLoaded: true
          });
        },
        className: cuiClassName('avatar__image'),
        alt: name,
        src: img
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          type = _this$props.type,
          size = _this$props.size,
          img = _this$props.img,
          name = _this$props.name,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('avatar'), _defineProperty({}, cuiClassName("avatar--".concat(type)), type), _defineProperty({}, cuiClassName("avatar--".concat(size)), size), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var content;

      if (type !== 'organization' && img) {
        content = this.getImage(img, name);
      } else {
        var iconProps = this.getIconProps(type, size);

        if (iconProps && (!name || size === 'xs')) {
          iconProps.className = cuiClassName('avatar__icon');
          content = /*#__PURE__*/React__default.createElement(Icon, iconProps);
        }
      }

      return /*#__PURE__*/React__default.createElement("div", props, content ? content : this.makeInitials(name));
    }
  }]);

  return Avatar;
}(Component);
Avatar.propTypes = {
  img: PropTypes.string,
  name: PropTypes.string,
  type: PropTypes.oneOf(['user', 'organization', 'team']),
  size: PropTypes.oneOf(['xl', 'l', 's', 'xs']),
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Avatar);

var Badge = /*#__PURE__*/function (_Component) {
  _inherits(Badge, _Component);

  var _super = _createSuper(Badge);

  function Badge() {
    _classCallCheck(this, Badge);

    return _super.apply(this, arguments);
  }

  _createClass(Badge, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          color = _this$props.color,
          outline = _this$props.outline,
          children = _this$props.children,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('badge'), _defineProperty({}, cuiClassName("badge--".concat(color)), color), _defineProperty({}, cuiClassName("badge--outline"), outline), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      return /*#__PURE__*/React__default.createElement("div", props, children && /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('badge__label')
      }, children), !children && (color === null || color === void 0 ? void 0 : color.includes('tier-')) && /*#__PURE__*/React__default.createElement(Icon, {
        icon: "star",
        size: "s"
      }));
    }
  }]);

  return Badge;
}(Component);
Badge.propTypes = {
  color: PropTypes.oneOf(['green', 'blue', 'yellow', 'red', 'purple', 'white', 'tier-silver', 'tier-gold', 'tier-platinum', 'tier-diamond']),
  outline: PropTypes.bool,
  className: PropTypes.string,
  children: PropTypes.node,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Badge);

var ButtonGroup = /*#__PURE__*/function (_Component) {
  _inherits(ButtonGroup, _Component);

  var _super = _createSuper(ButtonGroup);

  function ButtonGroup() {
    _classCallCheck(this, ButtonGroup);

    return _super.apply(this, arguments);
  }

  _createClass(ButtonGroup, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          color = _this$props.color,
          size = _this$props.size,
          children = _this$props.children,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('button-group'), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var childrenToRender = children;

      if (childrenToRender) {
        var overridenProps = {};

        if (color) {
          overridenProps.color = color;
        }

        if (size) {
          overridenProps.size = size;
        }

        childrenToRender = React__default.Children.map(childrenToRender, function (child) {
          if ( /*#__PURE__*/React__default.isValidElement(child)) {
            return /*#__PURE__*/React__default.cloneElement(child, overridenProps);
          }
        });
      }

      return /*#__PURE__*/React__default.createElement("div", props, childrenToRender);
    }
  }]);

  return ButtonGroup;
}(Component);
ButtonGroup.propTypes = {
  children: PropTypes.node,
  color: PropTypes.oneOf(['blue', 'green', 'red', 'ghost', 'ghost-alternative']),
  size: PropTypes.oneOf(['s']),
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(ButtonGroup);

var checkboxProps = ['autofocus', 'checked', 'defaultChecked', 'value', 'defaultValue', 'disabled', 'form', 'name', 'required', 'onChange', 'tabIndex'];
/**
 * Pick properties that should belong to hidden checkbox like elements.
 */

var getCheckboxProps = (function (props) {
  var checkbox = {};
  var rest = {};
  Object.keys(props).forEach(function (key) {
    if (checkboxProps.includes(key)) {
      checkbox[key] = props[key];
    } else {
      rest[key] = props[key];
    }
  });
  return {
    checkbox: checkbox,
    rest: rest
  };
});

var Checkbox = /*#__PURE__*/function (_Component) {
  _inherits(Checkbox, _Component);

  var _super = _createSuper(Checkbox);

  function Checkbox(props) {
    var _this;

    _classCallCheck(this, Checkbox);

    _this = _super.call(this, props);
    _this.inputElement = /*#__PURE__*/React__default.createRef();
    return _this;
  }

  _createClass(Checkbox, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.checkIndeterminate();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.checkIndeterminate();
    }
  }, {
    key: "checkIndeterminate",
    value: function checkIndeterminate() {
      if ('indeterminate' in this.props && this.inputElement.current) {
        this.inputElement.current.indeterminate = this.props.indeterminate;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          type = _this$props.type,
          children = _this$props.children,
          indeterminate = _this$props.indeterminate,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef,
          inputRef = _this$props.inputRef;
      var className = classnames(cuiClassName('checkbox'), _defineProperty({}, cuiClassName("checkbox--".concat(type)), type), givenClassName);
      var checkboxProps = getCheckboxProps(this.passthrough());

      var props = _objectSpread2(_objectSpread2(_objectSpread2({}, forwardRef && {
        ref: forwardRef
      }), checkboxProps.rest), {}, {
        className: className
      });

      var ref = function ref(node) {
        return triggerReferences(node, _this2.inputElement, inputRef);
      };

      var inputProps = _objectSpread2({
        ref: ref
      }, checkboxProps.checkbox);

      return /*#__PURE__*/React__default.createElement("label", props, /*#__PURE__*/React__default.createElement("input", _extends({
        type: "checkbox"
      }, inputProps)), /*#__PURE__*/React__default.createElement(Icon, {
        icon: indeterminate ? 'minus' : 'check-done',
        size: "s",
        className: cuiClassName('checkbox__checkmark')
      }), children && /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('checkbox__label')
      }, children));
    }
  }]);

  return Checkbox;
}(Component);
Checkbox.propTypes = {
  children: PropTypes.node,
  type: PropTypes.oneOf(['round']),
  indeterminate: PropTypes.bool,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  inputRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Checkbox);

var Dialog = /*#__PURE__*/function (_React$Component) {
  _inherits(Dialog, _React$Component);

  var _super = _createSuper(Dialog);

  function Dialog(props) {
    var _this;

    _classCallCheck(this, Dialog);

    _this = _super.call(this, props);
    _this.state = {
      visible: false,
      actionsLayout: 'row',
      actionsMeasured: false
    };
    _this.actions = /*#__PURE__*/React__default.createRef();
    _this.onTransitionEnd = _this.onTransitionEnd.bind(_assertThisInitialized(_this));
    _this.onKeyUp = _this.onKeyUp.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Dialog, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      if (this.props.visible) {
        this.initialTimeout = setTimeout(function () {
          _this2.enter();
        }, 0);
      }

      this.measureActions();
    }
  }, {
    key: "measureActions",
    value: function measureActions() {
      var _this$props = this.props,
          visible = _this$props.visible,
          actionsLayout = _this$props.actionsLayout;

      if (visible && actionsLayout === 'auto') {
        if (this.actions.current && this.actions.current.firstChild) {
          var _this$actions$current = this.actions.current.getBoundingClientRect(),
              actionsLeft = _this$actions$current.left;

          var _this$actions$current2 = this.actions.current.firstChild.getBoundingClientRect(),
              childLeft = _this$actions$current2.left;

          this.setState({
            actionsLayout: childLeft - actionsLeft <= 0 ? 'column' : 'row',
            actionsMeasured: true
          });
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (!prevProps.visible && this.props.visible) {
        this.enter();
      } else if (prevProps.visible && !this.props.visible) {
        this.leave();
      }

      if (prevProps.actions !== this.props.actions) {
        this.setState({
          actionsMeasured: false
        });
      }

      if (!this.state.actionsMeasured) {
        this.measureActions();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this.initialTimeout);
      document.removeEventListener('keyup', this.onKeyUp);
      document.body.classList.remove('cui4-dialog__container--no-overflow');
    }
  }, {
    key: "enter",
    value: function enter() {
      document.body.classList.add('cui4-dialog__container--no-overflow');
      this.setState({
        visible: true
      });
      document.addEventListener('keyup', this.onKeyUp);
    }
  }, {
    key: "leave",
    value: function leave() {
      document.removeEventListener('keyup', this.onKeyUp);
      document.body.classList.remove('cui4-dialog__container--no-overflow');
      this.setState({
        visible: false
      });
    }
  }, {
    key: "onTransitionEnd",
    value: function onTransitionEnd(event) {
      if (event.propertyName === 'opacity' && event.target === this.el) {
        this.props.onTransitionEnd && this.props.onTransitionEnd();
      }
    }
  }, {
    key: "onKeyUp",
    value: function onKeyUp(event) {
      if (this.props.closeOnEsc && event.keyCode === 27) {
        this.props.onClose();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props2 = this.props,
          className = _this$props2.className,
          dialogContainer = _this$props2.dialogContainer,
          title = _this$props2.title,
          children = _this$props2.children,
          actions = _this$props2.actions,
          actionsLayout = _this$props2.actionsLayout,
          forwardRef = _this$props2.forwardRef,
          onBackdropClick = _this$props2.onBackdropClick;
      var actualActionsLayout = actionsLayout === 'auto' ? this.state.actionsLayout : actionsLayout;
      var dialogClassName = classnames(cuiClassName('dialog'), _defineProperty({}, cuiClassName('dialog--visible'), this.state.visible), _defineProperty({}, cuiClassName('dialog--actions-layout-column'), actualActionsLayout === 'column'), className);

      var dialogProps = _objectSpread2(_objectSpread2({}, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default.createElement("div", {
        className: dialogClassName,
        onTransitionEnd: this.onTransitionEnd,
        ref: function ref(el) {
          _this3.el = el;
        }
      }, /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('dialog__backdrop'),
        role: "button",
        tabIndex: 0,
        onClick: onBackdropClick
      }), /*#__PURE__*/React__default.createElement("div", _extends({
        className: cuiClassName('dialog__wrap')
      }, dialogProps), title && /*#__PURE__*/React__default.createElement("h6", {
        className: cuiClassName('dialog__title')
      }, title), /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('dialog__content')
      }, children), /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('dialog__actions'),
        ref: this.actions
      }, actions))), dialogContainer);
    }
  }]);

  return Dialog;
}(React__default.Component);

Dialog.propTypes = {
  title: PropTypes.string,
  children: PropTypes.node.isRequired,
  actions: PropTypes.node.isRequired,
  actionsLayout: PropTypes.oneOf(['auto', 'row', 'column']),
  visible: PropTypes.bool,
  className: PropTypes.string,
  closeOnEsc: PropTypes.bool,
  onClose: PropTypes.func.isRequired,
  onTransitionEnd: PropTypes.func,
  onBackdropClick: PropTypes.func,
  dialogContainer: PropTypes.object,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
Dialog.defaultProps = {
  closeOnEsc: true,
  visible: false,
  className: '',

  get dialogContainer() {
    return typeof document === 'undefined' ? null : document.body;
  },

  actionsLayout: 'auto'
};
passthrough()(Dialog);

var Text = /*#__PURE__*/function (_Component) {
  _inherits(Text, _Component);

  var _super = _createSuper(Text);

  function Text() {
    _classCallCheck(this, Text);

    return _super.apply(this, arguments);
  }

  _createClass(Text, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('text'), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      return /*#__PURE__*/React__default.createElement("div", props, this.props.children);
    }
  }]);

  return Text;
}(Component);
Text.propTypes = {
  children: PropTypes.node,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Text);

var Tooltip = /*#__PURE__*/function (_Popover) {
  _inherits(Tooltip, _Popover);

  var _super = _createSuper(Tooltip);

  function Tooltip(props) {
    _classCallCheck(this, Tooltip);

    return _super.call(this, props);
  }

  _createClass(Tooltip, [{
    key: "baseClassName",
    get: function get() {
      return 'tooltip';
    }
  }, {
    key: "defaultSpacing",
    get: function get() {
      return {
        vertical: 'xs',
        horizontal: 's'
      };
    }
  }, {
    key: "distanceFromPopper",
    get: function get() {
      return 2;
    }
  }, {
    key: "getTriggerProps",
    value: function getTriggerProps() {
      var _this = this;

      var _onClick = this.props.children.props.onClick;
      return {
        onMouseMove: this.mouseMove,
        onMouseEnter: this.mouseEnter,
        onMouseLeave: this.mouseLeave,
        onClick: function onClick(e) {
          _onClick && _onClick(e);
          _this.state.visible && _this.onPopupVisibleChange(!_this.state.visible);
        }
      };
    }
  }, {
    key: "shouldRenderArrow",
    value: function shouldRenderArrow() {
      return true;
    }
  }, {
    key: "checkWindowEventListeners",
    value: function checkWindowEventListeners() {}
  }]);

  return Tooltip;
}(Popover);

Tooltip.displayName = 'Tooltip';
Tooltip.propTypes = _objectSpread2(_objectSpread2({}, Popover.propTypes), {}, {
  mouseEnterDelay: PropTypes.number,
  mouseLeaveDelay: PropTypes.number
});
Tooltip.defaultProps = {
  placement: 'bottom',
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1
}; // Reset passthrough

Tooltip.prototype.passthrough = undefined;
/* eslint-disable-line */

passthrough()(Tooltip);

var blurOnEnter = function blurOnEnter(event) {
  if (event.key === 'Enter') {
    event.preventDefault();
    event.currentTarget.blur();
  }
};

var EditableText = function EditableText(_ref) {
  var placeholder = _ref.placeholder,
      children = _ref.children,
      onChange = _ref.onChange,
      readOnly = _ref.readOnly,
      maxLength = _ref.maxLength,
      tagType = _ref.tagType,
      icon = _ref.icon,
      tooltipProps = _ref.tooltipProps,
      givenClassName = _ref.className;
  var inputRef = useRef(null);
  var textRef = useRef(null);

  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      width = _useState2[0],
      setWidth = _useState2[1];

  var _useState3 = useState(children),
      _useState4 = _slicedToArray(_useState3, 2),
      value = _useState4[0],
      setValue = _useState4[1];

  var _useState5 = useState(true),
      _useState6 = _slicedToArray(_useState5, 2),
      hideTooltip = _useState6[0],
      setHideTooltip = _useState6[1];

  var _useState7 = useState(placeholder || children),
      _useState8 = _slicedToArray(_useState7, 1),
      placeholderValue = _useState8[0];

  var TagType = tagType;

  var _useState9 = useState(false),
      _useState10 = _slicedToArray(_useState9, 2),
      isActive = _useState10[0],
      setIsActive = _useState10[1];

  var updateWidth = function updateWidth() {
    var _textRef$current;

    (textRef === null || textRef === void 0 ? void 0 : (_textRef$current = textRef.current) === null || _textRef$current === void 0 ? void 0 : _textRef$current.offsetWidth) && setWidth(textRef.current.offsetWidth + 1);
  };

  var handleBlur = function handleBlur() {
    var trimmedValue = value.trim();

    if (trimmedValue !== value) {
      setValue(trimmedValue);
    }

    if (onChange) {
      onChange(trimmedValue);
    }

    setIsActive(false);
  };

  var handleChange = function handleChange(event) {
    setValue(event.target.value);
  };

  var handleFocus = function handleFocus() {
    if (readOnly) {
      return;
    }

    setIsActive(true);
  };

  var isSmallText = ['h3', 'h4', 'p'].includes(TagType);
  var editableTextClasses = classnames(cuiClassName('editable-text'), _defineProperty({}, cuiClassName('editable-text--active'), isActive), _defineProperty({}, cuiClassName('editable-text--readonly'), readOnly), _defineProperty({}, cuiClassName('editable-text--icon-right'), icon), _defineProperty({}, cuiClassName('editable-text--small'), isSmallText), givenClassName);
  useEffect(function () {
    setValue(children);
  }, [children]);
  useEffect(function () {
    updateWidth();
  }, [value]);
  useEffect(function () {
    if (tooltipProps && value) {
      setHideTooltip(width <= inputRef.current.offsetWidth);
    }
  }, [width]);
  useEffect(function () {
    if (!document.fonts || document.fonts.status === 'loaded') {
      return;
    }

    document.fonts.ready.then(function () {
      updateWidth();
    });
  }, []);
  return /*#__PURE__*/React__default.createElement(Text, {
    className: editableTextClasses
  }, /*#__PURE__*/React__default.createElement(Tooltip, _extends({}, !tooltipProps && {
    visible: false
  }, tooltipProps, {
    content: value,
    className: hideTooltip ? cuiClassName('tooltip--hidden') : ''
  }), /*#__PURE__*/React__default.createElement(TagType, {
    className: cuiClassName('editable-text__box')
  }, /*#__PURE__*/React__default.createElement("input", {
    className: cuiClassName('editable-text__input'),
    placeholder: placeholderValue,
    style: {
      width: width
    },
    value: value,
    readOnly: readOnly,
    onFocus: handleFocus,
    onChange: handleChange,
    onBlur: handleBlur,
    onKeyDown: blurOnEnter,
    maxLength: maxLength,
    ref: inputRef
  }), icon &&
  /*#__PURE__*/

  /* eslint-disable-next-line no-undefined */
  React__default.createElement(Icon, {
    icon: icon,
    color: "black-32",
    size: isSmallText ? 's' : undefined
  }))), /*#__PURE__*/React__default.createElement(TagType, {
    className: cuiClassName('editable-text__child'),
    dangerouslySetInnerHTML: {
      __html: (value || placeholderValue).replace(/\s/g, '&nbsp;')
    },
    ref: textRef
  }));
};

EditableText.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  tagType: PropTypes.oneOf(['h1', 'h2', 'h3', 'h4', 'p']),
  icon: PropTypes.string,
  onChange: PropTypes.func,
  placeholder: PropTypes.string,
  readOnly: PropTypes.bool,
  maxLength: PropTypes.number,
  tooltipProps: Tooltip.propTypes
};
EditableText.defaultProps = {
  children: '',
  tagType: 'h1',
  readOnly: false
};
passthrough()(EditableText);

var Modal = /*#__PURE__*/function (_React$Component) {
  _inherits(Modal, _React$Component);

  var _super = _createSuper(Modal);

  function Modal(props) {
    var _this;

    _classCallCheck(this, Modal);

    _this = _super.call(this, props);
    _this.state = {
      visible: false
    };
    _this.onTransitionEnd = _this.onTransitionEnd.bind(_assertThisInitialized(_this));
    _this.onKeyUp = _this.onKeyUp.bind(_assertThisInitialized(_this));
    _this.modalContentRef = /*#__PURE__*/React__default.createRef();
    return _this;
  }

  _createClass(Modal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      if (this.props.visible) {
        this.initialTimeout = setTimeout(function () {
          _this2.enter();

          _this2.props.autoFocus && _this2.focusFirstElement();
        }, 0);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var becameVisible = !prevProps.visible && this.props.visible;
      var hasStoppedLoading = prevProps.loading && !this.props.loading;

      if (this.props.autoFocus && (becameVisible || hasStoppedLoading)) {
        this.focusFirstElement();
      }

      if (!prevProps.visible && this.props.visible) {
        this.enter();
      } else if (prevProps.visible && !this.props.visible) {
        this.leave();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this.initialTimeout);
      this.props.autoFocus && clearTimeout(this.focusTimeout);
      document.removeEventListener('keyup', this.onKeyUp);
      document.body.classList.remove('cui4-modal__container--no-overflow');
    }
  }, {
    key: "enter",
    value: function enter() {
      document.body.classList.add('cui4-modal__container--no-overflow');
      this.setState({
        visible: true
      });
      document.addEventListener('keyup', this.onKeyUp);
    }
  }, {
    key: "leave",
    value: function leave() {
      document.removeEventListener('keyup', this.onKeyUp);
      document.body.classList.remove('cui4-modal__container--no-overflow');
      this.setState({
        visible: false
      });
    }
  }, {
    key: "onTransitionEnd",
    value: function onTransitionEnd(event) {
      if (event.propertyName === 'opacity' && event.target === this.el) {
        this.props.onTransitionEnd && this.props.onTransitionEnd();
      }
    }
  }, {
    key: "onKeyUp",
    value: function onKeyUp(event) {
      if (this.props.closeOnEsc && event.keyCode === 27) {
        this.props.onClose();
      }
    }
  }, {
    key: "focusFirstElement",
    value: function focusFirstElement() {
      var _this3 = this;

      this.focusTimeout = setTimeout(function () {
        var firstInput = _this3.modalContentRef.current.querySelector('input:enabled');

        firstInput && firstInput.focus();
      }, 100);
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props = this.props,
          loading = _this$props.loading,
          loadingHeight = _this$props.loadingHeight,
          backdrop = _this$props.backdrop,
          onClose = _this$props.onClose,
          header = _this$props.header,
          footer = _this$props.footer,
          className = _this$props.className,
          modalContainer = _this$props.modalContainer,
          children = _this$props.children,
          forwardRef = _this$props.forwardRef,
          onBackdropClick = _this$props.onBackdropClick,
          spacing = _this$props.spacing;
      var modalClassName = classnames(cuiClassName('modal'), _defineProperty({}, cuiClassName('modal--visible'), this.state.visible), className);

      var modalProps = _objectSpread2(_objectSpread2({}, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var backdropClassName = classnames(cuiClassName('modal__backdrop'), _defineProperty({}, cuiClassName('modal__backdrop--transparent'), !backdrop));
      var contentClassName = classnames(cuiClassName('modal__content'), _defineProperty({}, cuiClassName('modal__content--loading'), loading));
      var contentStyle = loading && loadingHeight ? {
        height: "".concat(loadingHeight, "px")
      } : {};
      var needsSpacing = spacing || !hasSpacing(children);
      var spacingProps = spacing ? typeof spacing === 'string' ? {
        all: spacing
      } : spacing : {
        all: 'm'
      };
      var modalContent = loading ? /*#__PURE__*/React__default.createElement(Spinner, null) : children;
      return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default.createElement("div", {
        className: modalClassName,
        onTransitionEnd: this.onTransitionEnd,
        ref: function ref(el) {
          _this4.el = el;
        }
      }, /*#__PURE__*/React__default.createElement("div", {
        className: backdropClassName,
        role: "button",
        tabIndex: 0,
        onClick: onBackdropClick
      }), /*#__PURE__*/React__default.createElement("div", _extends({
        className: cuiClassName('modal__wrap')
      }, modalProps), /*#__PURE__*/React__default.createElement("header", {
        className: cuiClassName('modal__header')
      }, /*#__PURE__*/React__default.createElement(Button, {
        color: "ghost",
        size: "s",
        className: cuiClassName('modal__close'),
        onClick: onClose
      }, /*#__PURE__*/React__default.createElement(Icon, {
        size: "s",
        icon: "cross"
      })), /*#__PURE__*/React__default.createElement("h3", {
        title: header
      }, header)), /*#__PURE__*/React__default.createElement("div", {
        ref: this.modalContentRef,
        className: contentClassName,
        style: contentStyle
      }, needsSpacing ? /*#__PURE__*/React__default.createElement(Spacing, spacingProps, modalContent) : modalContent), this.props.footer && /*#__PURE__*/React__default.createElement("footer", {
        className: cuiClassName('modal__footer')
      }, footer))), modalContainer);
    }
  }]);

  return Modal;
}(React__default.Component);

Modal.propTypes = {
  backdrop: PropTypes.bool,
  visible: PropTypes.bool,
  loading: PropTypes.bool,
  loadingHeight: PropTypes.number,
  className: PropTypes.string,
  closeOnEsc: PropTypes.bool,
  onClose: PropTypes.func.isRequired,
  onTransitionEnd: PropTypes.func,
  header: PropTypes.string.isRequired,
  children: PropTypes.node.isRequired,
  footer: PropTypes.node,
  modalContainer: PropTypes.object,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  onBackdropClick: PropTypes.func,
  spacing: PropTypes.oneOfType([oneOfDimensionSizes, PropTypes.shape(spacingPropTypes)]),
  autoFocus: PropTypes.bool
};
Modal.defaultProps = {
  backdrop: true,
  closeOnEsc: false,
  visible: false,
  autoFocus: false,
  className: '',

  get modalContainer() {
    return typeof document === 'undefined' ? null : document.body;
  }

};
passthrough()(Modal);

var Panel = /*#__PURE__*/function (_Component) {
  _inherits(Panel, _Component);

  var _super = _createSuper(Panel);

  function Panel() {
    _classCallCheck(this, Panel);

    return _super.apply(this, arguments);
  }

  _createClass(Panel, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          color = _this$props.color,
          noMargin = _this$props.noMargin,
          children = _this$props.children,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef,
          spacing = _this$props.spacing,
          radius = _this$props.radius,
          noBorder = _this$props.noBorder,
          elevation = _this$props.elevation;
      var className = classnames(cuiClassName('panel'), _defineProperty({}, cuiClassName("panel--".concat(color)), color), _defineProperty({}, cuiClassName('panel--no-margin'), noMargin), _defineProperty({}, cuiClassName("panel--radius-".concat(radius)), radius), _defineProperty({}, cuiClassName("panel--no-border"), noBorder), _defineProperty({}, cuiClassName("panel--elevation-".concat(elevation)), elevation), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var needsSpacing = spacing || !hasSpacing(children);
      var spacingProps = spacing ? typeof spacing === 'string' ? {
        all: spacing
      } : spacing : {
        all: 'm'
      };
      return /*#__PURE__*/React__default.createElement("div", props, needsSpacing ? /*#__PURE__*/React__default.createElement(Spacing, spacingProps, children) : children);
    }
  }]);

  return Panel;
}(Component);
Panel.propTypes = {
  color: PropTypes.oneOf(['green', 'blue', 'yellow', 'red', 'note-yellow', 'transparent', 'black']),
  elevation: PropTypes.oneOf(['01', '02', '03', '08', '16', '24']),
  radius: PropTypes.oneOf(['s', 'm', 'l', 'xl']),
  noBorder: PropTypes.bool,
  noMargin: PropTypes.bool,
  className: PropTypes.string,
  children: PropTypes.node,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  spacing: PropTypes.oneOfType([oneOfDimensionSizes, PropTypes.shape(spacingPropTypes)])
};
passthrough()(Panel);

var baseClassName = cuiClassName('feedback-modal');
var footerButtonClassName = "".concat(baseClassName, "__footer-button");
var fieldRoot = "".concat(baseClassName, "__field");
var fieldClassNames = {
  root: fieldRoot,
  labelWrapper: "".concat(fieldRoot, "-label-wrapper"),
  invalidMessage: "".concat(fieldRoot, "-invalid-message"),
  requiredAsterisk: "".concat(fieldRoot, "-required-asterisk")
};

function ModalFooter(_ref) {
  var textSet = _ref.textSet,
      isFormValid = _ref.isFormValid,
      startClosing = _ref.startClosing,
      submit = _ref.submit;
  var onMouseDown = useCallback(function (e) {
    return e.preventDefault();
  }, []);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button, {
    className: footerButtonClassName,
    onClick: startClosing
  }, textSet.cancel), /*#__PURE__*/React__default.createElement(Button, {
    className: footerButtonClassName,
    disabled: !isFormValid,
    color: "green",
    onMouseDown: onMouseDown,
    onMouseUp: submit
  }, textSet.submit));
}

ModalFooter.propTypes = {
  textSet: PropTypes.object.isRequired,
  isFormValid: PropTypes.bool.isRequired,
  startClosing: PropTypes.func.isRequired,
  submit: PropTypes.func.isRequired
};
var ModalFooter$1 = /*#__PURE__*/memo(ModalFooter);

var SET_IS_FORM_VALID = 'FeedbackModal/SET_IS_FORM_VALID';
var ADD_FIELD = 'FeedbackModal/ADD_FIELD';
var UPDATE_FIELD_VALUE = 'FeedbackModal/UPDATE_FIELD_VALUE';
var UPDATE_FIELD_VALIDITY = 'FeedbackModal/UPDATE_FIELD_VALIDITY';
var SET_FIELD_IS_VALIDATED_ONCE = 'FeedbackModal/SET_FIELD_IS_VALIDATED_ONCE';
var UPDATE_FIELDS = 'FeedbackModal/UPDATE_FIELDS';
var SET_IS_CLOSING = 'FeedbackModal/SET_IS_CLOSING';
var fieldTypes = {
  checkbox: 'checkbox',
  select: 'select',
  textarea: 'textarea'
};
var minTextLength = 3;
var defaultTextSet = {
  title: 'Feedback',
  cancel: 'Cancel',
  submit: 'Submit'
};

var checkbox = fieldTypes.checkbox;
/**
 * @typedef {Object} Options
 * @property {string} type - field type.
 * @property {string|boolean} value - field value.
 * @property {string|boolean} initialValue - field initial value.
 */

/**
 * @summary Gets field initial value.
 * @param {Options} options - field options.
 * @returns {string|boolean} - field initial value.
 */

function getInitialValue(options) {
  if (typeof (options === null || options === void 0 ? void 0 : options.initialValue) !== 'undefined') {
    return options.initialValue;
  }

  if (typeof (options === null || options === void 0 ? void 0 : options.value) !== 'undefined') {
    return options.value;
  }

  var type = options.type;

  if (type === checkbox) {
    return false;
  }

  return '';
}
/**
 * @typedef {Object} Field
 * @property {string} type - field type.
 * @property {string} id - field id.
 * @property {string} uid - field unique prefixed id.
 * @property {string} value - field value.
 * @property {string} initialValue - field initialValue.
 * @property {boolean} required - is field required.
 * @property {boolean} isValid - is field valid.
 * @property {boolean} isValidatedOnce - is field validated once.
 * @property {string} invalidMessage - invalid field reason message.
 */

/**
 * @summary Gets initial field.
 * @param {string} id - field id.
 * @param {Options} options - field options.
 * @returns {Field} - initial field.
 */

function getInitialField(id, options) {
  var uid = "".concat(baseClassName, "-").concat(id);
  var initialValue = getInitialValue(options);
  var required = !!(options !== null && options !== void 0 && options.required);
  return _objectSpread2(_objectSpread2({}, options), {}, {
    id: id,
    uid: uid,
    value: initialValue,
    initialValue: initialValue,
    required: required,
    isValid: true,
    isValidatedOnce: false,
    invalidMessage: ''
  });
}

var initialState = {
  isVisible: false,
  isFormValid: true,
  fields: {},
  isClosing: false
};
function reducer(state, action) {
  switch (action.type) {
    case SET_IS_FORM_VALID:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        isFormValid: action.status
      });

    case ADD_FIELD:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        fields: _objectSpread2(_objectSpread2({}, state.fields), {}, _defineProperty({}, action.id, getInitialField(action.id, action.options)))
      });

    case UPDATE_FIELD_VALUE:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        fields: _objectSpread2(_objectSpread2({}, state.fields), {}, _defineProperty({}, action.id, _objectSpread2(_objectSpread2({}, state.fields[action.id]), {}, {
          value: action.value
        })))
      });

    case UPDATE_FIELD_VALIDITY:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        fields: _objectSpread2(_objectSpread2({}, state.fields), {}, _defineProperty({}, action.id, _objectSpread2(_objectSpread2({}, state.fields[action.id]), {}, {
          isValid: action.isValid,
          invalidMessage: action.invalidMessage
        })))
      });

    case SET_FIELD_IS_VALIDATED_ONCE:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        fields: _objectSpread2(_objectSpread2({}, state.fields), {}, _defineProperty({}, action.id, _objectSpread2(_objectSpread2({}, state.fields[action.id]), {}, {
          isValidatedOnce: true
        })))
      });

    case UPDATE_FIELDS:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        fields: action.fields
      });

    case SET_IS_CLOSING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        isClosing: action.status
      });

    default:
      return state;
  }
}

/**
 * @summary Gets text set.
 * @param {Object} initTextSet - initial text set passed
 * from the outside.
 * @returns {Object} - text set.
 */

function useTextSet(initTextSet) {
  return useMemo(function () {
    if (!initTextSet) {
      return defaultTextSet;
    }

    return _objectSpread2(_objectSpread2({}, defaultTextSet), initTextSet);
  }, [initTextSet]);
}

function setIsFormValid(status) {
  return {
    type: SET_IS_FORM_VALID,
    status: status
  };
}
function addField(id, options) {
  return {
    type: ADD_FIELD,
    id: id,
    options: options
  };
}
function updateFieldValue(id, value) {
  return {
    type: UPDATE_FIELD_VALUE,
    id: id,
    value: value
  };
}
function updateFieldValidity(id, _ref) {
  var isValid = _ref.isValid,
      invalidMessage = _ref.invalidMessage;
  return {
    type: UPDATE_FIELD_VALIDITY,
    id: id,
    isValid: isValid,
    invalidMessage: invalidMessage
  };
}
function setFieldIsValidatedOnce(id) {
  return {
    type: SET_FIELD_IS_VALIDATED_ONCE,
    id: id
  };
}
function updateFields(fields) {
  return {
    type: UPDATE_FIELDS,
    fields: fields
  };
}
function setIsClosing(status) {
  return {
    type: SET_IS_CLOSING,
    status: status
  };
}

/**
 * @summary Returns memoized set of state actions.
 * @param {Function} dispatch - state dispatch function.
 * @returns {Object} - memoized set of state actions.
 */

function useActions(dispatch) {
  return useMemo(function () {
    var addField$1 = function addField$1(id, options) {
      return dispatch(addField(id, options));
    };

    var updateFieldValue$1 = function updateFieldValue$1(id, value) {
      return dispatch(updateFieldValue(id, value));
    };

    var updateFieldValidity$1 = function updateFieldValidity$1(id, _ref) {
      var isValid = _ref.isValid,
          invalidMessage = _ref.invalidMessage;
      dispatch(updateFieldValidity(id, {
        isValid: isValid,
        invalidMessage: invalidMessage
      }));
    };

    var setFieldIsValidatedOnce$1 = function setFieldIsValidatedOnce$1(id) {
      dispatch(setFieldIsValidatedOnce(id));
    };

    var updateFields$1 = function updateFields$1(fields) {
      return dispatch(updateFields(fields));
    };

    var startClosing = function startClosing() {
      return dispatch(setIsClosing(true));
    };

    var finishClosing = function finishClosing() {
      return dispatch(setIsClosing(false));
    };

    var setIsFormValid$1 = function setIsFormValid$1(isFormValid) {
      return dispatch(setIsFormValid(isFormValid));
    };

    return {
      addField: addField$1,
      updateFieldValue: updateFieldValue$1,
      updateFieldValidity: updateFieldValidity$1,
      setFieldIsValidatedOnce: setFieldIsValidatedOnce$1,
      updateFields: updateFields$1,
      startClosing: startClosing,
      finishClosing: finishClosing,
      setIsFormValid: setIsFormValid$1
    };
  }, []);
}

var select = fieldTypes.select,
    textarea = fieldTypes.textarea;
/**
 * @typedef {Object} Field
 * @property {string|boolean} value - field value.
 * @property {boolean} required - is field required.
 */

/**
 * @typedef {Object} ValidityInfo
 * @property {boolean} isValid - is field valid.
 * @property {string} invalidMessage - field invalid message.
 */

/**
 * @summary Gets field text type validity.
 * @param {Field} field - field info.
 * @returns {ValidityInfo} - field text type validity.
 */

function getTextValidity(_ref) {
  var value = _ref.value,
      required = _ref.required;
  var warnings = [];

  if (!value && required) {
    warnings.push('Required.');
  }

  if (value.length < minTextLength) {
    warnings.push("Minimum length is ".concat(minTextLength, " characters."));
  }

  return {
    isValid: !warnings.length,
    invalidMessage: warnings.join(' ')
  };
}
/**
 * @summary Gets field select type validity.
 * @param {Field} field - field info.
 * @returns {ValidityInfo} - field select type validity.
 */

function getSelectValidity(_ref2) {
  var value = _ref2.value,
      required = _ref2.required;
  var warnings = [];

  if (!value && required) {
    warnings.push('Please, choose an option.');
  }

  return {
    isValid: !warnings.length,
    invalidMessage: warnings.join(' ')
  };
}
/**
 * @summary Gets field validity.
 * @param {Field} field - field info.
 * @returns {ValidityInfo} - field validity.
 */

function getFieldValidity(field) {
  var type = field.type;

  if (type === textarea) {
    return getTextValidity(field);
  }

  if (type === select) {
    return getSelectValidity(field);
  }

  return {
    isValid: true,
    invalidMessage: ''
  };
}

/**
 * @summary Gets validated fields.
 * @param {Object} fields - all fields.
 * @returns {Object} - validated fields.
 */

function getValidatedFields(fields) {
  return Object.entries(fields).reduce(function (acc, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        id = _ref2[0],
        field = _ref2[1];

    if (field.isValidatedOnce) {
      return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, id, _objectSpread2({}, field)));
    }

    var _getFieldValidity = getFieldValidity(field),
        isValid = _getFieldValidity.isValid,
        invalidMessage = _getFieldValidity.invalidMessage;

    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, id, _objectSpread2(_objectSpread2({}, field), {}, {
      isValid: isValid,
      invalidMessage: invalidMessage,
      isValidatedOnce: true
    })));
  }, {});
}

/**
 * @summary Gets is form valid.
 * @param {Object} fields - all fields.
 * @returns {boolean} - is form valid.
 */
function getIsFormValid(fields) {
  return Object.values(fields).every(function (field) {
    return field.isValid;
  });
}

/**
 * @summary Gets field values to submit.
 * @param {Object} fields - fields info.
 * @returns {Object} - field values to submit.
 */
function getFieldValuesToSubmit(fields) {
  return Object.entries(fields).reduce(function (acc, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[0],
        field = _ref2[1];

    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, name, field.value));
  }, {});
}

/**
 * @typedef {Object} Payload
 * @property {Object} fields - all fields.
 * @property {boolean} isFormValid - is form valid.
 * @property {Function} updateFields - all fields updater.
 * @property {Function} setIsFormValid - form validity updater.
 * @property {Function} onSubmit - on submit passed from the outside.
 * @property {Function} startClosing - starts closing
 * of the modal.
 */

/**
 * @summary Gets submit handler.
 * @param {Payload} payload - payload.
 * @returns {Function} - submit handler.
 */

function useSubmitHandler(_ref) {
  var fields = _ref.fields,
      isFormValid = _ref.isFormValid,
      updateFields = _ref.updateFields,
      setIsFormValid = _ref.setIsFormValid,
      onSubmit = _ref.onSubmit,
      startClosing = _ref.startClosing;
  return useCallback(function () {
    var validatedFields = getValidatedFields(fields);
    updateFields(validatedFields);
    var isUpdatedFormValid = getIsFormValid(validatedFields);

    if (isUpdatedFormValid !== isFormValid) {
      setIsFormValid(isUpdatedFormValid);
    }

    if (!isUpdatedFormValid) {
      return;
    }

    var valuesToSubmit = getFieldValuesToSubmit(fields);
    onSubmit(valuesToSubmit);
    startClosing();
  }, [fields, isFormValid, onSubmit]);
}

var FormContext = /*#__PURE__*/createContext$1();
function useFormContext() {
  var context = useContext(FormContext);

  if (!context) {
    throw new Error("FeedbackModal/Form compound components cannot be rendered outside of their parent.");
  }

  return context;
}
var FieldContext = /*#__PURE__*/createContext$1();
function useFieldContext() {
  var context = useContext(FieldContext);

  if (!context) {
    throw new Error("FeedbackModal/Field compound components cannot be rendered outside of their parent.");
  }

  return context;
}

var checkbox$1 = fieldTypes.checkbox,
    select$1 = fieldTypes.select;
/**
 * @summary Gets the correct event value depending
 * on the field type.
 * @param {Event|string} event - on change event.
 * @param {string} type - field type.
 * @returns {string|boolean} - correct event value depending
 * on the field type.
 */

function getEventValue(event, type) {
  if (type === checkbox$1) {
    return event.target.checked;
  }

  if (type === select$1) {
    return event;
  }

  return event.target.value;
}

/**
 * @typedef {Object} Payload
 * @property {string} id - field id.
 * @property {string} type - field type.
 * @property {Function} updateFieldValue - field value updater.
 */

/**
 * @summary Gets field value updater.
 * @param {Payload} payload - payload.
 * @returns {Function} - field value updater.
 */

function useFieldValueUpdater(_ref) {
  var id = _ref.id,
      type = _ref.type,
      updateFieldValue = _ref.updateFieldValue;
  return useCallback(function (event) {
    var eventValue = getEventValue(event, type);
    updateFieldValue(id, eventValue);
  }, []);
}

/**
 * @typedef {Object} Payload
 * @property {string} id - field id.
 * @property {Object} field - field info.
 * @property {boolean} isValidatedOnce - is field validated once.
 * @property {Function} updateFieldValidity - field validity updater.
 * @property {Function} setFieldIsValidatedOnce - field is validated * once updater.
 */

/**
 * @summary Gets field validity updater.
 * @param {Payload} payload -
 * @returns {Function} - field validity updater.
 */

function useFieldValidityUpdater(_ref) {
  var id = _ref.id,
      field = _ref.field,
      isValidatedOnce = _ref.isValidatedOnce,
      updateFieldValidity = _ref.updateFieldValidity,
      setFieldIsValidatedOnce = _ref.setFieldIsValidatedOnce;
  var value = field.value;
  return useCallback(function () {
    var _getFieldValidity = getFieldValidity(field),
        isValid = _getFieldValidity.isValid,
        invalidMessage = _getFieldValidity.invalidMessage;

    updateFieldValidity(id, {
      isValid: isValid,
      invalidMessage: invalidMessage
    });

    if (!isValidatedOnce) {
      setFieldIsValidatedOnce(id);
    }
  }, [isValidatedOnce, value]);
}

var select$2 = fieldTypes.select,
    textarea$1 = fieldTypes.textarea;
/**
 * @typedef {Object} UseValueChangePayload
 * @property {string} type - field type.
 * @property {string|boolean} value - field value.
 * @property {string|boolean} initialValue - field initial value.
 * @property {boolean} isValidatedOnce - is field validated once.
 * @property {Function} updateValidity - field validity updater.
 */

/**
 * @typedef {Object} UseValidityChangePayload
 * @property {Object} fields - all fields.
 * @property {boolean} isValid - is field valid.
 * @property {boolean} isFormValid - is form valid.
 * @property {Function} setIsFormValid - form validity updater.
 */

/**
 * @summary Performs updates on field value change.
 * @param {UseValueChangePayload} payload -
 */

function useValueChange(_ref) {
  var type = _ref.type,
      value = _ref.value,
      initialValue = _ref.initialValue,
      isValidatedOnce = _ref.isValidatedOnce,
      updateValidity = _ref.updateValidity;
  useEffect(function () {
    var _validationConditions;

    if (typeof value === 'undefined') {
      return;
    }

    var validationConditions = (_validationConditions = {}, _defineProperty(_validationConditions, select$2, value !== initialValue), _defineProperty(_validationConditions, textarea$1, isValidatedOnce), _validationConditions);
    var shouldValidate = validationConditions === null || validationConditions === void 0 ? void 0 : validationConditions[type];

    if (shouldValidate) {
      updateValidity();
    }
  }, [value]);
}
/**
 * @summary Performs updates on field validity change.
 * @param {UseValidityChangePayload} payload -
 */

function useValidityChange(_ref2) {
  var fields = _ref2.fields,
      isValid = _ref2.isValid,
      isFormValid = _ref2.isFormValid,
      setIsFormValid = _ref2.setIsFormValid;
  useEffect(function () {
    var isUpdatedFormValid = getIsFormValid(fields);

    if (isUpdatedFormValid !== isFormValid) {
      setIsFormValid(isUpdatedFormValid);
    }
  }, [isValid]);
}

/**
 * @typedef {Object} Payload
 * @property {Object} fields - all fields.
 * @property {string} type - field type.
 * @property {string|boolean} value - field value.
 * @property {string|boolean} initialValue - field initial value.
 * @property {boolean} isValidatedOnce - is field validated once.
 * @property {boolean} isValid - is field valid.
 * @property {boolean} isFormValid - is form valid.
 * @property {Function} updateValidity - field validity updater.
 * @property {Function} setIsFormValid - form validity updater.
 */

/**
 * @summary Performs field validation.
 * @param {Payload} payload - validation payload.
 */

function useFieldValidation(_ref) {
  var fields = _ref.fields,
      type = _ref.type,
      value = _ref.value,
      initialValue = _ref.initialValue,
      isValidatedOnce = _ref.isValidatedOnce,
      isValid = _ref.isValid,
      isFormValid = _ref.isFormValid,
      updateValidity = _ref.updateValidity,
      setIsFormValid = _ref.setIsFormValid;
  useValueChange({
    type: type,
    value: value,
    initialValue: initialValue,
    isValidatedOnce: isValidatedOnce,
    updateValidity: updateValidity
  });
  useValidityChange({
    fields: fields,
    isValid: isValid,
    isFormValid: isFormValid,
    setIsFormValid: setIsFormValid
  });
}

var checkbox$2 = fieldTypes.checkbox,
    select$3 = fieldTypes.select,
    textarea$2 = fieldTypes.textarea;

function Field(_ref) {
  var _fields$id;

  var id = _ref.id,
      options = _ref.options,
      children = _ref.children;

  var _useFormContext = useFormContext(),
      fields = _useFormContext.fields,
      addField = _useFormContext.addField,
      updateFieldValue = _useFormContext.updateFieldValue,
      updateFieldValidity = _useFormContext.updateFieldValidity,
      setFieldIsValidatedOnce = _useFormContext.setFieldIsValidatedOnce,
      isFormValid = _useFormContext.isFormValid,
      setIsFormValid = _useFormContext.setIsFormValid;

  var field = (_fields$id = fields === null || fields === void 0 ? void 0 : fields[id]) !== null && _fields$id !== void 0 ? _fields$id : {};
  var uid = field.uid,
      value = field.value,
      initialValue = field.initialValue,
      label = field.label,
      required = field.required,
      isValid = field.isValid,
      invalidMessage = field.invalidMessage,
      isValidatedOnce = field.isValidatedOnce;
  var type = options.type;
  var updateValue = useFieldValueUpdater({
    id: id,
    type: type,
    updateFieldValue: updateFieldValue
  });
  var updateValidity = useFieldValidityUpdater({
    id: id,
    field: field,
    isValidatedOnce: isValidatedOnce,
    updateFieldValidity: updateFieldValidity,
    setFieldIsValidatedOnce: setFieldIsValidatedOnce
  });
  var onUpdateValidity = useCallback(function (event) {
    event.stopPropagation();
    updateValidity();
  }, [updateValidity]);
  useEffect(function () {
    addField(id, options);
  }, []);
  useFieldValidation({
    fields: fields,
    type: type,
    value: value,
    initialValue: initialValue,
    isValidatedOnce: isValidatedOnce,
    isValid: isValid,
    isFormValid: isFormValid,
    updateValidity: updateValidity,
    setIsFormValid: setIsFormValid
  });

  if (typeof value === 'undefined') {
    return null;
  }

  return /*#__PURE__*/React__default.createElement(FieldContext.Provider, {
    value: {
      field: field,
      updateValue: updateValue,
      onUpdateValidity: onUpdateValidity
    }
  }, /*#__PURE__*/React__default.createElement("div", {
    className: fieldClassNames.root,
    onBlur: onUpdateValidity
  }, /*#__PURE__*/React__default.createElement("div", {
    className: fieldClassNames.labelWrapper
  }, label && type !== checkbox$2 && /*#__PURE__*/React__default.createElement("label", {
    htmlFor: uid
  }, label), required && /*#__PURE__*/React__default.createElement("div", {
    className: fieldClassNames.requiredAsterisk
  }, "*")), children, !isValid && /*#__PURE__*/React__default.createElement("div", {
    className: fieldClassNames.invalidMessage
  }, invalidMessage)));
}

Field.propTypes = {
  id: PropTypes.string.isRequired,
  options: PropTypes.shape({
    type: PropTypes.oneOf([checkbox$2, select$3, textarea$2]).isRequired,
    label: PropTypes.string,
    required: PropTypes.bool
  }).isRequired,
  children: PropTypes.node.isRequired
};

var checkbox$3 = fieldTypes.checkbox;

function Checkbox$1() {
  var _useFieldContext = useFieldContext(),
      field = _useFieldContext.field,
      updateValue = _useFieldContext.updateValue;

  var label = field.label,
      value = field.value;
  return /*#__PURE__*/React__default.createElement(Checkbox, {
    checked: value,
    onChange: updateValue
  }, label);
}

function FeedbackCheckbox(_ref) {
  var id = _ref.id,
      label = _ref.label;
  var options = {
    type: checkbox$3,
    label: label
  };
  return /*#__PURE__*/React__default.createElement(Field, {
    id: id,
    options: options
  }, /*#__PURE__*/React__default.createElement(Checkbox$1, null));
}

FeedbackCheckbox.propTypes = {
  id: PropTypes.string.isRequired,
  label: PropTypes.string.isRequired
};
var feedbackCheckbox = /*#__PURE__*/memo(FeedbackCheckbox);

function t(t){return "object"==typeof t&&null!=t&&1===t.nodeType}function e(t,e){return (!e||"hidden"!==t)&&"visible"!==t&&"clip"!==t}function n(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var r=getComputedStyle(t,null);return e(r.overflowY,n)||e(r.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return !!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return !1}function r(t,e,n,r,i,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-r:l>e&&d<n||o<t&&d>n?l-e+i:0}function computeScrollIntoView(e,i){var o=window,l=i.scrollMode,d=i.block,u=i.inline,h=i.boundary,a=i.skipOverflowHiddenElements,c="function"==typeof h?h:function(t){return t!==h};if(!t(e))throw new TypeError("Invalid target");for(var f=document.scrollingElement||document.documentElement,s=[],p=e;t(p)&&c(p);){if((p=p.parentElement)===f){s.push(p);break}null!=p&&p===document.body&&n(p)&&!n(document.documentElement)||null!=p&&n(p,a)&&s.push(p);}for(var m=o.visualViewport?o.visualViewport.width:innerWidth,g=o.visualViewport?o.visualViewport.height:innerHeight,w=window.scrollX||pageXOffset,v=window.scrollY||pageYOffset,W=e.getBoundingClientRect(),b=W.height,H=W.width,y=W.top,E=W.right,M=W.bottom,V=W.left,x="start"===d||"nearest"===d?y:"end"===d?M:y+b/2,I="center"===u?V+H/2:"end"===u?E:V,C=[],T=0;T<s.length;T++){var k=s[T],B=k.getBoundingClientRect(),D=B.height,O=B.width,R=B.top,X=B.right,Y=B.bottom,L=B.left;if("if-needed"===l&&y>=0&&V>=0&&M<=g&&E<=m&&y>=R&&M<=Y&&V>=L&&E<=X)return C;var S=getComputedStyle(k),j=parseInt(S.borderLeftWidth,10),q=parseInt(S.borderTopWidth,10),z=parseInt(S.borderRightWidth,10),A=parseInt(S.borderBottomWidth,10),F=0,G=0,J="offsetWidth"in k?k.offsetWidth-k.clientWidth-j-z:0,K="offsetHeight"in k?k.offsetHeight-k.clientHeight-q-A:0;if(f===k)F="start"===d?x:"end"===d?x-g:"nearest"===d?r(v,v+g,g,q,A,v+x,v+x+b,b):x-g/2,G="start"===u?I:"center"===u?I-m/2:"end"===u?I-m:r(w,w+m,m,j,z,w+I,w+I+H,H),F=Math.max(0,F+v),G=Math.max(0,G+w);else {F="start"===d?x-R-q:"end"===d?x-Y+A+K:"nearest"===d?r(R,Y,D,q,A+K,x,x+b,b):x-(R+D/2)+K/2,G="start"===u?I-L-j:"center"===u?I-(L+O/2)+J/2:"end"===u?I-X+z+J:r(L,X,O,j,z+J,I,I+H,H);var N=k.scrollLeft,P=k.scrollTop;x+=P-(F=Math.max(0,Math.min(P+F,k.scrollHeight-D+K))),I+=N-(G=Math.max(0,Math.min(N+G,k.scrollWidth-O+J)));}C.push({el:k,top:F,left:G});}return C}

function _extends$3() {
  _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$3.apply(this, arguments);
}

function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized$2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

// istanbul ignore next
var statusDiv = typeof document === 'undefined' ? null : document.getElementById('a11y-status-message');
var statuses = [];
/**
 * @param {String} status the status message
 */

function setStatus(status) {
  var isSameAsLast = statuses[statuses.length - 1] === status;

  if (isSameAsLast) {
    statuses = statuses.concat([status]);
  } else {
    statuses = [status];
  }

  var div = getStatusDiv(); // Remove previous children

  while (div.lastChild) {
    div.removeChild(div.firstChild);
  }

  statuses.filter(Boolean).forEach(function (statusItem, index) {
    div.appendChild(getStatusChildDiv(statusItem, index));
  });
}
/**
 * @param {String} status the status message
 * @param {Number} index the index
 * @return {HTMLElement} the child node
 */


function getStatusChildDiv(status, index) {
  var display = index === statuses.length - 1 ? 'block' : 'none';
  var childDiv = document.createElement('div');
  childDiv.style.display = display;
  childDiv.textContent = status;
  return childDiv;
}
/**
 * Get the status node or create it if it does not already exist
 * @return {HTMLElement} the status node
 */


function getStatusDiv() {
  if (statusDiv) {
    return statusDiv;
  }

  statusDiv = document.createElement('div');
  statusDiv.setAttribute('id', 'a11y-status-message');
  statusDiv.setAttribute('role', 'status');
  statusDiv.setAttribute('aria-live', 'assertive');
  statusDiv.setAttribute('aria-relevant', 'additions text');
  Object.assign(statusDiv.style, {
    border: '0',
    clip: 'rect(0 0 0 0)',
    height: '1px',
    margin: '-1px',
    overflow: 'hidden',
    padding: '0',
    position: 'absolute',
    width: '1px'
  });
  document.body.appendChild(statusDiv);
  return statusDiv;
}

var unknown =  '__autocomplete_unknown__' ;
var mouseUp =  '__autocomplete_mouseup__' ;
var itemMouseEnter =  '__autocomplete_item_mouseenter__' ;
var keyDownArrowUp =  '__autocomplete_keydown_arrow_up__' ;
var keyDownArrowDown =  '__autocomplete_keydown_arrow_down__' ;
var keyDownEscape =  '__autocomplete_keydown_escape__' ;
var keyDownEnter =  '__autocomplete_keydown_enter__' ;
var clickItem =  '__autocomplete_click_item__' ;
var blurInput =  '__autocomplete_blur_input__' ;
var changeInput =  '__autocomplete_change_input__' ;
var keyDownSpaceButton =  '__autocomplete_keydown_space_button__' ;
var clickButton =  '__autocomplete_click_button__' ;
var blurButton =  '__autocomplete_blur_button__' ;
var controlledPropUpdatedSelectedItem =  '__autocomplete_controlled_prop_updated_selected_item__' ;
var touchStart =  '__autocomplete_touchstart__' ;

var stateChangeTypes = /*#__PURE__*/Object.freeze({
  unknown: unknown,
  mouseUp: mouseUp,
  itemMouseEnter: itemMouseEnter,
  keyDownArrowUp: keyDownArrowUp,
  keyDownArrowDown: keyDownArrowDown,
  keyDownEscape: keyDownEscape,
  keyDownEnter: keyDownEnter,
  clickItem: clickItem,
  blurInput: blurInput,
  changeInput: changeInput,
  keyDownSpaceButton: keyDownSpaceButton,
  clickButton: clickButton,
  blurButton: blurButton,
  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,
  touchStart: touchStart
});

var idCounter = 0;
/**
 * Accepts a parameter and returns it if it's a function
 * or a noop function if it's not. This allows us to
 * accept a callback, but not worry about it if it's not
 * passed.
 * @param {Function} cb the callback
 * @return {Function} a function
 */

function cbToCb(cb) {
  return typeof cb === 'function' ? cb : noop;
}

function noop() {}
/**
 * Scroll node into view if necessary
 * @param {HTMLElement} node the element that should scroll into view
 * @param {HTMLElement} rootNode the root element of the component
 */


function scrollIntoView(node, rootNode) {
  if (node === null) {
    return;
  }

  var actions = computeScrollIntoView(node, {
    boundary: rootNode,
    block: 'nearest',
    scrollMode: 'if-needed'
  });
  actions.forEach(function (_ref) {
    var el = _ref.el,
        top = _ref.top,
        left = _ref.left;
    el.scrollTop = top;
    el.scrollLeft = left;
  });
}
/**
 * @param {HTMLElement} parent the parent node
 * @param {HTMLElement} child the child node
 * @return {Boolean} whether the parent is the child or the child is in the parent
 */


function isOrContainsNode(parent, child) {
  return parent === child || parent.contains && parent.contains(child);
}
/**
 * Simple debounce implementation. Will call the given
 * function once after the time given has passed since
 * it was last called.
 * @param {Function} fn the function to call after the time
 * @param {Number} time the time to wait
 * @return {Function} the debounced function
 */


function debounce$2(fn, time) {
  var timeoutId;

  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }

  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    cancel();
    timeoutId = setTimeout(function () {
      timeoutId = null;
      fn.apply(void 0, args);
    }, time);
  }

  wrapper.cancel = cancel;
  return wrapper;
}
/**
 * This is intended to be used to compose event handlers.
 * They are executed in order until one of them sets
 * `event.preventDownshiftDefault = true`.
 * @param {...Function} fns the event handler functions
 * @return {Function} the event handler to add to an element
 */


function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }

  return function (event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    return fns.some(function (fn) {
      if (fn) {
        fn.apply(void 0, [event].concat(args));
      }

      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
/**
 * This return a function that will call all the given functions with
 * the arguments with which it's called. It does a null-check before
 * attempting to call the functions and can take any number of functions.
 * @param {...Function} fns the functions to call
 * @return {Function} the function that calls all the functions
 */


function callAll() {
  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    fns[_key4] = arguments[_key4];
  }

  return function () {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    fns.forEach(function (fn) {
      if (fn) {
        fn.apply(void 0, args);
      }
    });
  };
}
/**
 * This generates a unique ID for an instance of Downshift
 * @return {String} the unique ID
 */


function generateId() {
  return String(idCounter++);
}
/**
 * @param {Object} param the downshift state and other relevant properties
 * @return {String} the a11y status message
 */


function getA11yStatusMessage(_ref2) {
  var isOpen = _ref2.isOpen,
      highlightedItem = _ref2.highlightedItem,
      selectedItem = _ref2.selectedItem,
      resultCount = _ref2.resultCount,
      previousResultCount = _ref2.previousResultCount,
      itemToString = _ref2.itemToString;

  if (!isOpen) {
    if (selectedItem) {
      return itemToString(selectedItem);
    } else {
      return '';
    }
  }

  if (!resultCount) {
    return 'No results.';
  } else if (!highlightedItem || resultCount !== previousResultCount) {
    return resultCount + " " + (resultCount === 1 ? 'result is' : 'results are') + " available, use up and down arrow keys to navigate.";
  }

  return itemToString(highlightedItem);
}
/**
 * Takes an argument and if it's an array, returns the first item in the array
 * otherwise returns the argument
 * @param {*} arg the maybe-array
 * @param {*} defaultValue the value if arg is falsey not defined
 * @return {*} the arg or it's first item
 */


function unwrapArray$1(arg, defaultValue) {
  arg = Array.isArray(arg) ?
  /* istanbul ignore next (preact) */
  arg[0] : arg;

  if (!arg && defaultValue) {
    return defaultValue;
  } else {
    return arg;
  }
}
/**
 * @param {Object} element (P)react element
 * @return {Boolean} whether it's a DOM element
 */


function isDOMElement(element) {
  // then we assume this is react
  return typeof element.type === 'string';
}
/**
 * @param {Object} element (P)react element
 * @return {Object} the props
 */


function getElementProps(element) {
  return element.props;
}
/**
 * Throws a helpful error message for required properties. Useful
 * to be used as a default in destructuring or object params.
 * @param {String} fnName the function name
 * @param {String} propName the prop name
 */


function requiredProp(fnName, propName) {
  // eslint-disable-next-line no-console
  console.error("The property \"" + propName + "\" is required in \"" + fnName + "\"");
}

var stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];
/**
 * @param {Object} state the state object
 * @return {Object} state that is relevant to downshift
 */

function pickState(state) {
  if (state === void 0) {
    state = {};
  }

  var result = {};
  stateKeys.forEach(function (k) {
    if (state.hasOwnProperty(k)) {
      result[k] = state[k];
    }
  });
  return result;
}
/**
 * Normalizes the 'key' property of a KeyboardEvent in IE/Edge
 * @param {Object} event a keyboardEvent object
 * @return {String} keyboard key
 */


function normalizeArrowKey(event) {
  var key = event.key,
      keyCode = event.keyCode;
  /* istanbul ignore next (ie) */

  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {
    return "Arrow" + key;
  }

  return key;
}
/**
 * Simple check if the value passed is object literal
 * @param {*} obj any things
 * @return {Boolean} whether it's object literal
 */


function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}

var Downshift =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose$1(Downshift, _Component);

  function Downshift(_props) {
    var _this = _Component.call(this, _props) || this;

    _this.id = _this.props.id || "downshift-" + generateId();
    _this.menuId = _this.props.menuId || _this.id + "-menu";
    _this.labelId = _this.props.labelId || _this.id + "-label";
    _this.inputId = _this.props.inputId || _this.id + "-input";

    _this.getItemId = _this.props.getItemId || function (index) {
      return _this.id + "-item-" + index;
    };

    _this.input = null;
    _this.items = [];
    _this.itemCount = null;
    _this.previousResultCount = 0;
    _this.timeoutIds = [];

    _this.internalSetTimeout = function (fn, time) {
      var id = setTimeout(function () {
        _this.timeoutIds = _this.timeoutIds.filter(function (i) {
          return i !== id;
        });
        fn();
      }, time);

      _this.timeoutIds.push(id);
    };

    _this.setItemCount = function (count) {
      _this.itemCount = count;
    };

    _this.unsetItemCount = function () {
      _this.itemCount = null;
    };

    _this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {
      if (highlightedIndex === void 0) {
        highlightedIndex = _this.props.defaultHighlightedIndex;
      }

      if (otherStateToSet === void 0) {
        otherStateToSet = {};
      }

      otherStateToSet = pickState(otherStateToSet);

      _this.internalSetState(_extends$3({
        highlightedIndex: highlightedIndex
      }, otherStateToSet));
    };

    _this.clearSelection = function (cb) {
      _this.internalSetState({
        selectedItem: null,
        inputValue: '',
        isOpen: false
      }, cb);
    };

    _this.selectItem = function (item, otherStateToSet, cb) {
      otherStateToSet = pickState(otherStateToSet);

      _this.internalSetState(_extends$3({
        isOpen: false,
        highlightedIndex: _this.props.defaultHighlightedIndex,
        selectedItem: item,
        inputValue: _this.isControlledProp('selectedItem') ? _this.props.defaultInputValue : _this.props.itemToString(item)
      }, otherStateToSet), cb);
    };

    _this.selectItemAtIndex = function (itemIndex, otherStateToSet, cb) {
      var item = _this.items[itemIndex];

      if (item == null) {
        return;
      }

      _this.selectItem(item, otherStateToSet, cb);
    };

    _this.selectHighlightedItem = function (otherStateToSet, cb) {
      return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
    };

    _this.internalSetState = function (stateToSet, cb) {
      var isItemSelected, onChangeArg;
      var onStateChangeArg = {};
      var isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call
      // so someone controlling the `inputValue` state gets notified of
      // the input change as soon as possible. This avoids issues with
      // preserving the cursor position.
      // See https://github.com/paypal/downshift/issues/217 for more info.

      if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {
        _this.props.onInputValueChange(stateToSet.inputValue, _extends$3({}, _this.getStateAndHelpers(), stateToSet));
      }

      return _this.setState(function (state) {
        state = _this.getState(state);
        var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.

        newStateToSet = _this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from
        // what was selected before
        // used to determine if onSelect and onChange callbacks should be called

        isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState

        var nextState = {}; // this is just used to tell whether the state changed

        var nextFullState = {}; // we need to call on change if the outside world is controlling any of our state
        // and we're trying to update that state. OR if the selection has changed and we're
        // trying to update the selection

        if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
          onChangeArg = newStateToSet.selectedItem;
        }

        newStateToSet.type = newStateToSet.type || unknown;
        Object.keys(newStateToSet).forEach(function (key) {
          // onStateChangeArg should only have the state that is
          // actually changing
          if (state[key] !== newStateToSet[key]) {
            onStateChangeArg[key] = newStateToSet[key];
          } // the type is useful for the onStateChangeArg
          // but we don't actually want to set it in internal state.
          // this is an undocumented feature for now... Not all internalSetState
          // calls support it and I'm not certain we want them to yet.
          // But it enables users controlling the isOpen state to know when
          // the isOpen state changes due to mouseup events which is quite handy.


          if (key === 'type') {
            return;
          }

          nextFullState[key] = newStateToSet[key]; // if it's coming from props, then we don't care to set it internally

          if (!_this.isControlledProp(key)) {
            nextState[key] = newStateToSet[key];
          }
        }); // if stateToSet is a function, then we weren't able to call onInputValueChange
        // earlier, so we'll call it now that we know what the inputValue state will be.

        if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {
          _this.props.onInputValueChange(newStateToSet.inputValue, _extends$3({}, _this.getStateAndHelpers(), newStateToSet));
        }

        return nextState;
      }, function () {
        // call the provided callback if it's a function
        cbToCb(cb)(); // only call the onStateChange and onChange callbacks if
        // we have relevant information to pass them.

        var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;

        if (hasMoreStateThanType) {
          _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
        }

        if (isItemSelected) {
          _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
        }

        if (onChangeArg !== undefined) {
          _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
        } // this is currently undocumented and therefore subject to change
        // We'll try to not break it, but just be warned.


        _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
      });
    };

    _this.rootRef = function (node) {
      return _this._rootNode = node;
    };

    _this.getRootProps = function (_temp, _temp2) {
      var _extends2;

      var _ref = _temp === void 0 ? {} : _temp,
          _ref$refKey = _ref.refKey,
          refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,
          rest = _objectWithoutPropertiesLoose$2(_ref, ["refKey"]);

      var _ref2 = _temp2 === void 0 ? {} : _temp2,
          _ref2$suppressRefErro = _ref2.suppressRefError,
          suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;

      // this is used in the render to know whether the user has called getRootProps.
      // It uses that to know whether to apply the props automatically
      _this.getRootProps.called = true;
      _this.getRootProps.refKey = refKey;
      _this.getRootProps.suppressRefError = suppressRefError;

      var _this$getState = _this.getState(),
          isOpen = _this$getState.isOpen;

      return _extends$3((_extends2 = {}, _extends2[refKey] = _this.rootRef, _extends2.role = 'combobox', _extends2['aria-expanded'] = isOpen, _extends2['aria-haspopup'] = 'listbox', _extends2['aria-owns'] = isOpen ? _this.menuId : null, _extends2['aria-labelledby'] = _this.labelId, _extends2), rest);
    };

    _this.keyDownHandlers = {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        var amount = event.shiftKey ? 5 : 1;
        this.moveHighlightedIndex(amount, {
          type: keyDownArrowDown
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        var amount = event.shiftKey ? -5 : -1;
        this.moveHighlightedIndex(amount, {
          type: keyDownArrowUp
        });
      },
      Enter: function Enter(event) {
        var _this$getState2 = this.getState(),
            isOpen = _this$getState2.isOpen,
            highlightedIndex = _this$getState2.highlightedIndex;

        if (isOpen && highlightedIndex != null) {
          event.preventDefault();
          var item = this.items[highlightedIndex];
          var itemNode = this.getItemNodeFromIndex(highlightedIndex);

          if (item == null || itemNode && itemNode.hasAttribute('disabled')) {
            return;
          }

          this.selectHighlightedItem({
            type: keyDownEnter
          });
        }
      },
      Escape: function Escape(event) {
        event.preventDefault();
        this.reset({
          type: keyDownEscape
        });
      }
    };
    _this.buttonKeyDownHandlers = _extends$3({}, _this.keyDownHandlers, {
      ' ': function _(event) {
        event.preventDefault();
        this.toggleMenu({
          type: keyDownSpaceButton
        });
      }
    });

    _this.getToggleButtonProps = function (_temp3) {
      var _ref3 = _temp3 === void 0 ? {} : _temp3,
          onClick = _ref3.onClick,
          onPress = _ref3.onPress,
          onKeyDown = _ref3.onKeyDown,
          onKeyUp = _ref3.onKeyUp,
          onBlur = _ref3.onBlur,
          rest = _objectWithoutPropertiesLoose$2(_ref3, ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"]);

      var _this$getState3 = _this.getState(),
          isOpen = _this$getState3.isOpen;

      var enabledEventHandlers = {
        onClick: callAllEventHandlers(onClick, _this.button_handleClick),
        onKeyDown: callAllEventHandlers(onKeyDown, _this.button_handleKeyDown),
        onKeyUp: callAllEventHandlers(onKeyUp, _this.button_handleKeyUp),
        onBlur: callAllEventHandlers(onBlur, _this.button_handleBlur)
      };
      var eventHandlers = rest.disabled ? {} : enabledEventHandlers;
      return _extends$3({
        type: 'button',
        role: 'button',
        'aria-label': isOpen ? 'close menu' : 'open menu',
        'aria-haspopup': true,
        'data-toggle': true
      }, eventHandlers, rest);
    };

    _this.button_handleKeyUp = function (event) {
      // Prevent click event from emitting in Firefox
      event.preventDefault();
    };

    _this.button_handleKeyDown = function (event) {
      var key = normalizeArrowKey(event);

      if (_this.buttonKeyDownHandlers[key]) {
        _this.buttonKeyDownHandlers[key].call(_assertThisInitialized$2(_assertThisInitialized$2(_this)), event);
      }
    };

    _this.button_handleClick = function (event) {
      event.preventDefault(); // handle odd case for Safari and Firefox which
      // don't give the button the focus properly.

      /* istanbul ignore if (can't reasonably test this) */

      if (_this.props.environment.document.activeElement === _this.props.environment.document.body) {
        event.target.focus();
      } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout
      // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated
      // when building for production and should therefore have no impact on production code.


      {
        // Ensure that toggle of menu occurs after the potential blur event in iOS
        _this.internalSetTimeout(function () {
          return _this.toggleMenu({
            type: clickButton
          });
        });
      }
    };

    _this.button_handleBlur = function (event) {
      var blurTarget = event.target; // Save blur target for comparison with activeElement later
      // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element

      _this.internalSetTimeout(function () {
        if (!_this.isMouseDown && (_this.props.environment.document.activeElement == null || _this.props.environment.document.activeElement.id !== _this.inputId) && _this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)
        ) {
            _this.reset({
              type: blurButton
            });
          }
      });
    };

    _this.getLabelProps = function (props) {
      return _extends$3({
        htmlFor: _this.inputId,
        id: _this.labelId
      }, props);
    };

    _this.getInputProps = function (_temp4) {
      var _ref4 = _temp4 === void 0 ? {} : _temp4,
          onKeyDown = _ref4.onKeyDown,
          onBlur = _ref4.onBlur,
          onChange = _ref4.onChange,
          onInput = _ref4.onInput,
          onChangeText = _ref4.onChangeText,
          rest = _objectWithoutPropertiesLoose$2(_ref4, ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"]);

      var onChangeKey;
      var eventHandlers = {};
      /* istanbul ignore next (preact) */

      onChangeKey = 'onChange';

      var _this$getState4 = _this.getState(),
          inputValue = _this$getState4.inputValue,
          isOpen = _this$getState4.isOpen,
          highlightedIndex = _this$getState4.highlightedIndex;

      if (!rest.disabled) {
        var _eventHandlers;

        eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.input_handleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.input_handleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.input_handleBlur), _eventHandlers);
      }
      /* istanbul ignore if (react-native) */


      return _extends$3({
        'aria-autocomplete': 'list',
        'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,
        'aria-controls': isOpen ? _this.menuId : null,
        'aria-labelledby': _this.labelId,
        // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
        // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
        autoComplete: 'off',
        value: inputValue,
        id: _this.inputId
      }, eventHandlers, rest);
    };

    _this.input_handleKeyDown = function (event) {
      var key = normalizeArrowKey(event);

      if (key && _this.keyDownHandlers[key]) {
        _this.keyDownHandlers[key].call(_assertThisInitialized$2(_assertThisInitialized$2(_this)), event);
      }
    };

    _this.input_handleChange = function (event) {
      _this.internalSetState({
        type: changeInput,
        isOpen: true,
        inputValue: event.target.value
      });
    };

    _this.input_handleTextChange
    /* istanbul ignore next (react-native) */
    = function (text) {
      _this.internalSetState({
        type: changeInput,
        isOpen: true,
        inputValue: text
      });
    };

    _this.input_handleBlur = function () {
      // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element
      _this.internalSetTimeout(function () {
        var downshiftButtonIsActive = _this.props.environment.document && _this.props.environment.document.activeElement.dataset.toggle && _this._rootNode && _this._rootNode.contains(_this.props.environment.document.activeElement);

        if (!_this.isMouseDown && !downshiftButtonIsActive) {
          _this.reset({
            type: blurInput
          });
        }
      });
    };

    _this.menuRef = function (node) {
      _this._menuNode = node;
    };

    _this.getMenuProps = function (_temp5, _temp6) {
      var _extends3;

      var _ref5 = _temp5 === void 0 ? {} : _temp5,
          _ref5$refKey = _ref5.refKey,
          refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,
          ref = _ref5.ref,
          props = _objectWithoutPropertiesLoose$2(_ref5, ["refKey", "ref"]);

      var _ref6 = _temp6 === void 0 ? {} : _temp6,
          _ref6$suppressRefErro = _ref6.suppressRefError,
          suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;

      _this.getMenuProps.called = true;
      _this.getMenuProps.refKey = refKey;
      _this.getMenuProps.suppressRefError = suppressRefError;
      return _extends$3((_extends3 = {}, _extends3[refKey] = callAll(ref, _this.menuRef), _extends3.role = 'listbox', _extends3['aria-labelledby'] = props && props['aria-label'] ? null : _this.labelId, _extends3.id = _this.menuId, _extends3), props);
    };

    _this.getItemProps = function (_temp7) {
      var _enabledEventHandlers;

      var _ref7 = _temp7 === void 0 ? {} : _temp7,
          onMouseMove = _ref7.onMouseMove,
          onMouseDown = _ref7.onMouseDown,
          onClick = _ref7.onClick,
          onPress = _ref7.onPress,
          index = _ref7.index,
          _ref7$item = _ref7.item,
          item = _ref7$item === void 0 ?  requiredProp('getItemProps', 'item') : _ref7$item,
          rest = _objectWithoutPropertiesLoose$2(_ref7, ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"]);

      if (index === undefined) {
        _this.items.push(item);

        index = _this.items.indexOf(item);
      } else {
        _this.items[index] = item;
      }

      var onSelectKey = 'onClick';
      var customClickHandler = onClick;
      var enabledEventHandlers = (_enabledEventHandlers = {
        // onMouseMove is used over onMouseEnter here. onMouseMove
        // is only triggered on actual mouse movement while onMouseEnter
        // can fire on DOM changes, interrupting keyboard navigation
        onMouseMove: callAllEventHandlers(onMouseMove, function () {
          if (index === _this.getState().highlightedIndex) {
            return;
          }

          _this.setHighlightedIndex(index, {
            type: itemMouseEnter
          }); // We never want to manually scroll when changing state based
          // on `onMouseMove` because we will be moving the element out
          // from under the user which is currently scrolling/moving the
          // cursor


          _this.avoidScrolling = true;

          _this.internalSetTimeout(function () {
            return _this.avoidScrolling = false;
          }, 250);
        }),
        onMouseDown: callAllEventHandlers(onMouseDown, function (event) {
          // This prevents the activeElement from being changed
          // to the item so it can remain with the current activeElement
          // which is a more common use case.
          event.preventDefault();
        })
      }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function () {
        _this.selectItemAtIndex(index, {
          type: clickItem
        });
      }), _enabledEventHandlers); // Passing down the onMouseDown handler to prevent redirect
      // of the activeElement if clicking on disabled items

      var eventHandlers = rest.disabled ? {
        onMouseDown: enabledEventHandlers.onMouseDown
      } : enabledEventHandlers;
      return _extends$3({
        id: _this.getItemId(index),
        role: 'option',
        'aria-selected': _this.getState().selectedItem === item
      }, eventHandlers, rest);
    };

    _this.clearItems = function () {
      _this.items = [];
    };

    _this.reset = function (otherStateToSet, cb) {
      if (otherStateToSet === void 0) {
        otherStateToSet = {};
      }

      otherStateToSet = pickState(otherStateToSet);

      _this.internalSetState(function (_ref8) {
        var selectedItem = _ref8.selectedItem;
        return _extends$3({
          isOpen: false,
          highlightedIndex: _this.props.defaultHighlightedIndex,
          inputValue: _this.props.itemToString(selectedItem)
        }, otherStateToSet);
      }, cb);
    };

    _this.toggleMenu = function (otherStateToSet, cb) {
      if (otherStateToSet === void 0) {
        otherStateToSet = {};
      }

      otherStateToSet = pickState(otherStateToSet);

      _this.internalSetState(function (_ref9) {
        var isOpen = _ref9.isOpen;
        return _extends$3({
          isOpen: !isOpen
        }, otherStateToSet);
      }, function () {
        var _this$getState5 = _this.getState(),
            isOpen = _this$getState5.isOpen;

        if (isOpen) {
          // highlight default index
          _this.setHighlightedIndex(undefined, otherStateToSet);
        }

        cbToCb(cb)();
      });
    };

    _this.openMenu = function (cb) {
      _this.internalSetState({
        isOpen: true
      }, cb);
    };

    _this.closeMenu = function (cb) {
      _this.internalSetState({
        isOpen: false
      }, cb);
    };

    _this.updateStatus = debounce$2(function () {
      var state = _this.getState();

      var item = _this.items[state.highlightedIndex];

      var resultCount = _this.getItemCount();

      var status = _this.props.getA11yStatusMessage(_extends$3({
        itemToString: _this.props.itemToString,
        previousResultCount: _this.previousResultCount,
        resultCount: resultCount,
        highlightedItem: item
      }, state));

      _this.previousResultCount = resultCount;
      setStatus(status);
    }, 200);

    var _state = _this.getState({
      highlightedIndex: _this.props.defaultHighlightedIndex,
      isOpen: _this.props.defaultIsOpen,
      inputValue: _this.props.defaultInputValue,
      selectedItem: _this.props.defaultSelectedItem
    });

    if (_state.selectedItem != null) {
      _state.inputValue = _this.props.itemToString(_state.selectedItem);
    }

    _this.state = _state;
    return _this;
  }

  var _proto = Downshift.prototype;

  /**
   * Clear all running timeouts
   */
  _proto.internalClearTimeouts = function internalClearTimeouts() {
    this.timeoutIds.forEach(function (id) {
      clearTimeout(id);
    });
    this.timeoutIds = [];
  };
  /**
   * Gets the state based on internal state or props
   * If a state value is passed via props, then that
   * is the value given, otherwise it's retrieved from
   * stateToMerge
   *
   * This will perform a shallow merge of the given state object
   * with the state coming from props
   * (for the controlled component scenario)
   * This is used in state updater functions so they're referencing
   * the right state regardless of where it comes from.
   *
   * @param {Object} stateToMerge defaults to this.state
   * @return {Object} the state
   */


  _proto.getState = function getState(stateToMerge) {
    var _this2 = this;

    if (stateToMerge === void 0) {
      stateToMerge = this.state;
    }

    return Object.keys(stateToMerge).reduce(function (state, key) {
      state[key] = _this2.isControlledProp(key) ? _this2.props[key] : stateToMerge[key];
      return state;
    }, {});
  };
  /**
   * This determines whether a prop is a "controlled prop" meaning it is
   * state which is controlled by the outside of this component rather
   * than within this component.
   * @param {String} key the key to check
   * @return {Boolean} whether it is a controlled controlled prop
   */


  _proto.isControlledProp = function isControlledProp(key) {
    return this.props[key] !== undefined;
  };

  _proto.getItemCount = function getItemCount() {
    // things read better this way. They're in priority order:
    // 1. `this.itemCount`
    // 2. `this.props.itemCount`
    // 3. `this.items.length`
    var itemCount = this.items.length;

    if (this.itemCount != null) {
      itemCount = this.itemCount;
    } else if (this.props.itemCount !== undefined) {
      itemCount = this.props.itemCount;
    }

    return itemCount;
  };

  _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index) {
    return this.props.environment.document.getElementById(this.getItemId(index));
  };

  _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
    /* istanbul ignore else (react-native) */
    {
      var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
      this.props.scrollIntoView(node, this._rootNode);
    }
  };

  _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
    if (this.getState().isOpen) {
      this.changeHighlightedIndex(amount, otherStateToSet);
    } else {
      this.setHighlightedIndex(undefined, _extends$3({
        isOpen: true
      }, otherStateToSet));
    }
  };

  _proto.changeHighlightedIndex = function changeHighlightedIndex(moveAmount, otherStateToSet) {
    var itemsLastIndex = this.getItemCount() - 1;

    if (itemsLastIndex < 0) {
      return;
    }

    var _this$getState6 = this.getState(),
        highlightedIndex = _this$getState6.highlightedIndex;

    var baseIndex = highlightedIndex;

    if (baseIndex === null) {
      baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
    }

    var newIndex = baseIndex + moveAmount;

    if (newIndex < 0) {
      newIndex = itemsLastIndex;
    } else if (newIndex > itemsLastIndex) {
      newIndex = 0;
    }

    this.setHighlightedIndex(newIndex, otherStateToSet);
  };

  _proto.getStateAndHelpers = function getStateAndHelpers() {
    var _this$getState7 = this.getState(),
        highlightedIndex = _this$getState7.highlightedIndex,
        inputValue = _this$getState7.inputValue,
        selectedItem = _this$getState7.selectedItem,
        isOpen = _this$getState7.isOpen;

    var itemToString = this.props.itemToString;
    var id = this.id;
    var getRootProps = this.getRootProps,
        getToggleButtonProps = this.getToggleButtonProps,
        getLabelProps = this.getLabelProps,
        getMenuProps = this.getMenuProps,
        getInputProps = this.getInputProps,
        getItemProps = this.getItemProps,
        openMenu = this.openMenu,
        closeMenu = this.closeMenu,
        toggleMenu = this.toggleMenu,
        selectItem = this.selectItem,
        selectItemAtIndex = this.selectItemAtIndex,
        selectHighlightedItem = this.selectHighlightedItem,
        setHighlightedIndex = this.setHighlightedIndex,
        clearSelection = this.clearSelection,
        clearItems = this.clearItems,
        reset = this.reset,
        setItemCount = this.setItemCount,
        unsetItemCount = this.unsetItemCount,
        setState = this.internalSetState;
    return {
      // prop getters
      getRootProps: getRootProps,
      getToggleButtonProps: getToggleButtonProps,
      getLabelProps: getLabelProps,
      getMenuProps: getMenuProps,
      getInputProps: getInputProps,
      getItemProps: getItemProps,
      // actions
      reset: reset,
      openMenu: openMenu,
      closeMenu: closeMenu,
      toggleMenu: toggleMenu,
      selectItem: selectItem,
      selectItemAtIndex: selectItemAtIndex,
      selectHighlightedItem: selectHighlightedItem,
      setHighlightedIndex: setHighlightedIndex,
      clearSelection: clearSelection,
      clearItems: clearItems,
      setItemCount: setItemCount,
      unsetItemCount: unsetItemCount,
      setState: setState,
      // props
      itemToString: itemToString,
      // derived
      id: id,
      // state
      highlightedIndex: highlightedIndex,
      inputValue: inputValue,
      isOpen: isOpen,
      selectedItem: selectedItem
    };
  }; //////////////////////////// ROOT


  _proto.componentDidMount = function componentDidMount() {
    var _this3 = this;

    /* istanbul ignore if (react-native) */
    if ( this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
      validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
    }
    /* istanbul ignore if (react-native) */


    {
      var targetWithinDownshift = function (target, checkActiveElement) {
        if (checkActiveElement === void 0) {
          checkActiveElement = true;
        }

        var document = _this3.props.environment.document;
        return [_this3._rootNode, _this3._menuNode].some(function (contextNode) {
          return contextNode && (isOrContainsNode(contextNode, target) || checkActiveElement && isOrContainsNode(contextNode, document.activeElement));
        });
      }; // this.isMouseDown helps us track whether the mouse is currently held down.
      // This is useful when the user clicks on an item in the list, but holds the mouse
      // down long enough for the list to disappear (because the blur event fires on the input)
      // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should
      // trigger hiding the menu.


      var onMouseDown = function () {
        _this3.isMouseDown = true;
      };

      var onMouseUp = function (event) {
        _this3.isMouseDown = false; // if the target element or the activeElement is within a downshift node
        // then we don't want to reset downshift

        var contextWithinDownshift = targetWithinDownshift(event.target);

        if (!contextWithinDownshift && _this3.getState().isOpen) {
          _this3.reset({
            type: mouseUp
          }, function () {
            return _this3.props.onOuterClick(_this3.getStateAndHelpers());
          });
        }
      }; // Touching an element in iOS gives focus and hover states, but touching out of
      // the element will remove hover, and persist the focus state, resulting in the
      // blur event not being triggered.


      var onTouchStart = function (event) {
        var contextWithinDownshift = targetWithinDownshift(event.target, false);

        if (!contextWithinDownshift && _this3.getState().isOpen) {
          _this3.reset({
            type: touchStart
          }, function () {
            return _this3.props.onOuterClick(_this3.getStateAndHelpers());
          });
        }
      };

      this.props.environment.addEventListener('mousedown', onMouseDown);
      this.props.environment.addEventListener('mouseup', onMouseUp);
      this.props.environment.addEventListener('touchstart', onTouchStart);

      this.cleanup = function () {
        _this3.internalClearTimeouts();

        _this3.updateStatus.cancel();

        _this3.props.environment.removeEventListener('mousedown', onMouseDown);

        _this3.props.environment.removeEventListener('mouseup', onMouseUp);

        _this3.props.environment.removeEventListener('touchstart', onTouchStart);
      };
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    {
      validateControlledUnchanged(prevProps, this.props);
      /* istanbul ignore if (react-native) */

      if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
      }
    }

    if (this.isControlledProp('selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
      this.internalSetState({
        type: controlledPropUpdatedSelectedItem,
        inputValue: this.props.itemToString(this.props.selectedItem)
      });
    }

    var current = this.props.highlightedIndex === undefined ? this.state : this.props;
    var prev = prevProps.highlightedIndex === undefined ? prevState : prevProps;

    if (current.highlightedIndex !== prev.highlightedIndex && !this.avoidScrolling) {
      this.scrollHighlightedItemIntoView();
    }
    /* istanbul ignore else (react-native) */


    this.updateStatus();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cleanup(); // avoids memory leak
  };

  _proto.render = function render() {
    var children = unwrapArray$1(this.props.children, noop); // because the items are rerendered every time we call the children
    // we clear this out each render and it will be populated again as
    // getItemProps is called.

    this.clearItems(); // we reset this so we know whether the user calls getRootProps during
    // this render. If they do then we don't need to do anything,
    // if they don't then we need to clone the element they return and
    // apply the props for them.

    this.getRootProps.called = false;
    this.getRootProps.refKey = undefined;
    this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps

    this.getMenuProps.called = false;
    this.getMenuProps.refKey = undefined;
    this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps

    this.getLabelProps.called = false; // and something similar for getInputProps

    this.getInputProps.called = false;
    var element = unwrapArray$1(children(this.getStateAndHelpers()));

    if (!element) {
      return null;
    }

    if (this.getRootProps.called || this.props.suppressRefError) {
      if ( !this.getRootProps.suppressRefError && !this.props.suppressRefError) {
        validateGetRootPropsCalledCorrectly(element, this.getRootProps);
      }

      return element;
    } else if (isDOMElement(element)) {
      // they didn't apply the root props, but we can clone
      // this and apply the props ourselves
      return React__default.cloneElement(element, this.getRootProps(getElementProps(element)));
    }
    /* istanbul ignore else */


    {
      // they didn't apply the root props, but they need to
      // otherwise we can't query around the autocomplete
      throw new Error('downshift: If you return a non-DOM element, you must use apply the getRootProps function');
    }
  };

  return Downshift;
}(Component);

Downshift.defaultProps = {
  defaultHighlightedIndex: null,
  defaultSelectedItem: null,
  defaultInputValue: '',
  defaultIsOpen: false,
  getA11yStatusMessage: getA11yStatusMessage,
  itemToString: function itemToString(i) {
    if (i == null) {
      return '';
    }

    if ( isPlainObject(i) && !i.hasOwnProperty('toString')) {
      // eslint-disable-next-line no-console
      console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);
    }

    return String(i);
  },
  onStateChange: noop,
  onInputValueChange: noop,
  onUserAction: noop,
  onChange: noop,
  onSelect: noop,
  onOuterClick: noop,
  selectedItemChanged: function selectedItemChanged(prevItem, item) {
    return prevItem !== item;
  },
  environment: typeof window === 'undefined'
  /* istanbul ignore next (ssr) */
  ? {} : window,
  stateReducer: function stateReducer(state, stateToSet) {
    return stateToSet;
  },
  suppressRefError: false,
  scrollIntoView: scrollIntoView
};
Downshift.stateChangeTypes = stateChangeTypes;
 Downshift.propTypes = {
  children: PropTypes.func,
  defaultHighlightedIndex: PropTypes.number,
  defaultSelectedItem: PropTypes.any,
  defaultInputValue: PropTypes.string,
  defaultIsOpen: PropTypes.bool,
  getA11yStatusMessage: PropTypes.func,
  itemToString: PropTypes.func,
  onChange: PropTypes.func,
  onSelect: PropTypes.func,
  onStateChange: PropTypes.func,
  onInputValueChange: PropTypes.func,
  onUserAction: PropTypes.func,
  onOuterClick: PropTypes.func,
  selectedItemChanged: PropTypes.func,
  stateReducer: PropTypes.func,
  itemCount: PropTypes.number,
  id: PropTypes.string,
  environment: PropTypes.shape({
    addEventListener: PropTypes.func,
    removeEventListener: PropTypes.func,
    document: PropTypes.shape({
      getElementById: PropTypes.func,
      activeElement: PropTypes.any,
      body: PropTypes.any
    })
  }),
  suppressRefError: PropTypes.bool,
  scrollIntoView: PropTypes.func,
  // things we keep in state for uncontrolled components
  // but can accept as props for controlled components

  /* eslint-disable react/no-unused-prop-types */
  selectedItem: PropTypes.any,
  isOpen: PropTypes.bool,
  inputValue: PropTypes.string,
  highlightedIndex: PropTypes.number,
  labelId: PropTypes.string,
  inputId: PropTypes.string,
  menuId: PropTypes.string,
  getItemId: PropTypes.func
  /* eslint-enable react/no-unused-prop-types */

} ;

function validateGetMenuPropsCalledCorrectly(node, _ref10) {
  var refKey = _ref10.refKey;

  if (!node) {
    // eslint-disable-next-line no-console
    console.error("downshift: The ref prop \"" + refKey + "\" from getMenuProps was not applied correctly on your menu element.");
  }
}

function validateGetRootPropsCalledCorrectly(element, _ref11) {
  var refKey = _ref11.refKey;
  var refKeySpecified = refKey !== 'ref';
  var isComposite = !isDOMElement(element);

  if (isComposite && !refKeySpecified) {
    // eslint-disable-next-line no-console
    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');
  } else if (!isComposite && refKeySpecified) {
    // eslint-disable-next-line no-console
    console.error("downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"" + refKey + "\"");
  }

  if (!getElementProps(element)[refKey]) {
    // eslint-disable-next-line no-console
    console.error("downshift: You must apply the ref prop \"" + refKey + "\" from getRootProps onto your root element.");
  }
}

function validateControlledUnchanged(prevProps, nextProps) {
  var warningDescription = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/paypal/downshift#control-props";
  ['selectedItem', 'isOpen', 'inputValue', 'highlightedIndex'].forEach(function (propKey) {
    if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {
      // eslint-disable-next-line no-console
      console.error("downshift: A component has changed the controlled prop \"" + propKey + "\" to be uncontrolled. " + warningDescription);
    } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {
      // eslint-disable-next-line no-console
      console.error("downshift: A component has changed the uncontrolled prop \"" + propKey + "\" to be controlled. " + warningDescription);
    }
  });
}

var Input = /*#__PURE__*/function (_Component) {
  _inherits(Input, _Component);

  var _super = _createSuper(Input);

  function Input(props) {
    var _this;

    _classCallCheck(this, Input);

    _this = _super.call(this, props);
    _this.state = {
      value: props.value || props.defaultValue || ''
    };
    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));
    _this.clear = _this.clear.bind(_assertThisInitialized(_this));
    _this.inputRef = /*#__PURE__*/React__default.createRef();
    return _this;
  }

  _createClass(Input, [{
    key: "handleChange",
    value: function handleChange(event) {
      var onChange = this.props.onChange;

      if (typeof onChange === 'function') {
        onChange(event);
      }

      this.setState({
        value: event.target.value
      });
    }
  }, {
    key: "clear",
    value: function clear(event) {
      event.stopPropagation();
      this.inputRef.current.focus();
      this.handleChange(_objectSpread2(_objectSpread2({}, event), {}, {
        target: _objectSpread2(_objectSpread2({}, this.inputRef.current), {}, {
          value: ''
        })
      }));
    }
  }, {
    key: "hasClear",
    value: function hasClear(allowClear, hasValue, readOnly, disabled) {
      var isEditable = !(readOnly || disabled);
      return allowClear && hasValue && isEditable;
    }
  }, {
    key: "getInputContent",
    value: function getInputContent(icon, loading) {
      if (loading) {
        return /*#__PURE__*/React__default.createElement(Spinner, {
          className: cuiClassName('input__spinner'),
          size: "s"
        });
      } else if (icon) {
        return /*#__PURE__*/React__default.createElement(Icon, {
          className: cuiClassName('input__icon'),
          icon: icon,
          size: "s"
        });
      } else {
        return null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          autofilled = _this$props.autofilled,
          color = _this$props.color,
          icon = _this$props.icon,
          iconPosition = _this$props.iconPosition,
          loading = _this$props.loading,
          label = _this$props.label,
          message = _this$props.message,
          allowClear = _this$props.allowClear,
          readOnly = _this$props.readOnly,
          disabled = _this$props.disabled,
          givenClassName = _this$props.className,
          selected = _this$props.selected,
          size = _this$props.size,
          forwardRef = _this$props.forwardRef,
          inputRef = _this$props.inputRef;
      var hasValue = !!(this.state.value && this.state.value.length);
      var hasClear = this.hasClear(allowClear, hasValue, readOnly, disabled);
      var spinnerPosition = icon ? iconPosition : 'right';
      var className = classnames(cuiClassName('input'), _defineProperty({}, cuiClassName("input--autofilled"), autofilled), _defineProperty({}, cuiClassName("input--".concat(color)), color), _defineProperty({}, cuiClassName("input--icon-".concat(iconPosition)), icon), _defineProperty({}, cuiClassName("input--spinner-".concat(spinnerPosition)), loading), _defineProperty({}, cuiClassName("input--has-clear"), hasClear), _defineProperty({}, cuiClassName("input--selected"), selected), _defineProperty({}, cuiClassName("input--".concat(size)), size), givenClassName);

      var props = _objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      });

      var ref = function ref(input) {
        return triggerReferences(input, _this2.inputRef, inputRef);
      };

      var inputProps = _objectSpread2({
        ref: ref
      }, this.passthrough());

      delete inputProps.defaultValue;
      return /*#__PURE__*/React__default.createElement("div", props, label && /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('input__label')
      }, label), /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('input__box')
      }, /*#__PURE__*/React__default.createElement("input", _extends({}, inputProps, {
        value: this.state.value,
        onChange: this.handleChange,
        readOnly: readOnly,
        disabled: disabled
      })), this.getInputContent(icon, loading), hasClear && /*#__PURE__*/React__default.createElement(Icon, {
        className: cuiClassName('input__clear'),
        icon: "cross",
        size: "s",
        onClick: this.clear
      })), message && /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('input__message')
      }, message));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if ('value' in props && state.value !== props.value) {
        return {
          value: props.value
        };
      }

      return null;
    }
  }]);

  return Input;
}(Component);

var smallSizeModifierValidator = function smallSizeModifierValidator(props, propName, componentName) {
  if (props[propName]) {
    PropTypes.checkPropTypes(_defineProperty({}, propName, PropTypes.bool), props, propName, componentName);

    if (props.size !== 's') {
      throw new Error("".concat(propName, " prop for ").concat(componentName, " should only be used together with small size!"));
    }
  }
};

Input.propTypes = {
  type: PropTypes.oneOf(['text', 'email', 'number', 'password', 'search', 'url']),
  color: PropTypes.oneOf(['red']),
  label: PropTypes.node,
  message: PropTypes.string,
  icon: PropTypes.string,
  iconPosition: PropTypes.oneOf(['left', 'right']),
  loading: PropTypes.bool,
  onChange: PropTypes.func,
  className: PropTypes.string,
  value: PropTypes.string,
  defaultValue: PropTypes.string,
  allowClear: PropTypes.bool,
  readOnly: PropTypes.bool,
  disabled: PropTypes.bool,
  size: PropTypes.oneOf(['s']),
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  inputRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  selected: smallSizeModifierValidator,
  autofilled: smallSizeModifierValidator
};
Input.defaultProps = {
  type: 'text',
  iconPosition: 'left',
  onChange: function onChange() {},
  readOnly: false,
  disabled: false
};
passthrough({
  force: ['type']
})(Input);

var Tag = /*#__PURE__*/function (_Component) {
  _inherits(Tag, _Component);

  var _super = _createSuper(Tag);

  function Tag(props) {
    _classCallCheck(this, Tag);

    return _super.call(this, props);
  }

  _createClass(Tag, [{
    key: "onKeyDown",
    value: function onKeyDown(event, onDismiss) {
      if (event.keyCode === 8) {
        event.preventDefault();
        onDismiss();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _cx,
          _this = this;

      var _this$props = this.props,
          givenClassName = _this$props.className,
          children = _this$props.children,
          color = _this$props.color,
          disabled = _this$props.disabled,
          forwardRef = _this$props.forwardRef,
          dismissable = _this$props.dismissable,
          onDismiss = _this$props.onDismiss,
          tabIndex = _this$props.tabIndex;
      var className = classnames(cuiClassName('tag'), givenClassName, (_cx = {}, _defineProperty(_cx, cuiClassName("tag--".concat(color)), color), _defineProperty(_cx, cuiClassName("tag--disabled"), disabled), _cx));

      var props = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
        className: className
      }, !disabled && {
        tabIndex: tabIndex
      }), !disabled && dismissable && onDismiss && {
        onKeyDown: function onKeyDown(e) {
          return _this.onKeyDown(e, onDismiss);
        }
      }), forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var dismissIcon;

      if (dismissable && !disabled) {
        var dismissIconProps = _objectSpread2({}, onDismiss && {
          onClick: onDismiss
        });

        dismissIcon = /*#__PURE__*/React__default.createElement(Icon, _extends({
          className: cuiClassName('tag__icon'),
          icon: "cross",
          size: "s"
        }, dismissIconProps));
      } // Check if child is textNode and wrap it with span


      var content = React__default.Children.map(children, function (child) {
        if (child) {
          if (child.type) {
            return child;
          }

          return /*#__PURE__*/React__default.createElement("span", {
            className: cuiClassName('tag__content')
          }, child);
        }
      });
      return /*#__PURE__*/React__default.createElement("div", props, dismissIcon, content);
    }
  }]);

  return Tag;
}(Component);
Tag.propTypes = {
  children: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  className: PropTypes.string,
  disabled: PropTypes.bool,
  color: PropTypes.oneOf(['red']),
  dismissable: PropTypes.bool,
  onDismiss: PropTypes.func,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  tabIndex: PropTypes.number
};
Tag.defaultProps = {
  tabIndex: 0
};
passthrough()(Tag);

var Separator = /*#__PURE__*/function (_Component) {
  _inherits(Separator, _Component);

  var _super = _createSuper(Separator);

  function Separator(props) {
    _classCallCheck(this, Separator);

    return _super.call(this, props);
  }

  _createClass(Separator, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          givenClassName = _this$props.className,
          children = _this$props.children,
          icon = _this$props.icon,
          sticky = _this$props.sticky,
          type = _this$props.type,
          forwardRef = _this$props.forwardRef,
          spacing = _this$props.spacing;
      var className = classnames(givenClassName, cuiClassName('separator'), cuiClassName("separator--".concat(type || 'line')), _defineProperty({}, cuiClassName("separator--sticky"), sticky));

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var needsSpacing = spacing && type === 'vertical';
      var spacingProps = spacing ? typeof spacing === 'string' ? {
        all: spacing
      } : spacing : {
        all: 'm'
      };
      var separator = /*#__PURE__*/React__default.createElement("div", props, icon && /*#__PURE__*/React__default.createElement(Icon, {
        icon: icon,
        size: "s"
      }), children ? /*#__PURE__*/React__default.createElement("span", null, children) : '');

      if (needsSpacing) {
        return /*#__PURE__*/React__default.createElement(Spacing, _extends({
          style: {
            display: 'flex',
            alignSelf: 'stretch'
          }
        }, spacingProps), separator);
      }

      return separator;
    }
  }]);

  return Separator;
}(Component);
Separator.propTypes = {
  type: PropTypes.oneOf(['block', 'vertical']),
  children: function children(props, propName, componentName) {
    PropTypes.checkPropTypes({
      children: PropTypes.node
    }, props, propName, componentName);

    if (!props.children) {
      if (props.type === 'block') {
        throw new Error("Block type ".concat(componentName, " component should have children!"));
      }

      if (props.icon) {
        throw new Error("".concat(componentName, " component with icon should have children!"));
      }
    }
  },
  icon: PropTypes.string,
  className: PropTypes.string,
  sticky: function sticky(props, propName, componentName) {
    if (props.sticky) {
      PropTypes.checkPropTypes({
        sticky: PropTypes.bool
      }, props, 'sticky', componentName);

      if (props.type !== 'block') {
        throw new Error("Sticky ".concat(componentName, " should only be used together with block type!"));
      }
    }
  },
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  spacing: function spacing(props, propName, componentName) {
    if (props.spacing) {
      PropTypes.checkPropTypes({
        spacing: PropTypes.oneOfType([oneOfDimensionSizes, PropTypes.shape(spacingPropTypes)])
      }, props, 'spacing', componentName);

      if (props.type !== 'vertical') {
        return new Error("Spacing should only be used together with vertical type ".concat(componentName, "!"));
      }
    }
  }
};
passthrough()(Separator);

var SelectOption = /*#__PURE__*/function (_Component) {
  _inherits(SelectOption, _Component);

  var _super = _createSuper(SelectOption);

  function SelectOption() {
    _classCallCheck(this, SelectOption);

    return _super.apply(this, arguments);
  }

  _createClass(SelectOption, [{
    key: "render",
    value: function render() {
      var propsToForward = _objectSpread2({}, this.props);

      delete propsToForward.itemToString;
      delete propsToForward.getContentForTrigger;
      return /*#__PURE__*/React__default.createElement(Option, propsToForward);
    }
  }]);

  return SelectOption;
}(Component);
SelectOption.propTypes = _objectSpread2(_objectSpread2({}, Option.propTypes), {}, {
  value: PropTypes.any,
  itemToString: PropTypes.func,
  getContentForTrigger: PropTypes.func
});
SelectOption.defaultProps = {
  itemToString: function itemToString(item) {
    return item.props.children;
  },
  manualHighlight: true
};

var _excluded$1 = ["getToggleButtonProps", "isOpen", "getRootProps"];

var getOptionContent = function getOptionContent(option) {
  var optionsProps = option.props;

  if (typeof optionsProps.getContentForTrigger === 'function') {
    return /*#__PURE__*/React__default.createElement("span", null, optionsProps.getContentForTrigger(option));
  }

  return /*#__PURE__*/React__default.createElement("span", null, optionsProps.children);
};

var getDirection = function getDirection(placement) {
  if (placement.endsWith('end')) {
    return 'end';
  }

  return 'start';
};
/**
 * When having adequate space for preferred placement return the passed `placement` prop.
 * Otherwise, return `placement` in the direction with applicable spacing.
 */


var getPlacement = function getPlacement(height, top, bottom) {
  var placement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'bottom-start';

  if (placement.includes('top')) {
    return height < top ? placement : "bottom-".concat(getDirection(placement));
  } else if (placement.includes('bottom')) {
    return height < bottom ? placement : "top-".concat(getDirection(placement));
  }

  return height < bottom ? placement : 'top-start';
};
/**
 * Get available space from the `placement` direction without clipping viewport boundary.
 */


var getMaxHeight = function getMaxHeight(top, bottom) {
  var placement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'bottom-start';

  /**
   * Safety threshold to prevent returned `maxHeight` to be clipped by viewport
   * and flipped in reverse by the `popper.js`
   */
  var VIEWPORT_EDGE_SETBACK_MARGIN = 8;
  var segmentedHeight = placement.includes('bottom') ? bottom : top;
  return Math.round(segmentedHeight) - VIEWPORT_EDGE_SETBACK_MARGIN;
};
/**
 * Fix to prefer original placement if flipped placement doesn't have enough room either.
 * Related to Popper.js issue: https://github.com/FezVrasta/popper.js/issues/550
 */


var POPPER_FLIP_BEHAVIOR_OVERRIDE = ['bottom', 'top', 'bottom'];

var Select = /*#__PURE__*/function (_Component) {
  _inherits(Select, _Component);

  var _super = _createSuper(Select);

  function Select(props) {
    var _this;

    _classCallCheck(this, Select);

    _this = _super.call(this, props);
    _this.state = {
      filterValue: '',
      value: props.value || props.defaultValue,
      placement: props.placement,
      behavior: POPPER_FLIP_BEHAVIOR_OVERRIDE,
      overflowStyles: {}
    };
    _this.clear = _this.clear.bind(_assertThisInitialized(_this));
    _this.onValueChange = _this.onValueChange.bind(_assertThisInitialized(_this));
    _this.onDownshiftChange = _this.onDownshiftChange.bind(_assertThisInitialized(_this));
    _this.onFilterChange = _this.onFilterChange.bind(_assertThisInitialized(_this));
    _this.onStateChange = _this.onStateChange.bind(_assertThisInitialized(_this));
    _this.stateReducer = _this.stateReducer.bind(_assertThisInitialized(_this));
    _this.dismissMultiple = _this.dismissMultiple.bind(_assertThisInitialized(_this));
    _this.getPortalTo = _this.getPortalTo.bind(_assertThisInitialized(_this));
    _this.renderOptionsIfVisible = _this.renderOptionsIfVisible.bind(_assertThisInitialized(_this));
    _this.restrictPlacementToViewport = _this.restrictPlacementToViewport.bind(_assertThisInitialized(_this));
    _this.getOverflowRestrictions = _this.getOverflowRestrictions.bind(_assertThisInitialized(_this));
    _this.filterElement = /*#__PURE__*/React__default.createRef();
    _this.selectElement = /*#__PURE__*/React__default.createRef();
    _this.popupElement = /*#__PURE__*/React__default.createRef();
    _this.multipleOptions = /*#__PURE__*/React__default.createRef();
    _this.scheduleUpdate = null;
    return _this;
  }

  _createClass(Select, [{
    key: "getPortalTo",
    value: function getPortalTo() {
      var portalTo = this.props.portalTo;

      if (typeof portalTo === 'function') {
        return portalTo();
      }

      return portalTo;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (typeof this.scheduleUpdate === 'function') {
        if (prevState.filterValue !== this.state.filterValue || prevState.value !== this.state.value) {
          this.scheduleUpdate();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.portalElement) {
        this.portalElement.remove();
      }
    }
  }, {
    key: "clear",
    value: function clear(event) {
      event.stopPropagation();
      this.onValueChange(null, true);
    }
  }, {
    key: "onDownshiftChange",
    value: function onDownshiftChange(item) {
      if (item && item.props && 'value' in item.props) {
        this.onValueChange(item.props.value);
      }
    }
    /**
     * Allow Select to be controlled or uncontrolled component by checking if value is available in props.
     */

  }, {
    key: "onValueChange",
    value: function onValueChange(optionValue, clear) {
      var _this$props = this.props,
          onChange = _this$props.onChange,
          multiple = _this$props.multiple,
          resetFilterOnValueChange = _this$props.resetFilterOnValueChange;
      var newSelectValue = optionValue;

      if (multiple && !clear) {
        var value = this.state.value;
        var optionValueIndex = -1;
        var selectedValues = [];

        if (value) {
          optionValueIndex = value.indexOf(optionValue);
          selectedValues = _toConsumableArray(value);
        }

        if (optionValueIndex === -1) {
          selectedValues.push(optionValue);
        } else {
          selectedValues.splice(optionValueIndex, 1);
        }

        newSelectValue = selectedValues;
      }

      if ('value' in this.props) {
        if (typeof onChange === 'function') {
          onChange(newSelectValue);
        }
      } else {
        this.setState({
          value: newSelectValue
        }, function () {
          if (typeof onChange === 'function') {
            onChange(newSelectValue);
          }
        });
      }

      if (resetFilterOnValueChange) {
        this.onFilterChange('');
      }
    }
  }, {
    key: "onFilterChange",
    value: function onFilterChange(filterValue) {
      var _this2 = this;

      var onFilterChange = this.props.onFilterChange;
      this.setState({
        filterValue: filterValue
      }, function () {
        if (typeof _this2.scheduleUpdate === 'function') {
          _this2.scheduleUpdate();
        }

        if (typeof onFilterChange === 'function') {
          onFilterChange(filterValue);
        }
      });
    }
  }, {
    key: "onStateChange",
    value: function onStateChange(action) {
      var onVisibilityChange = this.props.onVisibilityChange;

      if ('isOpen' in action) {
        onVisibilityChange && onVisibilityChange(action.isOpen);

        if (action.isOpen && this.filterElement.current) {
          this.filterElement.current.focus({
            preventScroll: true
          });
        } else if (!action.isOpen && this.selectElement.current) {
          var child = this.selectElement.current.getElementsByClassName(cuiClassName('select__box'));

          if (child.length) {
            child[0].focus();
          }
        }
      }
    }
  }, {
    key: "stateReducer",
    value: function stateReducer(state, changes) {
      var multiple = this.props.multiple;

      switch (changes.type) {
        case Downshift.stateChangeTypes.keyDownEnter:
        case Downshift.stateChangeTypes.clickItem:
          if (multiple) {
            return _objectSpread2(_objectSpread2({}, changes), {}, {
              isOpen: state.isOpen,
              highlightedIndex: state.highlightedIndex
            });
          }

          return changes;

        default:
          return changes;
      }
    }
  }, {
    key: "dismissMultiple",
    value: function dismissMultiple(option) {
      var _this3 = this;

      return function () {
        var value = _this3.state.value;
        var isLast = value && value.indexOf(option.props.value) === value.length - 1;

        if (isLast && value.length > 1 && _this3.multipleOptions.current) {
          var tags = _this3.multipleOptions.current.querySelectorAll(".".concat(cuiClassName('tag')));

          tags[tags.length - 2].focus();
        }

        _this3.onValueChange(option.props.value);
      };
    }
    /**
     * Get all options by looping through all elements and their children.
     */

  }, {
    key: "getOptions",
    value: function getOptions() {
      var children = this.props.children;

      var looper = function looper(items) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        React__default.Children.forEach(items, function (child) {
          if (child) {
            if (child.type === SelectOption) {
              options.push(child);
            } else if (child.props && typeof child.props.value !== 'undefined') {
              options.push(child);
            } else if (child.props && child.props.children) {
              looper(child.props.children, options);
            }
          }
        });
        return options;
      };

      return looper(children);
    }
  }, {
    key: "getSelectedOptions",
    value: function getSelectedOptions(options) {
      var _this4 = this;

      var multiple = this.props.multiple;
      var value = this.state.value;
      var selectedOptions = options.filter(function (option) {
        return _this4.isSelected(value, option.props.value);
      }); // Sort multiple options so they appear in the order they are selected.

      if (multiple && value) {
        selectedOptions.sort(function (a, b) {
          var aIndex = value.indexOf(a.props.value);
          var bIndex = value.indexOf(b.props.value);
          return aIndex - bIndex;
        });
      }

      return selectedOptions;
    }
  }, {
    key: "optionItemToString",
    value: function optionItemToString(item) {
      if (item && item.props) {
        if (item.props.itemToString) {
          return item.props.itemToString(item);
        } else {
          return this.props.optionItemToString(item);
        }
      }
    }
  }, {
    key: "getBoxContent",
    value: function getBoxContent() {
      var _this5 = this;

      var _this$props2 = this.props,
          placeholder = _this$props2.placeholder,
          multiple = _this$props2.multiple,
          disabled = _this$props2.disabled;
      var options = this.getOptions();
      var selectedOptions = this.getSelectedOptions(options);
      var boxContent = '';
      var hasValue = true;

      if (selectedOptions.length) {
        if (multiple) {
          boxContent = /*#__PURE__*/React__default.createElement("div", {
            ref: this.multipleOptions,
            className: cuiClassName('select__multiple-options')
          }, selectedOptions.map(function (option, index) {
            var tagProps = {
              dismissable: true
            };

            if (disabled) {
              tagProps.disabled = true;
            } else {
              tagProps.onClick = function (event) {
                return event.stopPropagation();
              };

              tagProps.onDismiss = _this5.dismissMultiple(option);
            }

            return /*#__PURE__*/React__default.createElement(Tag, _extends({
              key: index
            }, tagProps), _this5.optionItemToString(option));
          }));
        } else {
          boxContent = getOptionContent(selectedOptions[0]);
        }
      } else if (placeholder) {
        boxContent = /*#__PURE__*/React__default.createElement("span", null, placeholder);
        hasValue = false;
      } else if (options.length) {
        boxContent = getOptionContent(options[0]);
      }

      return {
        boxContent: boxContent,
        hasValue: hasValue
      };
    }
  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      var _this$props3 = this.props,
          allowClear = _this$props3.allowClear,
          autofilled = _this$props3.autofilled,
          color = _this$props3.color,
          disabled = _this$props3.disabled,
          downShiftProps = _this$props3.downShiftProps,
          givenClassName = _this$props3.className,
          selected = _this$props3.selected,
          size = _this$props3.size,
          forwardRef = _this$props3.forwardRef;
      var value = this.state.value;
      return /*#__PURE__*/React__default.createElement(Downshift, _extends({
        defaultHighlightedIndex: 0
      }, downShiftProps, {
        onChange: this.onDownshiftChange,
        selectedItem: value,
        itemToString: function itemToString(item) {
          return _this6.optionItemToString(item);
        },
        onStateChange: this.onStateChange,
        stateReducer: this.stateReducer
      }), function (_ref) {
        var _cx;

        var getToggleButtonProps = _ref.getToggleButtonProps,
            isOpen = _ref.isOpen,
            getRootProps = _ref.getRootProps,
            downShiftRest = _objectWithoutProperties(_ref, _excluded$1);

        var _this6$getBoxContent = _this6.getBoxContent(),
            boxContent = _this6$getBoxContent.boxContent,
            hasValue = _this6$getBoxContent.hasValue;

        var hasClear = allowClear && hasValue;
        var className = classnames(cuiClassName('select'), (_cx = {}, _defineProperty(_cx, cuiClassName("select--autofilled"), autofilled), _defineProperty(_cx, cuiClassName("select--".concat(color)), color), _defineProperty(_cx, cuiClassName('select--no-value'), !hasValue), _defineProperty(_cx, cuiClassName('select--has-clear'), hasClear), _defineProperty(_cx, cuiClassName('select--disabled'), disabled), _defineProperty(_cx, cuiClassName('select--open'), isOpen), _defineProperty(_cx, cuiClassName("select--selected"), selected), _defineProperty(_cx, cuiClassName("select--".concat(size)), size), _cx), givenClassName);
        var props = getRootProps(_objectSpread2({
          className: className
        }, _this6.passthrough()), {
          suppressRefError: true
        });
        var downshiftRef = props.ref;

        props.ref = function (node) {
          return triggerReferences(node, _this6.selectElement, downshiftRef, forwardRef);
        };

        return /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement(Manager, null, _this6.renderOptionsIfVisible(isOpen, downShiftRest), _this6.renderTrigger({
          isOpen: isOpen,
          hasClear: hasClear,
          boxContent: boxContent,
          getToggleButtonProps: getToggleButtonProps
        })));
      });
    }
  }, {
    key: "renderTrigger",
    value: function renderTrigger(_ref2) {
      var _this7 = this;

      var isOpen = _ref2.isOpen,
          hasClear = _ref2.hasClear,
          boxContent = _ref2.boxContent,
          getToggleButtonProps = _ref2.getToggleButtonProps;
      var _this$props4 = this.props,
          disabled = _this$props4.disabled,
          tabIndex = _this$props4.tabIndex,
          icon = _this$props4.icon;
      return /*#__PURE__*/React__default.createElement(Reference, null, function (_ref3) {
        var ref = _ref3.ref;
        var toggleButtonProps = {
          className: cuiClassName('select__box'),
          ref: ref
        };

        if (!disabled) {
          toggleButtonProps = getToggleButtonProps(_objectSpread2(_objectSpread2({}, toggleButtonProps), {}, {
            tabIndex: tabIndex
          }));
        }

        return /*#__PURE__*/React__default.createElement("span", toggleButtonProps, icon && /*#__PURE__*/React__default.createElement(Icon, {
          icon: icon,
          size: "s",
          className: cuiClassName('select__icon')
        }), boxContent, hasClear && /*#__PURE__*/React__default.createElement(Icon, {
          className: cuiClassName('select__clear'),
          onClick: _this7.clear,
          icon: "cross",
          size: "s"
        }), /*#__PURE__*/React__default.createElement(Icon, {
          className: cuiClassName('select__toggle'),
          icon: isOpen ? 'triangle-up' : 'triangle-down',
          size: "s"
        }));
      });
    }
  }, {
    key: "isSelected",
    value: function isSelected(selectValue, optionValue) {
      var multiple = this.props.multiple;
      return multiple ? Array.isArray(selectValue) && selectValue.includes(optionValue) : selectValue === optionValue;
    }
  }, {
    key: "renderOptionsIfVisible",
    value: function renderOptionsIfVisible(isOpen, downShiftRest) {
      if (!isOpen) {
        return null;
      }

      var portalTo = this.getPortalTo();

      if (portalTo) {
        if (!this.portalElement) {
          this.portalElement = document.createElement('div');
        }

        if (this.portalElement.parentNode !== portalTo) {
          portalTo.append(this.portalElement);
        }

        return /*#__PURE__*/ReactDOM.createPortal(this.renderOptions(downShiftRest), this.portalElement);
      } else if (this.portalElement) {
        this.portalElement.remove();
        this.portalElement = null;
      }

      return this.renderOptions(downShiftRest);
    }
  }, {
    key: "renderOptions",
    value: function renderOptions(_ref4) {
      var _this8 = this;

      var getItemProps = _ref4.getItemProps,
          getMenuProps = _ref4.getMenuProps,
          getInputProps = _ref4.getInputProps,
          highlightedIndex = _ref4.highlightedIndex,
          selectedItem = _ref4.selectedItem;
      var _this$props5 = this.props,
          filter = _this$props5.filter,
          filterNotFoundText = _this$props5.filterNotFoundText,
          filterPlaceholder = _this$props5.filterPlaceholder,
          children = _this$props5.children,
          popupClassName = _this$props5.popupClassName,
          popperProps = _this$props5.popperProps,
          renderOptions = _this$props5.renderOptions;
      var _this$state = this.state,
          filterValue = _this$state.filterValue,
          placement = _this$state.placement,
          behavior = _this$state.behavior,
          overflowStyles = _this$state.overflowStyles;
      var index = 0;
      var mapOptions; // eslint-disable-next-line complexity

      var mapOption = function mapOption(child) {
        if (child.type === SelectOption || child.props && typeof child.props.value !== 'undefined') {
          if (filterValue && !_this8.optionItemToString(child).toLowerCase().includes(filterValue.toLowerCase())) {
            return;
          }

          var disabled = child.props.disabled;
          var childProps = {
            item: child,
            highlighted: index === highlightedIndex,
            selected: _this8.isSelected(selectedItem, child.props.value),
            onClick: function onClick(ev) {
              ev.stopPropagation();
            }
          };

          if (disabled) {
            childProps.disabled = true;
          } else {
            childProps.index = index;
            index++;
          }

          return /*#__PURE__*/React__default.cloneElement(child, _objectSpread2({}, getItemProps(childProps)));
        } else if (child.props && child.props.children) {
          var groupChildren = mapOptions(child.props.children); // If we're filtering and there are no Options as children we can also skip the parent.

          if (filterValue && !React__default.Children.count(groupChildren.filter(function (child) {
            return child && child.type !== Separator;
          }))) {
            return;
          }

          return /*#__PURE__*/React__default.cloneElement(child, {
            children: groupChildren
          });
        } else {
          return child;
        }
      };

      mapOptions = function mapOptions(children) {
        return React__default.Children.map(children, function (child) {
          return child && mapOption(child);
        });
      };

      var options = mapOptions(children);

      if (filterValue && !React__default.Children.count(options)) {
        options = /*#__PURE__*/React__default.createElement("div", {
          className: cuiClassName('select__filter-not-found')
        }, filterNotFoundText);
      } else {
        options = renderOptions(options);
      }

      return /*#__PURE__*/React__default.createElement(Popper$1, _extends({
        placement: placement
      }, popperProps, {
        modifiers: _objectSpread2(_objectSpread2({
          hide: {
            enabled: false
          },
          flip: {
            behavior: behavior
          },
          preventOverflow: {
            /**
             * Restrict placement to `window` as the default `scrollParent`
             * can cause overlap with the `selectElement`.
             */
            boundariesElement: window
          }
        }, popperProps && popperProps.modifiers), {}, {
          arrow: {
            enabled: false
          },
          restrictPlacementToViewport: this.restrictPlacementToViewport()
        })
      }), function (_ref5) {
        var ref = _ref5.ref,
            style = _ref5.style,
            placement = _ref5.placement,
            scheduleUpdate = _ref5.scheduleUpdate;

        var popupStyle = _objectSpread2(_objectSpread2({}, style), overflowStyles);

        delete popupStyle.top;
        delete popupStyle.left;

        if (_this8.selectElement.current) {
          popupStyle.minWidth = "".concat(_this8.selectElement.current.offsetWidth, "px");
        }

        _this8.scheduleUpdate = scheduleUpdate;
        var popperRef = ref;

        ref = function ref(node) {
          return triggerReferences(node, _this8.popupElement, popperRef);
        };

        return /*#__PURE__*/React__default.createElement("div", {
          className: classnames(cuiClassName('select__popup'), _defineProperty({}, cuiClassName("select__popup--placement-".concat(placement)), placement), popupClassName),
          ref: ref,
          style: popupStyle
        }, filter && /*#__PURE__*/React__default.createElement(Input, _extends({
          placeholder: filterPlaceholder,
          icon: "search",
          iconPosition: "right",
          className: cuiClassName('select__filter')
        }, getInputProps({
          value: filterValue,
          onChange: function onChange(event) {
            return _this8.onFilterChange(event.target.value);
          }
        }), {
          inputRef: _this8.filterElement
        })), /*#__PURE__*/React__default.createElement("div", getMenuProps({
          className: cuiClassName('select__options')
        }), options));
      });
    }
  }, {
    key: "restrictPlacementToViewport",
    value: function restrictPlacementToViewport() {
      var _this9 = this;

      /**
       * `react-popper` `updateStateModifier` order nr for `popper.js` `ModifierFn`
       * https://github.com/FezVrasta/react-popper/blob/master/src/Popper.js#L91
       */
      var REACT_POPPER_UPDATE_STATE_MODIFIER_ORDER = 900;
      /**
       * Schedule the modifier fn to run after `react-popper` has completed `updateStateModifier`
       * https://github.com/FezVrasta/react-popper/blob/master/src/Popper.js#L89
       */

      var order = REACT_POPPER_UPDATE_STATE_MODIFIER_ORDER + 1;
      return {
        enabled: true,
        order: order,
        fn: function fn(data) {
          var _this9$getOverflowRes = _this9.getOverflowRestrictions(data),
              behavior = _this9$getOverflowRes.behavior,
              placement = _this9$getOverflowRes.placement,
              overflowStyles = _this9$getOverflowRes.style;
          /**
           * Not reliable to use `data.styles.maxHeight = maxHeight`
           * as it ejects some styles on indeterminate events.
           * Using internal state will assure persistent state.
           */


          _this9.setState({
            behavior: behavior,
            placement: placement,
            overflowStyles: overflowStyles
          });

          return data;
        }
      };
    }
  }, {
    key: "getOverflowRestrictions",
    value: function getOverflowRestrictions(_ref6) {
      var popoverHeight = _ref6.popper.height;
      var passedPlacement = this.props.placement;
      var element = this.selectElement.current;

      var _element$getBoundingC = element.getBoundingClientRect(),
          rectBottom = _element$getBoundingC.bottom,
          top = _element$getBoundingC.top;

      var _window = window,
          innerHeight = _window.innerHeight;
      var bottom = innerHeight - rectBottom;
      var placement = getPlacement(popoverHeight, top, bottom, passedPlacement);
      var behavior = [placement];
      var maxHeight = getMaxHeight(top, bottom, placement);
      var style = {
        maxHeight: maxHeight,
        zIndex: 6001
      };
      return {
        behavior: behavior,
        placement: placement,
        style: style
      };
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if ('value' in props && state.value !== props.value) {
        return {
          value: props.value
        };
      }

      return null;
    }
  }]);

  return Select;
}(Component);

var smallSizeModifierValidator$1 = function smallSizeModifierValidator(props, propName, componentName) {
  if (props[propName]) {
    PropTypes.checkPropTypes(_defineProperty({}, propName, PropTypes.bool), props, propName, componentName);

    if (props.size !== 's') {
      throw new Error("".concat(propName, " prop for ").concat(componentName, " should only be used together with small size!"));
    }
  }
};

var valuePropType = function valuePropType(props, propName, componentName) {
  if (props.multiple) {
    PropTypes.checkPropTypes(_defineProperty({}, propName, PropTypes.array), props, propName, componentName);
  }
};

Select.propTypes = {
  autofilled: smallSizeModifierValidator$1,
  color: PropTypes.oneOf(['red']),
  children: PropTypes.node,
  portalTo: PropTypes.any,
  icon: PropTypes.string,
  value: valuePropType,
  defaultValue: valuePropType,
  onChange: PropTypes.func,
  allowClear: PropTypes.bool,
  placeholder: PropTypes.node,
  disabled: PropTypes.bool,
  tabIndex: PropTypes.number,
  filter: PropTypes.bool,
  filterNotFoundText: PropTypes.string,
  filterPlaceholder: PropTypes.string,
  resetFilterOnValueChange: PropTypes.bool,
  onFilterChange: PropTypes.func,
  optionItemToString: PropTypes.func,
  popupClassName: PropTypes.string,
  downShiftProps: PropTypes.object,
  popperProps: PropTypes.object,
  placement: PropTypes.string,
  className: PropTypes.string,
  selected: smallSizeModifierValidator$1,
  size: function size(props, propName, componentName) {
    if (propName in props && props[propName] !== 's') {
      throw new Error("Invalid prop ".concat(propName, " supplied to ").concat(componentName, ". Prop can only be \"s\"."));
    } else if (props[propName] === 's' && props.multiple) {
      throw new Error("Small Select cannot be multiple.");
    }
  },
  renderOptions: PropTypes.func,
  multiple: PropTypes.bool,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  onVisibilityChange: PropTypes.func
};
Select.defaultProps = {
  tabIndex: 0,
  filterNotFoundText: 'No results were found',
  defaultValue: undefined,
  // eslint-disable-line
  onChange: function onChange() {},
  optionItemToString: function optionItemToString(item) {
    return item.props.children;
  },
  placement: 'bottom-start',
  renderOptions: function renderOptions(options) {
    return options;
  }
};
passthrough()(Select);
Select.Option = SelectOption;

var select$4 = fieldTypes.select;

function Select$1(_ref) {
  var children = _ref.children;

  var _useFieldContext = useFieldContext(),
      field = _useFieldContext.field,
      updateValue = _useFieldContext.updateValue;

  var uid = field.uid,
      value = field.value,
      placeholder = field.placeholder;
  return /*#__PURE__*/React__default.createElement(Select, {
    value: value,
    onChange: updateValue,
    placeholder: placeholder,
    portalTo: document.body,
    downShiftProps: {
      labelId: uid
    }
  }, children);
}

Select$1.propTypes = {
  children: PropTypes.node.isRequired
};

function FeedbackSelect(_ref2) {
  var id = _ref2.id,
      label = _ref2.label,
      placeholder = _ref2.placeholder,
      initialValue = _ref2.initialValue,
      required = _ref2.required,
      children = _ref2.children;
  var options = {
    type: select$4,
    label: label,
    initialValue: initialValue,
    placeholder: placeholder,
    required: required
  };
  return /*#__PURE__*/React__default.createElement(Field, {
    id: id,
    options: options
  }, /*#__PURE__*/React__default.createElement(Select$1, null, children));
}

FeedbackSelect.propTypes = {
  id: PropTypes.string.isRequired,
  label: PropTypes.string,
  placeholder: PropTypes.string,
  initialValue: PropTypes.string,
  required: PropTypes.bool,
  children: PropTypes.node.isRequired
};
var feedbackSelect = /*#__PURE__*/memo(FeedbackSelect);

var Textarea = /*#__PURE__*/function (_Component) {
  _inherits(Textarea, _Component);

  var _super = _createSuper(Textarea);

  function Textarea() {
    _classCallCheck(this, Textarea);

    return _super.apply(this, arguments);
  }

  _createClass(Textarea, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          color = _this$props.color,
          label = _this$props.label,
          message = _this$props.message,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef,
          inputRef = _this$props.inputRef,
          resize = _this$props.resize;
      var className = classnames(cuiClassName('textarea'), _defineProperty({}, cuiClassName("textarea--".concat(color)), color), _defineProperty({}, cuiClassName("textarea--resize-".concat(resize)), resize !== 'y' && resize), givenClassName);

      var props = _objectSpread2(_objectSpread2({}, forwardRef && {
        ref: forwardRef
      }), {}, {
        className: className
      });

      var textareaProps = _objectSpread2(_objectSpread2({}, inputRef && {
        ref: inputRef
      }), this.passthrough());

      return /*#__PURE__*/React__default.createElement("div", props, label && /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('textarea__label')
      }, label), /*#__PURE__*/React__default.createElement("textarea", textareaProps), message && /*#__PURE__*/React__default.createElement("p", {
        className: cuiClassName('textarea__message')
      }, message));
    }
  }]);

  return Textarea;
}(Component);
Textarea.propTypes = {
  color: PropTypes.oneOf(['red']),
  label: PropTypes.node,
  message: PropTypes.string,
  className: PropTypes.string,
  onChange: PropTypes.func,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  inputRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  resize: PropTypes.oneOf(['both', 'x', 'y', 'none'])
};
Textarea.defaultProps = {
  resize: 'y',
  onChange: function onChange() {}
};
passthrough({
  force: ['onChange'],
  omitKnownPropTypes: true
})(Textarea);

var textarea$3 = fieldTypes.textarea;

function Textarea$1() {
  var _useFieldContext = useFieldContext(),
      field = _useFieldContext.field,
      updateValue = _useFieldContext.updateValue,
      onUpdateValidity = _useFieldContext.onUpdateValidity;

  var id = field.id,
      uid = field.uid,
      value = field.value;
  return /*#__PURE__*/React__default.createElement(Textarea, {
    id: uid,
    name: id,
    value: value,
    onChange: updateValue,
    onBlur: onUpdateValidity
  });
}

function FeedbackTextarea(_ref) {
  var id = _ref.id,
      label = _ref.label,
      required = _ref.required;
  var options = {
    type: textarea$3,
    label: label,
    required: required
  };
  return /*#__PURE__*/React__default.createElement(Field, {
    id: id,
    options: options
  }, /*#__PURE__*/React__default.createElement(Textarea$1, null));
}

FeedbackTextarea.propTypes = {
  id: PropTypes.string.isRequired,
  label: PropTypes.string,
  required: PropTypes.bool
};
var feedbackTextarea = /*#__PURE__*/memo(FeedbackTextarea);

var FeedbackModal = /*#__PURE__*/forwardRef(function (_ref, forwardedRef) {
  var visible = _ref.visible,
      hide = _ref.hide,
      onSubmit = _ref.onSubmit,
      initTextSet = _ref.textSet,
      children = _ref.children;

  var _useReducer = useReducer(reducer, initialState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];

  var isFormValid = state.isFormValid,
      fields = state.fields,
      isClosing = state.isClosing;
  var textSet = useTextSet(initTextSet);

  var _useActions = useActions(dispatch),
      addField = _useActions.addField,
      updateFieldValue = _useActions.updateFieldValue,
      updateFieldValidity = _useActions.updateFieldValidity,
      setFieldIsValidatedOnce = _useActions.setFieldIsValidatedOnce,
      updateFields = _useActions.updateFields,
      startClosing = _useActions.startClosing,
      finishClosing = _useActions.finishClosing,
      setIsFormValid = _useActions.setIsFormValid;

  var submit = useSubmitHandler({
    fields: fields,
    isFormValid: isFormValid,
    updateFields: updateFields,
    setIsFormValid: setIsFormValid,
    onSubmit: onSubmit,
    startClosing: startClosing
  });
  var unmount = useCallback(function () {
    if (isClosing) {
      finishClosing();
      hide();
    }
  }, [isClosing, hide]);
  return /*#__PURE__*/React__default.createElement(FormContext.Provider, {
    value: {
      fields: fields,
      addField: addField,
      updateFieldValue: updateFieldValue,
      updateFieldValidity: updateFieldValidity,
      setFieldIsValidatedOnce: setFieldIsValidatedOnce,
      isFormValid: isFormValid,
      setIsFormValid: setIsFormValid
    }
  }, visible && /*#__PURE__*/React__default.createElement(Modal, {
    ref: forwardedRef,
    className: baseClassName,
    spacing: "none",
    visible: visible && !isClosing,
    header: textSet.title,
    footer: /*#__PURE__*/React__default.createElement(ModalFooter$1, {
      textSet: textSet,
      isFormValid: isFormValid,
      startClosing: startClosing,
      submit: submit
    }),
    onClose: startClosing,
    onTransitionEnd: unmount,
    closeOnEsc: true
  }, /*#__PURE__*/React__default.createElement(Panel, {
    spacing: "m",
    noBorder: true,
    noMargin: true
  }, children)));
});
FeedbackModal.propTypes = {
  visible: PropTypes.bool.isRequired,
  hide: PropTypes.func.isRequired,
  onSubmit: PropTypes.func.isRequired,
  textSet: PropTypes.object,
  children: PropTypes.node
};

function Form(_ref) {
  var children = _ref.children,
      id = _ref.id,
      onSubmit = _ref.onSubmit;
  return /*#__PURE__*/React__default.createElement("form", {
    className: cuiClassName('form'),
    id: id,
    onSubmit: onSubmit
  }, children);
}

Form.propTypes = {
  children: PropTypes.node.isRequired,
  id: PropTypes.string.isRequired,
  onSubmit: PropTypes.func.isRequired
};

function Link(_ref) {
  var title = _ref.title,
      url = _ref.url,
      onClick = _ref.onClick;
  var additionalLinkProps = {};

  if (url) {
    additionalLinkProps = {
      href: url,
      target: '_blank',
      rel: 'noopener noreferrer'
    };
  }

  if (url || url === '') {
    return /*#__PURE__*/React__default.createElement("a", _extends({
      className: cuiClassName('inline-info__link')
    }, additionalLinkProps, {
      onClick: onClick
    }), /*#__PURE__*/React__default.createElement("span", {
      className: cuiClassName('inline-info__link-text')
    }, title), url !== '' && /*#__PURE__*/React__default.createElement(Icon, {
      className: cuiClassName('inline-info__link-arrow'),
      icon: "redirect",
      size: "s",
      color: "blue"
    }));
  }

  return null;
}

Link.propTypes = {
  title: PropTypes.string,
  url: PropTypes.string,
  onClick: PropTypes.func
};

function InlineInfo(_ref) {
  var text = _ref.text,
      title = _ref.title,
      linkUrl = _ref.linkUrl,
      _ref$linkTitle = _ref.linkTitle,
      linkTitle = _ref$linkTitle === void 0 ? 'Learn more' : _ref$linkTitle,
      onLinkClick = _ref.onLinkClick,
      placement = _ref.placement,
      offset = _ref.offset,
      trigger = _ref.trigger,
      portalTo = _ref.portalTo;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isVisible = _useState2[0],
      setVisible = _useState2[1];

  var popover = useRef(null);
  var content = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, title && /*#__PURE__*/React__default.createElement(Text, null, /*#__PURE__*/React__default.createElement("h4", null, title)), text, /*#__PURE__*/React__default.createElement(Link, {
    title: linkTitle,
    url: linkUrl,
    onClick: onLinkClick
  }));
  var InfoIcon = /*#__PURE__*/React__default.createElement(Icon, {
    className: cuiClassName('inline-info__icon'),
    color: isVisible ? 'purple' : 'black-64',
    icon: isVisible ? 'info' : 'info-outline',
    size: "s",
    "aria-label": "Info",
    tabIndex: "0",
    onKeyDown: function onKeyDown(event) {
      if (['Enter', ' '].includes(event.key)) {
        if (event.key === ' ') {
          // Prevent page scroll
          event.preventDefault();
        }

        setVisible(function (isVisible) {
          return !isVisible;
        });
      } else if (event.key === 'Escape') {
        setVisible(false);
      }
    },
    onBlur: function onBlur(event) {
      var _popover$current;

      if (event.relatedTarget !== popover.current && !((_popover$current = popover.current) !== null && _popover$current !== void 0 && _popover$current.contains(event.relatedTarget))) {
        setVisible(false);
      }
    }
  });
  return /*#__PURE__*/React__default.createElement(Popover, {
    visible: isVisible,
    onVisibilityChange: function onVisibilityChange(visible) {
      return setVisible(visible);
    },
    placement: placement,
    offset: offset,
    spacing: "m",
    className: cuiClassName('inline-info__popover'),
    forwardRef: popover,
    content: content,
    tabIndex: "0",
    onBlur: function onBlur() {
      return setVisible(false);
    },
    trigger: trigger,
    portalTo: portalTo
  }, InfoIcon);
}

InlineInfo.propTypes = {
  text: PropTypes.node.isRequired,
  title: PropTypes.node,
  linkUrl: PropTypes.string,
  linkTitle: PropTypes.string,
  onLinkClick: PropTypes.func,
  placement: PropTypes.oneOf(['left', 'right', 'top', 'bottom', 'top-start', 'top-end', 'bottom-start', 'bottom-end', 'left-start', 'left-end', 'right-start', 'right-end', 'initial']),
  offset: PropTypes.oneOf(['xs', 's', 'm', 'l', 'xl', 'xxl', '-xs', '-s', '-m', '-l', '-xl', '-xxl']),
  trigger: PropTypes.oneOf(['hover', 'click']),
  portalTo: PropTypes.any
};

function Section(_ref) {
  var children = _ref.children,
      title = _ref.title,
      description = _ref.description,
      inlineInfoProps = _ref.inlineInfoProps;
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Spacing, {
    all: "l"
  }, /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(Text, {
    className: cuiClassName('form__section-title')
  }, /*#__PURE__*/React__default.createElement("h2", null, title), inlineInfoProps && /*#__PURE__*/React__default.createElement(InlineInfo, inlineInfoProps)), description && /*#__PURE__*/React__default.createElement(Text, {
    className: cuiClassName('form__section-description')
  }, /*#__PURE__*/React__default.createElement("p", null, description)), children)), /*#__PURE__*/React__default.createElement(Separator, {
    className: cuiClassName('form__section-separator')
  }));
}

Section.propTypes = {
  children: PropTypes.node.isRequired,
  title: PropTypes.string.isRequired,
  description: PropTypes.string,
  inlineInfoProps: PropTypes.shape(InlineInfo.propTypes)
};

function Group(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/React__default.createElement("div", {
    className: cuiClassName('form__group')
  }, children);
}

Group.propTypes = {
  children: PropTypes.node.isRequired
};

function Label(_ref) {
  var children = _ref.children,
      type = _ref.type,
      hint = _ref.hint,
      id = _ref.id,
      inlineInfoProps = _ref.inlineInfoProps,
      noTopPadding = _ref.noTopPadding;
  var labelContent = /*#__PURE__*/React__default.createElement(React__default.Fragment, null, children, hint && /*#__PURE__*/React__default.createElement("span", {
    className: cuiClassName('form__field-label--hint')
  }, "(", hint, ")"));
  return /*#__PURE__*/React__default.createElement(Text, null, /*#__PURE__*/React__default.createElement("div", {
    className: classnames(cuiClassName('form__field-label'), _defineProperty({}, cuiClassName('form__field-label--no-top-padding'), noTopPadding))
  }, type === 'legend' && /*#__PURE__*/React__default.createElement("legend", {
    className: cuiClassName('form__fieldset-legend')
  }, labelContent), type === 'label' && /*#__PURE__*/React__default.createElement("label", {
    className: cuiClassName('form__field-label-text'),
    htmlFor: id
  }, labelContent), inlineInfoProps && /*#__PURE__*/React__default.createElement(InlineInfo, inlineInfoProps)));
}

Label.propTypes = {
  children: PropTypes.node.isRequired,
  type: PropTypes.string.isRequired,
  hint: PropTypes.oneOf(['required', 'optional']),
  id: PropTypes.string,
  inlineInfoProps: PropTypes.shape(InlineInfo.propTypes),
  noTopPadding: PropTypes.bool
};

function Subtext(_ref) {
  var children = _ref.children,
      type = _ref.type;
  return /*#__PURE__*/React__default.createElement(Text, {
    className: classnames(cuiClassName('form__field-text'), _defineProperty({}, cuiClassName('form__field-text--error'), type === 'error'))
  }, /*#__PURE__*/React__default.createElement("p", null, children));
}

Subtext.propTypes = {
  children: PropTypes.string.isRequired,
  type: PropTypes.oneOf(['error'])
};

function FieldLayout(_ref) {
  var _cx;

  var children = _ref.children,
      vertical = _ref.vertical,
      fullWidth = _ref.fullWidth,
      smallMargin = _ref.smallMargin;
  return /*#__PURE__*/React__default.createElement("div", {
    className: classnames((_cx = {}, _defineProperty(_cx, cuiClassName('form__fieldset--horizontal'), !vertical), _defineProperty(_cx, cuiClassName('form__fieldset--horizontal--full-width'), !vertical && fullWidth), _defineProperty(_cx, cuiClassName('form__fieldset--horizontal--small-margin'), !vertical && smallMargin), _defineProperty(_cx, cuiClassName('form__fieldset--vertical'), vertical), _cx))
  }, children);
}

FieldLayout.propTypes = {
  children: PropTypes.node.isRequired,
  vertical: PropTypes.bool,
  fullWidth: PropTypes.bool,
  smallMargin: PropTypes.bool
};

function FieldSet(_ref) {
  var children = _ref.children,
      label = _ref.label,
      labelHint = _ref.labelHint,
      error = _ref.error,
      helper = _ref.helper,
      inlineInfoProps = _ref.inlineInfoProps,
      layoutOptions = _ref.layoutOptions;
  var vertical = layoutOptions.vertical,
      fullWidth = layoutOptions.fullWidth,
      noTopPadding = layoutOptions.noTopPadding,
      smallMargin = layoutOptions.smallMargin;
  return /*#__PURE__*/React__default.createElement("fieldset", {
    className: classnames(cuiClassName('form__field'), cuiClassName('form__fieldset'))
  }, /*#__PURE__*/React__default.createElement(Label, {
    type: "legend",
    hint: labelHint,
    inlineInfoProps: inlineInfoProps,
    noTopPadding: noTopPadding
  }, label), /*#__PURE__*/React__default.createElement(FieldLayout, {
    vertical: vertical,
    fullWidth: fullWidth,
    smallMargin: smallMargin
  }, children, error && error.isError && /*#__PURE__*/React__default.createElement(Subtext, {
    type: "error"
  }, error.text), helper && /*#__PURE__*/React__default.createElement(Subtext, null, helper)));
}

FieldSet.propTypes = {
  children: PropTypes.node.isRequired,
  label: PropTypes.string.isRequired,
  labelHint: PropTypes.string,
  error: PropTypes.shape({
    isError: PropTypes.bool,
    text: PropTypes.string
  }),
  helper: PropTypes.string,
  inlineInfoProps: PropTypes.shape(InlineInfo.propTypes),
  layoutOptions: PropTypes.shape({
    vertical: PropTypes.bool,
    fullWidth: PropTypes.bool,
    noTopPadding: PropTypes.bool,
    smallMargin: PropTypes.bool
  })
};

function Indicator(_ref) {
  var _cx;

  var remainingCharacters = _ref.remainingCharacters,
      setIndicator = _ref.setIndicator,
      noTopPadding = _ref.noTopPadding;
  return /*#__PURE__*/React__default.createElement(Text, {
    className: classnames(cuiClassName('form__field-helper'), (_cx = {}, _defineProperty(_cx, cuiClassName('form__field-helper--no-top-padding'), noTopPadding), _defineProperty(_cx, cuiClassName('form__field-text--error'), remainingCharacters < 0), _cx))
  }, /*#__PURE__*/React__default.createElement("p", null, setIndicator(remainingCharacters)));
}

Indicator.propTypes = {
  remainingCharacters: PropTypes.number.isRequired,
  setIndicator: PropTypes.func.isRequired,
  noTopPadding: PropTypes.bool
};

function FieldWrapper(props) {
  var _children$props, _children$props$value;

  var children = props.children,
      label = props.label,
      labelHint = props.labelHint,
      error = props.error,
      helper = props.helper,
      inlineInfoProps = props.inlineInfoProps,
      layout = props.layout,
      id = props.id,
      characterLimit = props.characterLimit,
      setIndicator = props.setIndicator;

  var _useState = useState(((_children$props = children.props) === null || _children$props === void 0 ? void 0 : (_children$props$value = _children$props.value) === null || _children$props$value === void 0 ? void 0 : _children$props$value.length) || 0),
      _useState2 = _slicedToArray(_useState, 2),
      characterCount = _useState2[0],
      setCharacterCount = _useState2[1];

  var remainingCharacters = characterLimit - characterCount;

  var layoutOptions = _objectSpread2({
    vertical: false,
    fullWidth: false,
    noTopPadding: false,
    smallMargin: true
  }, layout);

  if (Array.isArray(children)) {
    return /*#__PURE__*/React__default.createElement(FieldSet, _extends({}, props, {
      layoutOptions: layoutOptions
    }), children);
  }

  return /*#__PURE__*/React__default.createElement("div", {
    className: cuiClassName('form__field')
  }, /*#__PURE__*/React__default.createElement(Label, {
    type: "label",
    hint: labelHint,
    id: id,
    inlineInfoProps: inlineInfoProps,
    noTopPadding: layoutOptions.noTopPadding
  }, label), /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/cloneElement(children, {
    id: id,
    onChange: characterLimit ? function (e) {
      var _children$props$onCha, _children$props2;

      (_children$props$onCha = (_children$props2 = children.props).onChange) === null || _children$props$onCha === void 0 ? void 0 : _children$props$onCha.call(_children$props2, e);
      setCharacterCount(e.target.value.length);
    } : children.props.onChange
  }), error && error.isError && /*#__PURE__*/React__default.createElement(Subtext, {
    type: "error"
  }, error.text), helper && /*#__PURE__*/React__default.createElement(Subtext, null, helper)), characterLimit && setIndicator && /*#__PURE__*/React__default.createElement(Indicator, {
    remainingCharacters: remainingCharacters,
    setIndicator: setIndicator,
    noTopPadding: layoutOptions.noTopPadding
  }));
}

FieldWrapper.propTypes = {
  children: PropTypes.node.isRequired,
  label: PropTypes.string.isRequired,
  labelHint: PropTypes.string,
  error: PropTypes.shape({
    isError: PropTypes.bool,
    text: PropTypes.string
  }),
  helper: PropTypes.string,
  inlineInfoProps: PropTypes.shape(InlineInfo.propTypes),
  layout: PropTypes.shape({
    vertical: PropTypes.bool,
    fullWidth: PropTypes.bool,
    noTopPadding: PropTypes.bool,
    smallMargin: PropTypes.bool
  }),
  characterLimit: PropTypes.number,
  setIndicator: PropTypes.func,
  id: PropTypes.string
};

Form.Section = Section;
Form.Group = Group;
Form.FieldWrapper = FieldWrapper;
Form.FieldLayout = FieldLayout;

var baseClassName$1 = cuiClassName('image-overlay');

function ControlButton(_ref) {
  var onClick = _ref.onClick,
      children = _ref.children,
      href = _ref.href,
      tooltipText = _ref.tooltipText;

  var props = _objectSpread2({
    onClick: onClick,
    href: href
  }, href && {
    target: '_blank',
    rel: 'noreferrer'
  });

  return /*#__PURE__*/React__default.createElement(Tooltip, {
    content: tooltipText
  }, /*#__PURE__*/React__default.createElement(Button, _extends({
    className: "".concat(baseClassName$1, "__control-button"),
    color: "ghost"
  }, props), children));
}

ControlButton.propTypes = {
  onClick: PropTypes.func,
  children: PropTypes.node,
  href: PropTypes.string,
  tooltipText: PropTypes.string
};
var ControlButton$1 = /*#__PURE__*/React__default.memo(ControlButton);

function ErrorImage() {
  return /*#__PURE__*/React__default.createElement("svg", {
    width: "80",
    height: "80",
    viewBox: "0 0 80 80",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/React__default.createElement("rect", {
    x: "17",
    y: "17",
    width: "41",
    height: "41",
    rx: "2",
    stroke: "#747678",
    strokeWidth: "2"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M20.5819 50.0079L28.1539 42.1325C28.3571 41.9212 28.6903 41.9173 28.8981 42.1238L32.7433 45.9446C32.9568 46.1567 33.3011 46.146 33.5014 45.9209L41.3244 37.1311C41.5283 36.9021 41.8801 36.8956 42.0919 37.1171L54.4235 50.0089C54.7478 50.3479 54.5114 50.9165 54.0462 50.9165H20.9583C20.4924 50.9165 20.2563 50.3466 20.5819 50.0079Z",
    fill: "#747678"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M36.5 30.25C36.5 31.8532 35.2255 33.125 33.6875 33.125C32.1495 33.125 30.875 31.8532 30.875 30.25C30.875 28.6468 32.1495 27.375 33.6875 27.375C35.2255 27.375 36.5 28.6468 36.5 30.25Z",
    stroke: "#747678",
    strokeWidth: "2"
  }), /*#__PURE__*/React__default.createElement("rect", {
    x: "42",
    y: "42",
    width: "32",
    height: "32",
    rx: "16",
    fill: "#404346"
  }), /*#__PURE__*/React__default.createElement("path", {
    d: "M63.1818 52.9092L53 63.091M63.1818 63.091L53 52.9092",
    stroke: "#B9BABB",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}

var baseClassName$2 = cuiClassName('image-overlay');

function Image$1(_ref) {
  var src = _ref.src,
      alt = _ref.alt,
      onLoad = _ref.onLoad,
      onError = _ref.onError;
  return /*#__PURE__*/React__default.createElement("img", {
    src: src,
    alt: alt,
    className: "".concat(baseClassName$2, "__image"),
    onLoad: onLoad,
    onError: onError
  });
}

Image$1.propTypes = {
  src: PropTypes.string.isRequired,
  alt: PropTypes.string.isRequired,
  onLoad: PropTypes.func.isRequired,
  onError: PropTypes.func.isRequired
};
var Image$2 = /*#__PURE__*/React__default.memo(Image$1);

var baseClassName$3 = cuiClassName('image-overlay');
var LOADING_STATUSES = {
  LOADING: 'loading',
  LOADED: 'loaded',
  FAILED: 'failed'
};
var LOADING = LOADING_STATUSES.LOADING,
    LOADED = LOADING_STATUSES.LOADED,
    FAILED = LOADING_STATUSES.FAILED;

function ImageOverlay(_ref) {
  var src = _ref.src,
      alt = _ref.alt,
      title = _ref.title,
      onClose = _ref.onClose,
      visible = _ref.visible,
      errorMessage = _ref.errorMessage,
      closeTooltipText = _ref.closeTooltipText,
      newTabTooltipText = _ref.newTabTooltipText,
      _ref$portalTo = _ref.portalTo,
      portalTo = _ref$portalTo === void 0 ? document.body : _ref$portalTo,
      _ref$closeOnEsc = _ref.closeOnEsc,
      closeOnEsc = _ref$closeOnEsc === void 0 ? true : _ref$closeOnEsc;

  var _useState = useState(LOADING),
      _useState2 = _slicedToArray(_useState, 2),
      loadingStatus = _useState2[0],
      setLoadingStatus = _useState2[1];

  var onImageLoad = useCallback(function () {
    return setLoadingStatus(LOADED);
  }, []);
  var onImageError = useCallback(function () {
    return setLoadingStatus(FAILED);
  }, []);
  var onBackdropClick = useCallback(function (event) {
    var isBackdropClick = event.target === event.currentTarget;

    if (isBackdropClick) {
      onClose();
    }
  }, [onClose]);

  var onKeyUp = function onKeyUp(event) {
    if (event.key === 'Escape' && closeOnEsc) {
      onClose();
    }
  };

  useEffect(function () {
    if (visible) {
      setLoadingStatus(LOADING);
      document.addEventListener('keyup', onKeyUp);
    } else {
      document.removeEventListener('keyup', onKeyUp);
    }

    return function () {
      return document.removeEventListener('keyup', onKeyUp);
    };
  }, [visible]);

  if (!visible) {
    return null;
  }

  return /*#__PURE__*/createPortal( /*#__PURE__*/React__default.createElement("div", {
    className: baseClassName$3,
    onClick: onBackdropClick
  }, /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(baseClassName$3, "__header")
  }, /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(baseClassName$3, "__title")
  }, title), /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(baseClassName$3, "__controls")
  }, /*#__PURE__*/React__default.createElement(ControlButton$1, {
    tooltipText: newTabTooltipText,
    href: src
  }, /*#__PURE__*/React__default.createElement(Icon, {
    icon: "redirect",
    color: "black-32"
  })), /*#__PURE__*/React__default.createElement(ControlButton$1, {
    tooltipText: closeTooltipText,
    onClick: onClose
  }, /*#__PURE__*/React__default.createElement(Icon, {
    icon: "cross",
    color: "black-32"
  })))), loadingStatus === LOADING && /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(baseClassName$3, "__spinner")
  }, /*#__PURE__*/React__default.createElement(Spinner, {
    darkBackground: true,
    light: true,
    size: "l"
  })), loadingStatus === FAILED ? /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(ErrorImage, null), errorMessage && /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(baseClassName$3, "__error-message")
  }, errorMessage)) : /*#__PURE__*/React__default.createElement(Image$2, {
    src: src,
    alt: alt,
    onLoad: onImageLoad,
    onError: onImageError
  })), portalTo);
}

ImageOverlay.propTypes = {
  src: PropTypes.string.isRequired,
  alt: PropTypes.string.isRequired,
  visible: PropTypes.bool.isRequired,
  onClose: PropTypes.func.isRequired,
  title: PropTypes.string,
  portalTo: PropTypes.any,
  errorMessage: PropTypes.string,
  closeTooltipText: PropTypes.string,
  newTabTooltipText: PropTypes.string,
  closeOnEsc: PropTypes.bool
};

var Message = /*#__PURE__*/function (_React$Component) {
  _inherits(Message, _React$Component);

  var _super = _createSuper(Message);

  function Message(props) {
    var _this;

    _classCallCheck(this, Message);

    _this = _super.call(this, props);
    _this.state = {
      visible: false,
      height: '0px'
    };
    _this.messageInner = /*#__PURE__*/React__default.createRef();
    _this.onTransitionEnd = _this.onTransitionEnd.bind(_assertThisInitialized(_this));
    _this.onResize = _this.onResize.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Message, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.visible) {
        this.show();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var messageContentHeight = "".concat(this.messageInner.current.offsetHeight, "px");

      if (!prevProps.visible && this.props.visible) {
        this.show();
      } else if (prevProps.visible && !this.props.visible) {
        this.hide();
      }

      if (this.props.visible && this.state.height !== messageContentHeight) {
        this.setState({
          height: messageContentHeight
        });
      }
    }
  }, {
    key: "show",
    value: function show() {
      var _this2 = this;

      this.setState({
        visible: true,
        height: "".concat(this.messageInner.current.offsetHeight, "px")
      }, function () {
        window.addEventListener('resize', _this2.onResize);
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this3 = this;

      this.setState({
        visible: false,
        height: '0px'
      }, function () {
        window.removeEventListener('resize', _this3.onResize);
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.onResize);
    }
  }, {
    key: "onResize",
    value: function onResize() {
      this.setState({
        height: "".concat(this.messageInner.current.offsetHeight, "px")
      });
    }
  }, {
    key: "onTransitionEnd",
    value: function onTransitionEnd(event) {
      if (event.propertyName === 'opacity' && event.target === this.el) {
        this.props.onTransitionEnd && this.props.onTransitionEnd(this.state.visible);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props = this.props,
          color = _this$props.color,
          icon = _this$props.icon,
          title = _this$props.title,
          children = _this$props.children,
          onClose = _this$props.onClose,
          alternative = _this$props.alternative,
          alternativePosition = _this$props.alternativePosition,
          alignCenter = _this$props.alignCenter,
          noAnimation = _this$props.noAnimation,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var _this$state = this.state,
          visible = _this$state.visible,
          height = _this$state.height;
      var className = classnames(cuiClassName('message'), _defineProperty({}, cuiClassName("message--visible"), visible), _defineProperty({}, cuiClassName("message--".concat(color)), color), _defineProperty({}, cuiClassName("message--alternative".concat(alternativePosition ? "-".concat(alternativePosition) : '')), alternative), _defineProperty({}, cuiClassName("message--align-center"), alternative && alignCenter), _defineProperty({}, cuiClassName("message--no-animation"), noAnimation), givenClassName);

      var messageRef = function messageRef(message) {
        triggerReferences(message, forwardRef);
        _this4.el = message;
      };

      var props = _objectSpread2({
        className: className,
        onTransitionEnd: this.onTransitionEnd,
        ref: messageRef,
        style: {
          height: height
        }
      }, this.passthrough());

      return /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement("div", {
        ref: this.messageInner,
        className: cuiClassName('message__inner')
      }, /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('message__icon')
      }, icon && /*#__PURE__*/React__default.createElement(Icon, {
        icon: icon,
        color: color || 'blue',
        size: "s"
      })), /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('message__content-wrap')
      }, title && /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('message__title')
      }, title), children && /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('message__content')
      }, children)), /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('message__close')
      }, onClose && /*#__PURE__*/React__default.createElement(Button, {
        color: "ghost",
        size: "s",
        onClick: onClose
      }, /*#__PURE__*/React__default.createElement(Icon, {
        size: "s",
        icon: "cross",
        color: "black"
      })))));
    }
  }]);

  return Message;
}(React__default.Component);
Message.propTypes = {
  visible: PropTypes.bool,
  color: PropTypes.oneOf(['green', 'yellow', 'red']),
  icon: PropTypes.string,
  title: PropTypes.node,
  children: PropTypes.node,
  onClose: PropTypes.func,
  alternative: PropTypes.bool,
  alternativePosition: PropTypes.oneOf(['bottom']),
  alignCenter: PropTypes.bool,
  onTransitionEnd: PropTypes.func,
  noAnimation: PropTypes.bool,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Message);

var Pill = /*#__PURE__*/function (_Component) {
  _inherits(Pill, _Component);

  var _super = _createSuper(Pill);

  function Pill() {
    _classCallCheck(this, Pill);

    return _super.apply(this, arguments);
  }

  _createClass(Pill, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          size = _this$props.size,
          color = _this$props.color,
          outline = _this$props.outline,
          children = _this$props.children,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('pill'), _defineProperty({}, cuiClassName('pill--s'), size === 's'), _defineProperty({}, cuiClassName("pill--".concat(color)), color), _defineProperty({}, cuiClassName('pill--outline'), outline), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var content = React__default.Children.map(children, function (child) {
        if (child) {
          if (child.type) {
            return child;
          }

          return /*#__PURE__*/React__default.createElement("span", {
            className: cuiClassName('pill__label')
          }, child);
        }
      });
      return /*#__PURE__*/React__default.createElement("div", props, content);
    }
  }]);

  return Pill;
}(Component);
Pill.propTypes = {
  size: PropTypes.oneOf(['s']),
  color: PropTypes.oneOf(['white', 'green', 'blue', 'yellow', 'red', 'purple']),
  outline: PropTypes.bool,
  className: PropTypes.string,
  children: PropTypes.node,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Pill);

function validateCircularProps(defaultValues, circularValues) {
  return function (props, propName, componentName) {
    if (!props[propName]) {
      return;
    }

    var allowed = defaultValues;
    var circularNotice = '';

    if (props.circular) {
      allowed = circularValues;
      circularNotice = 'Circular Progressbar is limited in options.';
    }

    if (!allowed.includes(props[propName])) {
      return new Error("Invalid \"".concat(propName, "\" prop supplied to ").concat(componentName, ". Allowed values: ").concat(allowed.map(function (s) {
        return "\"".concat(s, "\"");
      }).join(', '), ". ").concat(circularNotice));
    }
  };
}

var Progressbar = /*#__PURE__*/function (_Component) {
  _inherits(Progressbar, _Component);

  var _super = _createSuper(Progressbar);

  function Progressbar() {
    _classCallCheck(this, Progressbar);

    return _super.apply(this, arguments);
  }

  _createClass(Progressbar, [{
    key: "renderDefault",
    value: function renderDefault(props) {
      var progressProps = {
        className: cuiClassName('progressbar__progress'),
        style: {
          width: "".concat(this.props.percent, "%")
        }
      };
      return /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement("div", progressProps));
    }
  }, {
    key: "renderCircular",
    value: function renderCircular(props) {
      var dimensions = this.props.size === 's' ? 20 : 30;
      var stroke = this.props.size === 's' ? 2 : 3;
      var radius = dimensions / 2;
      var normalizedRadius = radius - stroke;
      var circumference = normalizedRadius * 2 * Math.PI;
      var strokeDashoffset = circumference - this.props.percent / 100 * circumference;
      var svgProps = {
        height: dimensions,
        width: dimensions
      };
      var backgroundCircleProps = {
        className: cuiClassName('progressbar__circle-background'),
        fill: 'transparent',
        strokeWidth: stroke,
        r: normalizedRadius,
        cx: radius,
        cy: radius
      };
      var circleProps = {
        className: cuiClassName('progressbar__circle-progress'),
        fill: 'transparent',
        strokeWidth: stroke,
        strokeDasharray: "".concat(circumference, " ").concat(circumference),
        style: {
          strokeDashoffset: strokeDashoffset
        },
        r: normalizedRadius,
        cx: radius,
        cy: radius
      };
      var circularProps = {
        svgProps: svgProps,
        backgroundCircleProps: backgroundCircleProps,
        circleProps: circleProps
      };
      return /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement("svg", circularProps.svgProps, !this.props.noBackground && /*#__PURE__*/React__default.createElement("circle", circularProps.backgroundCircleProps), /*#__PURE__*/React__default.createElement("circle", circularProps.circleProps)));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          color = _this$props.color,
          size = _this$props.size,
          noBackground = _this$props.noBackground,
          circular = _this$props.circular,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('progressbar'), _defineProperty({}, cuiClassName("progressbar--".concat(color)), color), _defineProperty({}, cuiClassName("progressbar--".concat(size)), size), _defineProperty({}, cuiClassName("progressbar--no-background"), noBackground), _defineProperty({}, cuiClassName("progressbar--circular"), circular), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      if (circular) {
        return this.renderCircular(props);
      }

      return this.renderDefault(props);
    }
  }]);

  return Progressbar;
}(Component);
Progressbar.propTypes = {
  percent: PropTypes.number,
  color: validateCircularProps(['green', 'yellow', 'red', 'blue', 'purple'], ['green', 'red']),
  size: validateCircularProps(['s', 'l', 'xl'], ['s']),
  noBackground: PropTypes.bool,
  className: PropTypes.string,
  circular: PropTypes.bool,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
Progressbar.defaultProps = {
  percent: 0
};
passthrough()(Progressbar);

var Radio = /*#__PURE__*/function (_Component) {
  _inherits(Radio, _Component);

  var _super = _createSuper(Radio);

  function Radio() {
    _classCallCheck(this, Radio);

    return _super.apply(this, arguments);
  }

  _createClass(Radio, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef,
          inputRef = _this$props.inputRef;
      var className = classnames(cuiClassName('radio'), _defineProperty({}, cuiClassName("radio--no-label"), !children), givenClassName);
      var checkboxProps = getCheckboxProps(this.passthrough());

      var props = _objectSpread2(_objectSpread2(_objectSpread2({}, forwardRef && {
        ref: forwardRef
      }), checkboxProps.rest), {}, {
        className: className
      });

      var inputProps = _objectSpread2(_objectSpread2({}, inputRef && {
        ref: inputRef
      }), checkboxProps.checkbox);

      if (inputProps.onClick || !inputProps.onChange) {
        inputProps.onClick = inputProps.onChange;
      }

      return /*#__PURE__*/React__default.createElement("label", props, /*#__PURE__*/React__default.createElement("input", _extends({
        type: "radio"
      }, inputProps)), /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('radio__dot')
      }), children && /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('radio__label')
      }, children));
    }
  }]);

  return Radio;
}(Component);
Radio.propTypes = {
  children: PropTypes.node,
  onChange: PropTypes.func,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  inputRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
Radio.defaultProps = {
  onChange: function onChange() {}
};
passthrough({
  force: ['onChange'],
  omitKnownPropTypes: true
})(Radio);

var height = 48;
/* same for header and footer */

var Sidebar = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      onClose = _ref.onClose,
      onTransitionEnd = _ref.onTransitionEnd,
      mountNode = _ref.mountNode,
      visible = _ref.visible,
      topOffset = _ref.topOffset,
      zIndex = _ref.zIndex,
      background = _ref.background,
      title = _ref.title,
      closeText = _ref.closeText,
      header = _ref.header,
      footer = _ref.footer;
  var sidebarClass = classnames(cuiClassName('sidebar'), _defineProperty({}, cuiClassName('sidebar--visible'), visible));
  var headerClass = classnames(cuiClassName('sidebar__header'), _defineProperty({}, cuiClassName('sidebar__header--no-title'), !title));
  var contentClass = classnames(cuiClassName('sidebar__content'), _defineProperty({}, cuiClassName('sidebar__content--transparent'), background === 'transparent'));
  var contentStyle = {
    height: "calc(100vh - ".concat(height, "px - ").concat(footer ? height : 0, "px - ").concat(topOffset, "px)")
  };
  useEffect(function () {
    function onEsc(_ref2) {
      var key = _ref2.key;

      if (key === 'Esc' || key === 'Escape') {
        onClose();
      }
    }

    document.addEventListener('keyup', onEsc);
    return function () {
      return document.removeEventListener('keyup', onEsc);
    };
  }, [onClose]);

  function handleTransitionEnd(event) {
    if (onTransitionEnd && event.propertyName === 'visibility' && event.target === event.currentTarget) {
      onTransitionEnd(visible);
    }
  }

  return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default.createElement("aside", {
    className: sidebarClass,
    style: {
      top: "".concat(topOffset, "px"),
      zIndex: zIndex
    },
    role: "complementary",
    onTransitionEnd: handleTransitionEnd,
    ref: ref
  }, /*#__PURE__*/React__default.createElement(Panel, {
    elevation: "16",
    noBorder: true,
    spacing: "none"
  }, /*#__PURE__*/React__default.createElement("header", {
    className: headerClass
  }, title && /*#__PURE__*/React__default.createElement("span", null, title), /*#__PURE__*/React__default.createElement("div", null, header, /*#__PURE__*/React__default.createElement(Tooltip, {
    content: closeText,
    placement: "bottom-end"
  }, /*#__PURE__*/React__default.createElement(Button, {
    color: "ghost",
    onClick: onClose,
    "aria-label": closeText
  }, /*#__PURE__*/React__default.createElement(Icon, {
    size: "s",
    icon: "cross"
  }))))), /*#__PURE__*/React__default.createElement(Panel, {
    spacing: "m",
    noBorder: true,
    noMargin: true,
    className: contentClass,
    style: contentStyle
  }, children), footer && /*#__PURE__*/React__default.createElement("footer", {
    className: cuiClassName('sidebar__footer')
  }, footer))), mountNode);
});
Sidebar.propTypes = {
  children: PropTypes.node.isRequired,
  onClose: PropTypes.func.isRequired,
  closeText: PropTypes.string.isRequired,
  mountNode: PropTypes.object,
  visible: PropTypes.bool,
  background: PropTypes.oneOf(['transparent', 'gray']),
  title: PropTypes.string,
  topOffset: PropTypes.number,
  zIndex: PropTypes.number,
  header: PropTypes.node,
  footer: PropTypes.node,
  onTransitionEnd: PropTypes.func
};
Sidebar.defaultProps = {
  visible: false,
  background: 'gray',
  topOffset: 0,
  zIndex: 1,

  get mountNode() {
    return document === 'undefined' ? null : document.body;
  }

};

function getOptionsForSnackbarWithAction(props) {
  var options = {
    isClosable: typeof props.onDismiss === 'function',
    isAutoClosable: true,
    dismissAfter: props.actionText ? 8000 : 4000
  };

  if (props.duration === 'long') {
    options.dismissAfter = 16000;
  } else if (props.duration === 'no-timeout') {
    options.dismissAfter = null;
    options.isAutoClosable = false;
  }

  return options;
}

function getOptionsFromProps(props) {
  return getOptionsForSnackbarWithAction(props);
}

var Snackbar = /*#__PURE__*/function (_PureComponent) {
  _inherits(Snackbar, _PureComponent);

  var _super = _createSuper(Snackbar);

  function Snackbar(props) {
    var _this;

    _classCallCheck(this, Snackbar);

    _this = _super.call(this, props);
    _this.state = _objectSpread2(_objectSpread2({}, getOptionsFromProps(props)), {}, {
      isActive: false
    });
    return _this;
  }

  _createClass(Snackbar, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      // wait for React to render dom before starting animation
      this.activeTimeout = setTimeout(function () {
        _this2.setState({
          isActive: true
        });
      }, 20);

      if (this.state.dismissAfter) {
        this.setDismissTimeout(this.state.dismissAfter);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this.activeTimeout);
      this.clearDismissTimeout();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevState.dismissAfter && prevState.dismissAfter !== this.state.dismissAfter) {
        this.setDismissTimeout(this.state.dismissAfter);
      }
    }
  }, {
    key: "clearDismissTimeout",
    value: function clearDismissTimeout() {
      clearTimeout(this.dismissTimeout);
    }
  }, {
    key: "setDismissTimeout",
    value: function setDismissTimeout(dismissAfter) {
      var _this3 = this;

      this.clearDismissTimeout();
      this.dismissTimeout = setTimeout(function () {
        _this3.handleDismiss();
      }, dismissAfter);
    }
    /*
     * @function handleClick
     * @description Handle click events on the action button.
     */

  }, {
    key: "handleClick",
    value: function handleClick() {
      if (typeof this.props.onClick === 'function') {
        this.props.onClick();
      }

      this.handleDismiss();
    }
  }, {
    key: "handleDismiss",
    value: function handleDismiss() {
      var _this4 = this;

      this.setState({
        isActive: false
      });

      if (typeof this.props.onDismiss === 'function') {
        // give a chance to show transition
        setTimeout(function () {
          _this4.props.onDismiss();
        }, 500);
      }
    }
  }, {
    key: "getModalContainer",
    value: function getModalContainer() {
      return typeof document === 'undefined' ? null : document.body;
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var _this$props = this.props,
          message = _this$props.message,
          closeText = _this$props.closeText,
          actionText = _this$props.actionText,
          showSpinner = _this$props.showSpinner,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef,
          href = _this$props.href;
      var modalContainer = typeof this.props.modalContainer === 'undefined' ? this.getModalContainer() : this.props.modalContainer;
      var className = classnames(cuiClassName('snackbar'), _defineProperty({}, cuiClassName('snackbar--hidden'), !this.state.isActive), givenClassName);

      var props = _objectSpread2(_objectSpread2(_objectSpread2({}, forwardRef && {
        ref: forwardRef
      }), this.passthrough()), {}, {
        className: className,
        onMouseOver: function onMouseOver() {
          return _this5.state.isAutoClosable && _this5.clearDismissTimeout();
        },
        onMouseOut: function onMouseOut() {
          return _this5.state.isAutoClosable && _this5.setDismissTimeout(1000);
        }
      });

      var closeButton;

      if (this.state.isClosable) {
        closeButton = /*#__PURE__*/React__default.createElement(Icon, {
          className: cuiClassName('snackbar__close'),
          icon: "cross",
          size: "s",
          color: "white",
          onClick: function onClick() {
            return _this5.handleDismiss();
          }
        });

        if (closeText) {
          closeButton = /*#__PURE__*/React__default.createElement(Tooltip, {
            content: closeText,
            placement: "top",
            portalTo: modalContainer,
            style: {
              zIndex: 10000
            }
          }, closeButton);
        }
      }

      return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('snackbar__snack-content')
      }, showSpinner && /*#__PURE__*/React__default.createElement(Spinner, {
        className: cuiClassName('snackbar__spinner'),
        size: "s",
        light: true,
        darkBackground: true
      }), /*#__PURE__*/React__default.createElement("p", {
        className: cuiClassName('snackbar__message')
      }, message), actionText && (href ? /*#__PURE__*/React__default.createElement("a", {
        className: cuiClassName('snackbar__action'),
        href: href,
        rel: "noreferrer",
        target: "_blank",
        onClick: function onClick() {
          return _this5.handleDismiss();
        }
      }, actionText) : /*#__PURE__*/React__default.createElement("button", {
        className: cuiClassName('snackbar__action'),
        onClick: function onClick() {
          return _this5.handleClick();
        }
      }, actionText)), closeButton)), modalContainer);
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props) {
      return _objectSpread2({}, getOptionsFromProps(props));
    }
  }]);

  return Snackbar;
}(PureComponent);

Snackbar.propTypes = {
  /** Text inside snackbar. */
  message: PropTypes.string.isRequired,

  /** Text on action button. Not shown by default. */
  actionText: PropTypes.string,

  /** Only applied when actionText is defined. Default durations - 4 seconds without action, 8 seconds with action. */
  duration: PropTypes.oneOf(['long', 'no-timeout']),
  showSpinner: PropTypes.bool,
  onClick: PropTypes.func,
  onDismiss: PropTypes.func,
  className: PropTypes.string,
  closeText: PropTypes.string,
  modalContainer: PropTypes.object,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  href: PropTypes.string
};
Snackbar.defaultProps = {
  get modalContainer() {
    return typeof document === 'undefined' ? null : document.body;
  }

};
passthrough()(Snackbar);

var Stage = /*#__PURE__*/function (_Component) {
  _inherits(Stage, _Component);

  var _super = _createSuper(Stage);

  function Stage() {
    _classCallCheck(this, Stage);

    return _super.apply(this, arguments);
  }

  _createClass(Stage, [{
    key: "renderStage",
    value: function renderStage(labelProps) {
      var _this$props = this.props,
          tooltip = _this$props.tooltip,
          tooltipPortal = _this$props.tooltipPortal;
      return /*#__PURE__*/React__default.createElement(Tooltip, {
        portalTo: tooltipPortal,
        position: "bottom",
        content: tooltip
      }, /*#__PURE__*/React__default.createElement("label", labelProps, this.getStageContent()));
    }
  }, {
    key: "getStageContent",
    value: function getStageContent() {
      var _this$props2 = this.props,
          loading = _this$props2.loading,
          children = _this$props2.children,
          isCompletedOrCurrent = _this$props2.isCompletedOrCurrent;

      if (loading) {
        return /*#__PURE__*/React__default.createElement(Spinner, {
          size: "s",
          darkBackground: isCompletedOrCurrent,
          light: true
        });
      }

      return children;
    }
  }, {
    key: "render",
    value: function render() {
      var _cx;

      var _this$props3 = this.props,
          size = _this$props3.size,
          id = _this$props3.id,
          dealStageId = _this$props3.dealStageId,
          onClick = _this$props3.onClick,
          loading = _this$props3.loading;
      var className = classnames(cuiClassName('stage-selector__stage'), (_cx = {}, _defineProperty(_cx, cuiClassName('stage-selector__stage--current'), id === dealStageId), _defineProperty(_cx, cuiClassName('stage-selector__stage--loading'), loading), _cx));
      var labelProps = {
        className: className,
        onClick: onClick,
        size: size,
        id: id
      };

      if (loading) {
        delete labelProps.onClick;
      }

      if (size === 's' || size === 'xs') {
        return /*#__PURE__*/React__default.createElement("label", labelProps);
      }

      return this.renderStage(labelProps);
    }
  }]);

  return Stage;
}(Component);
Stage.propTypes = {
  id: PropTypes.number.isRequired,
  dealStageId: PropTypes.number.isRequired,
  onClick: PropTypes.func,
  children: PropTypes.string,
  loading: PropTypes.bool,
  size: PropTypes.string,
  tooltip: PropTypes.string,
  tooltipPortal: PropTypes.instanceOf(Element),
  isCompletedOrCurrent: PropTypes.bool
};

var StageSelector = /*#__PURE__*/function (_Component) {
  _inherits(StageSelector, _Component);

  var _super = _createSuper(StageSelector);

  function StageSelector() {
    _classCallCheck(this, StageSelector);

    return _super.apply(this, arguments);
  }

  _createClass(StageSelector, [{
    key: "renderStages",
    value: function renderStages() {
      var _this$props = this.props,
          children = _this$props.children,
          size = _this$props.size,
          dealStageId = _this$props.dealStageId;
      var stageProps = {
        size: size,
        dealStageId: dealStageId
      };
      var childrenToRender = children;

      if (childrenToRender) {
        var isCompletedOrCurrent = true;
        childrenToRender = React__default.Children.map(childrenToRender, function (child) {
          var childElement = /*#__PURE__*/React__default.cloneElement(child, _objectSpread2(_objectSpread2({}, stageProps), {}, {
            isCompletedOrCurrent: isCompletedOrCurrent
          }));

          if (child.props.id === dealStageId) {
            isCompletedOrCurrent = false;
          }

          return childElement;
        });
      }

      return childrenToRender;
    }
  }, {
    key: "render",
    value: function render() {
      var _cx;

      var _this$props2 = this.props,
          size = _this$props2.size,
          dealStatus = _this$props2.dealStatus;
      var className = classnames(cuiClassName('stage-selector'), (_cx = {}, _defineProperty(_cx, cuiClassName("stage-selector--".concat(size)), size), _defineProperty(_cx, cuiClassName("stage-selector--".concat(dealStatus)), dealStatus), _cx));
      return /*#__PURE__*/React__default.createElement("div", {
        className: className
      }, this.renderStages());
    }
  }]);

  return StageSelector;
}(Component);
StageSelector.propTypes = {
  dealStageId: PropTypes.number.isRequired,
  children: PropTypes.node.isRequired,
  size: function size(props) {
    if (props.size === 'l' || !props.size) {
      var tooltipError = props.children.find(function (child) {
        return !child.props.tooltip;
      });
      var onClickError = props.children.find(function (child) {
        return !child.props.onClick;
      });

      if (tooltipError) {
        return new Error('tooltip is required for large and default size stage selector');
      }

      if (onClickError) {
        return new Error('onClick is required for large and default size stage selector');
      }
    }
  },
  dealStatus: PropTypes.oneOf(['won', 'lost', 'deleted'])
};
passthrough()(StageSelector);
StageSelector.Stage = Stage;

var tableTypes = {
  DEFAULT: 'DEFAULT',
  LEADS: 'LEADS'
};
var rowTypes = {
  head: 'head',
  body: 'body'
};
var cellTypes = {
  head: 'head',
  body: 'body',
  checkbox: 'checkbox',
  checkboxLeads: 'checkboxLeads',
  checkboxLeadsUnseen: 'checkboxLeadsUnseen',
  action: 'action'
};
var borderTypes = {
  DEFAULT: 'default',
  HORIZONTAL: 'horizontal',
  NONE: 'none'
};
var rowActionsTypes = {
  SEPARATOR: 'SEPARATOR'
};

var cssProps = {
  position: {
    relative: 'relative',
    sticky: 'sticky'
  }
};
var zIndexes = {
  columnDraggingOverlay: 1,
  columnDroppingOverlay: 2,
  columnDndBorder: 3
};
var dropDirections = {
  BEFORE: 'BEFORE',
  AFTER: 'AFTER',
  NONE: 'NONE'
};
var selectedStates = {
  ALL: 'ALL',
  NONE: 'NONE',
  INDETERMINATE: 'INDETERMINATE'
};
var sortingOrders = {
  NONE: null,
  ASC: 'asc',
  DESC: 'desc'
};
var requiredHandlers = [{
  name: 'useDndColumn',
  value: function value() {
    return {};
  }
}, {
  name: 'useColumnResize',
  value: function value() {
    return {};
  }
}, {
  name: 'onColumnClick'
}, {
  name: 'onRowClick'
}, {
  name: 'infiniteScroll',
  value: {
    hasMore: function hasMore() {
      return {};
    },
    loadMore: function loadMore() {
      return {};
    }
  }
}, {
  name: 'onHeadCornerClick',
  value: function value() {
    return {};
  }
}, {
  name: 'getRowActions',
  value: function value() {
    return [];
  }
}];
var flags = ['selectable', 'fullWidth'];
var widthUnits = ['px', '%', 'vw']; // The largest monitor's height is 2160px, it's ~68 rows

var maxRowsToDisplay = 100;
var minRowsToDisplay = 1;
var defaultInfiniteScrollThreshold = 15;
var defaultRowSelectionLimit = Infinity;
var defaultOverscanRowsCount = 30;
var scrollOffsetInaccuracy = 2;

var infiniteScrollPropTypes = PropTypes.shape({
  spinner: PropTypes.shape({
    caption: PropTypes.node
  })
});
var globalOptionsPropTypes = PropTypes.shape({
  tableType: PropTypes.oneOf(Object.values(tableTypes)),
  style: PropTypes.object,
  handlers: PropTypes.object,
  selectable: PropTypes.bool,
  fullWidth: PropTypes.bool,
  borderType: PropTypes.string,
  infiniteScroll: infiniteScrollPropTypes
});
var cellPropTypes = PropTypes.shape({
  type: PropTypes.string.isRequired,
  content: PropTypes.node,
  description: PropTypes.string,
  options: PropTypes.shape({
    style: PropTypes.object
  }),
  globalOptions: globalOptionsPropTypes
}).isRequired;
var rowActionPropTypes = PropTypes.shape({
  title: PropTypes.string,
  handler: PropTypes.func,
  type: PropTypes.string
});
var columnSortingItemPropTypes = PropTypes.shape({
  isPending: PropTypes.bool.isRequired,
  order: PropTypes.oneOf(Object.values(sortingOrders)),
  sequence: PropTypes.oneOf([null, 1, 2, 3])
});
var dropDirectionPropTypes = PropTypes.oneOf([dropDirections.BEFORE, dropDirections.AFTER, dropDirections.NONE]);
var rectPropTypes = PropTypes.shape({
  width: PropTypes.number,
  height: PropTypes.number,
  left: PropTypes.number,
  right: PropTypes.number
});
var offsetPropTypes = PropTypes.shape({
  x: PropTypes.number,
  y: PropTypes.number
});
var headMessagePropTypes = PropTypes.shape({
  text: PropTypes.string.isRequired,
  color: PropTypes.string,
  icon: PropTypes.string
});
var headMessagesPropTypes = PropTypes.arrayOf(headMessagePropTypes);

var _rowClassNames, _cellClassNames;
/**
 * @summary A hook to obtain a memoized full classname
 * from the provided classnames with their dependencies.
 * @param {...{string|Object}} args - Classnames with their dependencies
 * (look at the 'classnames' docs to learn more).
 * @returns {string} - Full classname.
 */

function useClassName() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var dependencies = args.reduce(function (acc, current) {
    if (current && _typeof(current) === 'object') {
      return [].concat(_toConsumableArray(acc), _toConsumableArray(Object.values(current)));
    }

    return acc;
  }, []);
  return useMemo(function () {
    return classnames(args);
  }, dependencies);
}
var baseClassName$4 = cuiClassName('table');
var rootClassNames = {
  fullWidth: "".concat(baseClassName$4, "--full-width"),
  horizontalBorder: "".concat(baseClassName$4, "--horizontal-border"),
  noBorder: "".concat(baseClassName$4, "--no-border")
};
var columnResizeHandleClassName = "".concat(baseClassName$4, "__column-resize-handle");
var columnSortingIndicatorClassName = "".concat(baseClassName$4, "__column-sorting-indicator");
var horizontalScrollIndicatorClassName = "".concat(baseClassName$4, "__horizontal-scroll-indicator");
var headContentWrapperClassName = "".concat(baseClassName$4, "__head-content-wrapper");
var rowActionsClassName = "".concat(baseClassName$4, "__row-actions");
var headCornerRoot = "".concat(baseClassName$4, "__head-corner");
var headCornerClassNames = {
  root: headCornerRoot,
  placeholder: "".concat(headCornerRoot, "--placeholder")
};
var bodyClassName = "".concat(baseClassName$4, "__body");
var bodySectionsClassName = "".concat(baseClassName$4, "__body-sections");
var bodyRowsClassName = "".concat(baseClassName$4, "__body-rows");
var checkboxesRoot = "".concat(baseClassName$4, "__checkboxes");
var checkboxesClassNames = {
  root: checkboxesRoot,
  leads: "".concat(checkboxesRoot, "--leads"),
  horizontallyScrolling: "".concat(checkboxesRoot, "--horizontally-scrolling")
};
var headRoot = "".concat(baseClassName$4, "__head");
var headClassNames = {
  root: headRoot
};
var rowRoot = "".concat(baseClassName$4, "__row");
var rowClassNames = (_rowClassNames = {
  root: rowRoot
}, _defineProperty(_rowClassNames, rowTypes.head, "".concat(rowRoot, "--head")), _defineProperty(_rowClassNames, rowTypes.body, "".concat(rowRoot, "--body")), _defineProperty(_rowClassNames, "clickable", "".concat(rowRoot, "--clickable")), _defineProperty(_rowClassNames, "selectable", "".concat(rowRoot, "--selectable")), _defineProperty(_rowClassNames, "hovered", "".concat(rowRoot, "--hovered")), _defineProperty(_rowClassNames, "selected", "".concat(rowRoot, "--selected")), _defineProperty(_rowClassNames, "noBorder", "".concat(rowRoot, "--no-border")), _defineProperty(_rowClassNames, "horizontalBorder", "".concat(rowRoot, "--horizontal-border")), _defineProperty(_rowClassNames, "horizontalBorderHead", "".concat(rowRoot, "--horizontal-border-head")), _rowClassNames);
var infiniteLoaderRoot = "".concat(baseClassName$4, "-infinite-loader");
var infiniteLoaderClassNames = {
  root: infiniteLoaderRoot,
  caption: "".concat(infiniteLoaderRoot, "__caption")
};
var cellRoot = "".concat(baseClassName$4, "__cell");
var cellClassNames = (_cellClassNames = {
  root: cellRoot,
  hovered: "".concat(cellRoot, "--hovered")
}, _defineProperty(_cellClassNames, cellTypes.head, "".concat(cellRoot, "--head")), _defineProperty(_cellClassNames, "headDragging", "".concat(cellRoot, "--head-dragging")), _defineProperty(_cellClassNames, "headSorted", "".concat(cellRoot, "--head-sorted")), _defineProperty(_cellClassNames, cellTypes.body, "".concat(cellRoot, "--body")), _defineProperty(_cellClassNames, cellTypes.checkbox, "".concat(cellRoot, "--checkbox")), _defineProperty(_cellClassNames, "checkboxHorizontallyScrolling", "".concat(cellRoot, "--checkbox-horizontally-scrolling")), _defineProperty(_cellClassNames, cellTypes.checkboxLeads, "".concat(cellRoot, "--checkbox-leads")), _defineProperty(_cellClassNames, cellTypes.action, "".concat(cellRoot, "--action")), _defineProperty(_cellClassNames, "checkboxLeadsUnseen", "".concat(cellRoot, "--checkbox-leads-unseen")), _defineProperty(_cellClassNames, "noBorder", "".concat(cellRoot, "--no-border")), _defineProperty(_cellClassNames, "horizontalBorder", "".concat(cellRoot, "--horizontal-border")), _defineProperty(_cellClassNames, "withRightBorder", "".concat(cellRoot, "--with-right-border")), _cellClassNames);
var cellTextClassName = "".concat(baseClassName$4, "__cell-text");

/**
 * @typedef {Object} Options
 * @property {boolean} fullWidth - is the table full width.
 * @property {string} borderType - table border type.
 */

/**
 * @typedef {Object} Payload
 * @property {string} className - passed additional class name.
 * @property {Options} options - options for calculation.
 */

/**
 * @summary Gets classname for a specific row.
 * @param {Payload} payload - info for calculation.
 * @returns {string} - root classname.
 */

function useRootClassName() {
  var _useClassName;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options;

  var fullWidth = options.fullWidth,
      borderType = options.borderType;
  return useClassName(baseClassName$4, (_useClassName = {}, _defineProperty(_useClassName, rootClassNames.fullWidth, fullWidth), _defineProperty(_useClassName, rootClassNames.horizontalBorder, borderType === borderTypes.HORIZONTAL), _defineProperty(_useClassName, rootClassNames.noBorder, borderType === borderTypes.NONE), _defineProperty(_useClassName, className, className), _useClassName));
}

/**
 * @typedef {Object} Payload
 * @property {string[]} types - types for a specific entity.
 * @property {Object.<string, string>} classNames - all class names
 * of a specific entity.
 * @property {Object.<string, string>} allTypes - all types
 * of a specific entity.
 */

/**
 * @summary Gets an object with key value pairs of
 * class name and shouldBeApplied indicator for a specific entity.
 * @param {Payload} payload - info for calculation.
 * @returns {Object.<string, boolean>} - key value pairs of
 * class name and shouldBeApplied indicator for a specific entity.
 */

function useTypeClassNames(_ref) {
  var types = _ref.types,
      classNames = _ref.classNames,
      allTypes = _ref.allTypes;
  return useMemo(function () {
    return types.reduce(function (acc, type) {
      var className = classNames === null || classNames === void 0 ? void 0 : classNames[type];
      if (!className) return acc;
      var shouldBeApplied = types.includes(allTypes === null || allTypes === void 0 ? void 0 : allTypes[type]);
      return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, className, shouldBeApplied));
    }, {});
  }, []);
}

/**
 * @typedef {Object} Options
 * @property {boolean} selected - is row selected.
 * @property {boolean} isHovered - is row hovered.
 */

/**
 * @typedef {Object} Payload
 * @property {string[]} types - array of row types.
 * @property {Options} options - options for calculation.
 */

/**
 * @summary Gets classname for a specific row.
 * @param {Payload} payload - info for calculation.
 * @returns {string} - classname for a specific row.
 */

function useRowClassName() {
  var _objectSpread2$1;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      types = _ref.types,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options,
      globalOptions = _ref.globalOptions;

  var borderType = globalOptions.borderType,
      selectable = globalOptions.selectable;
  var onRowClick = globalOptions.handlers.onRowClick;
  var selected = options.selected,
      isHovered = options.isHovered;
  var typeClassNames = useTypeClassNames({
    types: types,
    classNames: rowClassNames,
    allTypes: rowTypes
  });
  var isHead = typeClassNames === null || typeClassNames === void 0 ? void 0 : typeClassNames[rowClassNames.head];
  var noBorder = borderType === borderTypes.NONE;
  var horizontalBorder = borderType === borderTypes.HORIZONTAL;
  return useClassName(rowClassNames.root, _objectSpread2(_objectSpread2({}, typeClassNames), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, rowClassNames.clickable, !(onRowClick !== null && onRowClick !== void 0 && onRowClick.isPlaceholder)), _defineProperty(_objectSpread2$1, rowClassNames.hovered, isHovered), _defineProperty(_objectSpread2$1, rowClassNames.selectable, selectable), _defineProperty(_objectSpread2$1, rowClassNames.selected, selected), _defineProperty(_objectSpread2$1, rowClassNames.noBorder, noBorder), _defineProperty(_objectSpread2$1, rowClassNames.horizontalBorder, horizontalBorder), _defineProperty(_objectSpread2$1, rowClassNames.horizontalBorderHead, isHead && horizontalBorder), _objectSpread2$1)));
}

/**
 * @typedef {Object} Options
 * @property {string} borderType - Table border type.
 */

/**
 * @typedef {Object} Payload
 * @property {string[]} types - array of cell types.
 * @property {Options} options - options for calculation.
 */

/**
 * @summary Gets classname for a specific cell.
 * @param {Payload} payload - info for calculation.
 * @returns {string} - classname for a specific cell.
 */

function useCellClassName() {
  var _objectSpread2$1;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      types = _ref.types,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options,
      _ref$globalOptions = _ref.globalOptions,
      globalOptions = _ref$globalOptions === void 0 ? {} : _ref$globalOptions;

  var isDragging = options.isDragging,
      isSorted = options.isSorted,
      isHovered = options.isHovered,
      withRightBorder = options.withRightBorder;
  var borderType = globalOptions.borderType;
  var typeClassNames = useTypeClassNames({
    types: types,
    classNames: cellClassNames,
    allTypes: cellTypes
  });
  var isHead = types.includes(cellTypes.head);
  var headDragging = isHead && isDragging;
  var headSorted = isHead && isSorted;
  return useClassName(cellClassNames.root, _objectSpread2(_objectSpread2({}, typeClassNames), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, cellClassNames.hovered, isHovered), _defineProperty(_objectSpread2$1, cellClassNames.noBorder, borderType === borderTypes.NONE), _defineProperty(_objectSpread2$1, cellClassNames.horizontalBorder, borderType === borderTypes.HORIZONTAL), _defineProperty(_objectSpread2$1, cellClassNames.headDragging, headDragging), _defineProperty(_objectSpread2$1, cellClassNames.headSorted, headSorted), _defineProperty(_objectSpread2$1, cellClassNames.withRightBorder, withRightBorder), _objectSpread2$1)));
}

function useHeadCheckboxClassName(_ref) {
  var _useClassName;

  var options = _ref.options,
      globalOptions = _ref.globalOptions;
  var baseClassNames = useCellClassName({
    types: [cellTypes.head, cellTypes.checkbox],
    globalOptions: globalOptions
  });
  var isHorizontallyScrolling = options.isHorizontallyScrolling;
  var tableType = globalOptions.tableType;
  var isLeads = tableType === tableTypes.LEADS;
  return useClassName(baseClassNames, (_useClassName = {}, _defineProperty(_useClassName, cellClassNames.checkboxLeads, isLeads), _defineProperty(_useClassName, cellClassNames.checkboxHorizontallyScrolling, isHorizontallyScrolling), _useClassName));
}

function useBodyCheckboxClassName(_ref) {
  var _useClassName;

  var _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options,
      globalOptions = _ref.globalOptions;
  var baseClassNames = useCellClassName({
    types: [cellTypes.body, cellTypes.checkbox],
    globalOptions: globalOptions
  });
  var isUnseen = options.isUnseen,
      isHovered = options.isHovered;
  var tableType = globalOptions.tableType;
  var isLeads = tableType === tableTypes.LEADS;
  return useClassName(baseClassNames, (_useClassName = {}, _defineProperty(_useClassName, cellClassNames.hovered, isHovered), _defineProperty(_useClassName, cellClassNames.checkboxLeads, isLeads), _defineProperty(_useClassName, cellClassNames.checkboxLeadsUnseen, isLeads && isUnseen), _useClassName));
}

/**
 * @typedef {Object} Options
 * @property {boolean} isHorizontallyScrolling - is Table horizontally
 * scrolling.
 * @property {string} tableType - Table type.
 */

/**
 * @typedef {Object} Payload
 * @property {Options} options - options for calculation.
 */

/**
 * @summary Gets classname for checkboxes.
 * @param {Payload} payload - info for calculation.
 * @returns {string} - classname for checkboxes.
 */

function useCheckboxesClassName(_ref) {
  var _useClassName;

  var options = _ref.options;
  var isHorizontallyScrolling = options.isHorizontallyScrolling,
      tableType = options.tableType;
  var isLeads = tableType === tableTypes.LEADS;
  return useClassName(checkboxesClassNames.root, (_useClassName = {}, _defineProperty(_useClassName, checkboxesClassNames.leads, isLeads), _defineProperty(_useClassName, checkboxesClassNames.horizontallyScrolling, isHorizontallyScrolling), _useClassName));
}

/**
 * @typedef {Object} Options
 * @property {boolean} isPlaceholder - is it a placeholder.
 */

/**
 * @typedef {Object} Payload
 * @property {Options} options - options for calculation.
 */

/**
 * @summary Gets head corner classname.
 * @param {Payload} payload - info for calculation.
 * @returns {string} - head corner classname.
 */

function useHeadCornerClassName(_ref) {
  var options = _ref.options;
  var isPlaceholder = options.isPlaceholder;
  return useClassName(headCornerClassNames.root, _defineProperty({}, headCornerClassNames.placeholder, isPlaceholder));
}

/**
 * @summary Gets initial ref: internal or the passed one.
 * @param {Object} passedRef - ref passed by a parent.
 * @returns {Object} - initial ref.
 */

function useInitialRef(passedRef) {
  var internalRef = useRef(null);
  return passedRef !== null && passedRef !== void 0 ? passedRef : internalRef;
}
/**
 * @typedef {Object} Refs
 * @property {Object} rootRef - root node ref.
 * @property {Object} horizontalScrollIndicatorRef - horizontal
 * scroll indicator ref.
 * @property {Object} bodyRefs - body refs container.
 * @property {Object} headRefs - head refs container.
 */

/**
 * @summary Gets table refs and adds them into the ref
 * passed by a parent.
 * @param {Object} ref - ref passed by a parent.
 * @returns {Refs} - table refs.
 */

function useTableRefs(passedRef) {
  var initialRef = useInitialRef(passedRef);
  var rootRef = useRef(null);
  var horizontalScrollIndicatorRef = useRef(null);
  var headRefs = useRef(null);
  var bodyRefs = useRef(null);
  useImperativeHandle(initialRef, function () {
    return {
      get root() {
        return rootRef.current;
      },

      get head() {
        return headRefs.current;
      },

      get body() {
        return bodyRefs.current;
      },

      _scrollBodySections: function _scrollBodySections(index, behaviour) {
        var _this = this;

        return new Promise(function (resolve) {
          var _this$body, _this$body$checkboxes, _this$body$checkboxes2, _this$body2, _this$body2$rows, _this$body2$rows$scro, _this$body3, _this$body3$rowAction, _this$body3$rowAction2;

          _this === null || _this === void 0 ? void 0 : (_this$body = _this.body) === null || _this$body === void 0 ? void 0 : (_this$body$checkboxes = _this$body.checkboxes) === null || _this$body$checkboxes === void 0 ? void 0 : (_this$body$checkboxes2 = _this$body$checkboxes.scrollToItem) === null || _this$body$checkboxes2 === void 0 ? void 0 : _this$body$checkboxes2.call(_this$body$checkboxes, index, behaviour);
          _this === null || _this === void 0 ? void 0 : (_this$body2 = _this.body) === null || _this$body2 === void 0 ? void 0 : (_this$body2$rows = _this$body2.rows) === null || _this$body2$rows === void 0 ? void 0 : (_this$body2$rows$scro = _this$body2$rows.scrollToItem) === null || _this$body2$rows$scro === void 0 ? void 0 : _this$body2$rows$scro.call(_this$body2$rows, index, behaviour);
          _this === null || _this === void 0 ? void 0 : (_this$body3 = _this.body) === null || _this$body3 === void 0 ? void 0 : (_this$body3$rowAction = _this$body3.rowActions) === null || _this$body3$rowAction === void 0 ? void 0 : (_this$body3$rowAction2 = _this$body3$rowAction.scrollToItem) === null || _this$body3$rowAction2 === void 0 ? void 0 : _this$body3$rowAction2.call(_this$body3$rowAction, index, behaviour);
          resolve();
        });
      },
      scrollToItem: function scrollToItem(index, behaviour) {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var _this2$root, _this2$root$scrollTo, _this2$body, _this2$body$rows, _this2$body$rows$stat;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this2._scrollBodySections(index, behaviour);

                case 2:
                  _this2 === null || _this2 === void 0 ? void 0 : (_this2$root = _this2.root) === null || _this2$root === void 0 ? void 0 : (_this2$root$scrollTo = _this2$root.scrollTo) === null || _this2$root$scrollTo === void 0 ? void 0 : _this2$root$scrollTo.call(_this2$root, 0, (_this2 === null || _this2 === void 0 ? void 0 : (_this2$body = _this2.body) === null || _this2$body === void 0 ? void 0 : (_this2$body$rows = _this2$body.rows) === null || _this2$body$rows === void 0 ? void 0 : (_this2$body$rows$stat = _this2$body$rows.state) === null || _this2$body$rows$stat === void 0 ? void 0 : _this2$body$rows$stat.scrollOffset) + scrollOffsetInaccuracy);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    };
  });
  return {
    initialRef: initialRef,
    rootRef: rootRef,
    horizontalScrollIndicatorRef: horizontalScrollIndicatorRef,
    headRefs: headRefs,
    bodyRefs: bodyRefs
  };
}

/**
 * @typedef {Object} Refs
 * @property {Object} rowRef - row ref.
 */

/**
 * @summary Gets head refs and adds them into the ref
 * passed by a parent.
 * @param {Object} ref - ref passed by a parent.
 * @returns {Refs} - head refs.
 */

function useHeadRefs(ref) {
  var rowRef = useRef(null);
  var columnsRef = useRef(null);
  useImperativeHandle(ref, function () {
    return {
      get row() {
        return rowRef.current;
      },

      get columns() {
        return columnsRef.current;
      }

    };
  });
  return {
    rowRef: rowRef,
    columnsRef: columnsRef
  };
}

/**
 * @typedef {Object} Refs
 * @property {Object} checkboxesRef - checkboxes ref.
 * @property {Object} rowsRef - rows ref.
 * @property {Object} rowActionsRef - row actions ref.
 */

/**
 * @summary Gets body refs and adds them into the ref
 * passed by a parent.
 * @param {Object} ref - ref passed by a parent.
 * @returns {Refs} - body refs.
 */

function useBodyRefs(ref) {
  var checkboxesRef = useRef(null);
  var rowsRef = useRef(null);
  var rowActionsRef = useRef(null);
  useImperativeHandle(ref, function () {
    return {
      get checkboxes() {
        return checkboxesRef.current;
      },

      get rows() {
        return rowsRef.current;
      },

      get rowActions() {
        return rowActionsRef.current;
      }

    };
  });
  return {
    checkboxesRef: checkboxesRef,
    rowsRef: rowsRef,
    rowActionsRef: rowActionsRef
  };
}

var prefix = 'cui4-table';
var testAttrs = {
  headCell: "".concat(prefix, "-head-cell"),
  bodyCell: "".concat(prefix, "-body-cell"),
  actionCell: "".concat(prefix, "-action-cell"),
  checkboxCell: "".concat(prefix, "-checkbox-cell"),
  headActionCellIcon: "".concat(prefix, "-head-action-cell-icon"),
  checkbox: "".concat(prefix, "-checkbox"),
  row: "".concat(prefix, "-row"),
  cellTextWrapper: "".concat(prefix, "-cell-text-wrapper"),
  dndStaticOverlay: "".concat(prefix, "-dnd-static-overlay"),
  dndDraggingOverlay: "".concat(prefix, "-dnd-dragging-overlay"),
  dndDroppingOverlay: "".concat(prefix, "-dnd-dropping-overlay"),
  dndColumnLeftBorder: "".concat(prefix, "-dnd-column-left-border"),
  dndColumnRightBorder: "".concat(prefix, "-dnd-column-right-border"),
  columnResizeHandle: "".concat(prefix, "-column-resize-handle"),
  sortingIndicatorWrapper: "".concat(prefix, "-sorting-indicator-wrapper"),
  sortingIndicatorSpinner: "".concat(prefix, "-sorting-indicator-spinner"),
  sortingIndicatorAscIcon: "".concat(prefix, "-sorting-indicator-asc-icon"),
  sortingIndicatorDescIcon: "".concat(prefix, "-sorting-indicator-desc-icon"),
  rowAction: "".concat(prefix, "-row-action"),
  rowActionsPopover: "".concat(prefix, "-row-actions-popover"),
  rowActionsPopoverTrigger: "".concat(prefix, "-row-actions-popover-trigger"),
  rowActionsSeparator: "".concat(prefix, "-row-actions-separator"),
  headMessage: "".concat(prefix, "-head-message")
};

function HeadMessages(_ref) {
  var _ref$messages = _ref.messages,
      messages = _ref$messages === void 0 ? [] : _ref$messages;
  return messages.map(function (_ref2, index) {
    var text = _ref2.text,
        color = _ref2.color,
        icon = _ref2.icon;

    if (!text) {
      return null;
    }

    return /*#__PURE__*/React__default.createElement(Message, {
      visible: true,
      alternative: true,
      key: index,
      color: color,
      icon: icon
    }, text);
  });
}

HeadMessages.propTypes = {
  messages: headMessagesPropTypes
};

function CheckboxCell(_ref) {
  var className = _ref.className,
      checked = _ref.checked,
      disabled = _ref.disabled,
      indeterminate = _ref.indeterminate,
      onCheckboxChange = _ref.onCheckboxChange;
  return /*#__PURE__*/React__default.createElement("div", {
    className: className,
    onClick: onCheckboxChange
  }, /*#__PURE__*/React__default.createElement(Checkbox, {
    checked: checked,
    disabled: disabled,
    indeterminate: indeterminate,
    onChange: onCheckboxChange
  }));
}

CheckboxCell.propTypes = {
  className: PropTypes.string.isRequired,
  checked: PropTypes.bool.isRequired,
  disabled: PropTypes.bool,
  indeterminate: PropTypes.bool,
  onCheckboxChange: PropTypes.func.isRequired
};
var CheckboxCell$1 = /*#__PURE__*/memo(CheckboxCell);

function ActionCell(_ref) {
  var type = _ref.type,
      globalOptions = _ref.globalOptions,
      onClick = _ref.onClick,
      children = _ref.children;
  var className = useCellClassName({
    types: [type, cellTypes.action],
    globalOptions: globalOptions
  });
  return /*#__PURE__*/React__default.createElement("div", {
    className: className,
    onClick: onClick
  }, children);
}

ActionCell.propTypes = {
  type: PropTypes.oneOf([cellTypes.head, cellTypes.body]),
  globalOptions: globalOptionsPropTypes,
  onClick: PropTypes.func,
  children: PropTypes.node
};

function HeadCorner(_ref) {
  var globalOptions = _ref.globalOptions;
  var onHeadCornerClick = globalOptions.handlers.onHeadCornerClick;
  var isPlaceholder = onHeadCornerClick === null || onHeadCornerClick === void 0 ? void 0 : onHeadCornerClick.isPlaceholder;
  var className = useHeadCornerClassName({
    options: {
      isPlaceholder: isPlaceholder
    }
  });
  var onClick = useCallback(function (event) {
    return onHeadCornerClick({
      event: event
    });
  }, [onHeadCornerClick]);
  return /*#__PURE__*/React__default.createElement("div", {
    className: className
  }, /*#__PURE__*/React__default.createElement(ActionCell, {
    type: cellTypes.head,
    onClick: onClick,
    globalOptions: globalOptions
  }, !(onHeadCornerClick !== null && onHeadCornerClick !== void 0 && onHeadCornerClick.isPlaceholder) && /*#__PURE__*/React__default.createElement(Icon, {
    icon: "cogs",
    size: "s",
    color: "black-64"
  })));
}

HeadCorner.propTypes = {
  globalOptions: globalOptionsPropTypes
};

/**
 * @summary Gets the object with the decimal values from
 * the string values object recursively.
 * @param {Object} obj - object with the string values possibly
 * nested into another objects.
 * @returns {Object} - the object with the decimal values.
 */
function getDecimalObject(obj) {
  return Object.entries(obj).reduce(function (acc, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[0],
        value = _ref2[1];

    if (_typeof(value) === 'object') {
      return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, name, getDecimalObject(value)));
    }

    var convertedDecimal = parseInt(value, 10);

    if (isNaN(convertedDecimal)) {
      return acc;
    }

    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, name, convertedDecimal));
  }, {});
}

var _checkboxesStyle;
var DEFAULT = tableTypes.DEFAULT,
    LEADS = tableTypes.LEADS;
var borderWidth = 1; // Must be the same as in .cui4-table__cell in convention-ui-css

var cellStyle = {
  height: '32px',
  minWidth: '64px',
  maxWidth: '800px'
};
var cellStyleDecimal = getDecimalObject(cellStyle);
var headCellStyle = {
  // adding 1px from the top and the bottom border
  height: "".concat(cellStyleDecimal.height + 2, "px")
};
var headCellStyleDecimal = getDecimalObject(headCellStyle);
var rowActionsStyle = {
  width: '33px'
};
var rowActionsStyleDecimal = getDecimalObject(rowActionsStyle);
var checkboxesStyle = (_checkboxesStyle = {}, _defineProperty(_checkboxesStyle, DEFAULT, {
  width: '33px'
}), _defineProperty(_checkboxesStyle, LEADS, {
  width: '41px'
}), _checkboxesStyle);
var checkboxesStyleDecimal = getDecimalObject(checkboxesStyle);
var rowActionsTriggerStyle = {
  width: '33px'
};
var rowActionStyle = {
  minWidth: '200px'
};
var infiniteLoaderStyle = {
  // Must be the same as $infinite-loader-height in CUI CSS
  height: '37px'
};
var resizeHandleRightOffset = -3;
var stickyColumnStyle = {
  zIndex: 1,
  overflow: 'visible'
};
var resizeHandleStyle = {
  width: '5px'
};
var resizeHandleStyleDecimal = getDecimalObject(resizeHandleStyle);

/**
 * @typedef {Object} Payload
 * @property {string} width - checkboxes width.
 */

/**
 * @summary Gets checkboxes style.
 * @param {Payload} payload - info for calculation.
 * @returns {Object} - checkboxes style.
 */

function useCheckboxesStyle(_ref) {
  var width = _ref.width;
  return useMemo(function () {
    return _objectSpread2(_objectSpread2({}, stickyColumnStyle), {}, {
      position: cssProps.position.sticky,
      left: 0,
      width: width
    });
  }, [width]);
}

var variables = createCommonjsModule(function (module, exports) {
exports.__esModule = true;
exports.spacings = exports.fonts = exports.elevations = exports.colors = void 0;
exports.colors = {
    "white": "rgb(255,255,255)",
    "white64": "rgba(255,255,255,.64)",
    "white32": "rgba(255,255,255,.32)",
    "white16": "rgba(255,255,255,.16)",
    "black": "rgb(38,41,44)",
    "blackShade16Opaque": "#202225",
    "blackShade16": "rgb(32,34,37)",
    "black88Opaque": "#404346",
    "black88": "rgba(38,41,44,.88)",
    "black64Opaque": "#747678",
    "black64": "rgba(38,41,44,.64)",
    "black32Opaque": "#b9babb",
    "black32": "rgba(38,41,44,.32)",
    "black24Opaque": "#cbcccd",
    "black24": "rgba(38,41,44,.24)",
    "black16Opaque": "#dcdddd",
    "black16": "rgba(38,41,44,.16)",
    "black12Opaque": "#e5e5e5",
    "black12": "rgba(38,41,44,.12)",
    "black8Opaque": "#eeeeee",
    "black8": "rgba(38,41,44,.08)",
    "black5Opaque": "#f4f4f4",
    "black5": "rgba(38,41,44,.05)",
    "black4Opaque": "#f7f7f7",
    "black4": "rgba(38,41,44,.04)",
    "green": "rgb(8,167,66)",
    "greenShade16Opaque": "#0c923e",
    "greenShade16": "rgb(12,146,62)",
    "green88Opaque": "#26b259",
    "green88": "rgba(8,167,66,.88)",
    "green64Opaque": "#61c786",
    "green64": "rgba(8,167,66,.64)",
    "green32Opaque": "#b0e2c2",
    "green32": "rgba(8,167,66,.32)",
    "green24Opaque": "#c4ead2",
    "green24": "rgba(8,167,66,.24)",
    "green16Opaque": "#d7f1e1",
    "green16": "rgba(8,167,66,.16)",
    "green12Opaque": "#e1f4e8",
    "green12": "rgba(8,167,66,.12)",
    "green8Opaque": "#ecf8f0",
    "green8": "rgba(8,167,66,.08)",
    "blue": "rgb(49,122,226)",
    "blueShade16Opaque": "#2f6cc5",
    "blueShade16": "rgb(47,108,197)",
    "blue88Opaque": "#4a8ae6",
    "blue88": "rgba(49,122,226,.88)",
    "blue64Opaque": "#7baaed",
    "blue64": "rgba(49,122,226,.64)",
    "blue32Opaque": "#bdd4f5",
    "blue32": "rgba(49,122,226,.32)",
    "blue24Opaque": "#cedff8",
    "blue24": "rgba(49,122,226,.24)",
    "blue16Opaque": "#deeafa",
    "blue16": "rgba(49,122,226,.16)",
    "blue12Opaque": "#e6effb",
    "blue12": "rgba(49,122,226,.12)",
    "blue8Opaque": "#eff5fd",
    "blue8": "rgba(49,122,226,.08)",
    "red": "rgb(249,72,57)",
    "redShade16Opaque": "#d64336",
    "redShade16": "rgb(214,67,54)",
    "red88Opaque": "#fa5e51",
    "red88": "rgba(249,72,57,.88)",
    "red64Opaque": "#fb8a80",
    "red64": "rgba(249,72,57,.64)",
    "red32Opaque": "#fdc4bf",
    "red32": "rgba(249,72,57,.32)",
    "red24Opaque": "#fed3d0",
    "red24": "rgba(249,72,57,.24)",
    "red16Opaque": "#fee2df",
    "red16": "rgba(249,72,57,.16)",
    "red12Opaque": "#fee9e7",
    "red12": "rgba(249,72,57,.12)",
    "red8Opaque": "#fff1f0",
    "red8": "rgba(249,72,57,.08)",
    "yellow": "rgb(255,204,0)",
    "yellowShade16Opaque": "#ddb207",
    "yellowShade16": "rgb(221,178,7)",
    "yellow64Opaque": "#ffdf5c",
    "yellow64": "rgba(255,204,0,.64)",
    "yellow16Opaque": "#fff7d6",
    "yellow16": "rgba(255,204,0,.16)",
    "purple": "rgb(114,30,169)",
    "purpleShade16Opaque": "#661f95",
    "purpleShade16": "rgb(102,31,149)",
    "purple64Opaque": "#a56fc8",
    "purple64": "rgba(114,30,169,.64)",
    "purple16Opaque": "#e8dbf1",
    "purple16": "rgba(114,30,169,.16)",
    "highlightYellow": "rgb(255,245,112)",
    "noteYellow": "rgb(255,252,220)",
    "orchid": "#c762ce",
    "steel": "#8ba5af",
    "sky": "#42b7fc",
    "turquoise": "#00d3e4",
    "lime": "#69c97d",
    "kiwi": "#a3d776",
    "lemon": "#ffed27",
    "apricot": "#ffb32b",
    "salmon": "#ff827b",
    "flamingo": "#ff5592"
};
exports.elevations = {
    "elevation00": "none",
    "elevation01": "0 0 1px 1px rgba(0,0,0,.05),0 1px 2px -2px rgba(0,0,0,.06),0 1px 3px 0 rgba(0,0,0,.07)",
    "elevation02": "0 0 1px 0 rgba(0,0,0,.16),0 2px 2px 0 rgba(0,0,0,.05),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.1)",
    "elevation03": "0 0 2px 0 rgba(0,0,0,.16),0 3px 4px 0 rgba(0,0,0,.05),0 3px 3px -2px rgba(0,0,0,.06),0 1px 8px 0 rgba(0,0,0,.1)",
    "elevation04": "0 0 1px 1px rgba(0,0,0,.05),0 -1px 2px -2px rgba(0,0,0,.06),0 -1px 3px 0 rgba(0,0,0,.07)",
    "elevation08": "0 0 2px 0 rgba(0,0,0,.24),0 8px 10px 1px rgba(0,0,0,.05),0 3px 14px 2px rgba(0,0,0,.06),0 5px 5px -3px rgba(0,0,0,.1)",
    "elevation16": "0 0 2px 0 rgba(0,0,0,.24),0 16px 24px 2px rgba(0,0,0,.05),0 6px 30px 5px rgba(0,0,0,.06),0 8px 10px -5px rgba(0,0,0,.1)",
    "elevation24": "0 0 2px 0 rgba(0,0,0,.24),0 24px 38px 3px rgba(0,0,0,.05),0 9px 46px 8px rgba(0,0,0,.06),0 11px 15px -7px rgba(0,0,0,.1)"
};
exports.fonts = {
    "fontFamily": "'Source Sans Pro',sans-serif",
    "fontFamilyMonospace": "'Menlo','Consolas','Courier',monospace",
    "fontWeightNormal": "400",
    "fontWeightSemi": "600",
    "fontWeightBold": "600",
    "fontSizeXxl": "27px",
    "fontSizeXl": "23px",
    "fontSizeL": "18px",
    "fontSizeM": "15px",
    "fontSizeS": "13px",
    "fontSizeXs": "11px",
    "lineHeightXxl": "32px",
    "lineHeightXl": "28px",
    "lineHeightL": "24px",
    "lineHeightM": "20px",
    "lineHeightS": "16px",
    "lineHeightXs": "16px",
    "letterSpacingL": ".04em",
    "letterSpacingM": ".03em",
    "fontTitleXxl": "400 27px/32px 'Source Sans Pro',sans-serif",
    "fontTitleXl": "400 23px/28px 'Source Sans Pro',sans-serif",
    "fontTitleL": "600 18px/24px 'Source Sans Pro',sans-serif",
    "fontTitleM": "600 15px/20px 'Source Sans Pro',sans-serif",
    "fontBodyL": "400 18px/24px 'Source Sans Pro',sans-serif",
    "fontBody": "400 15px/20px 'Source Sans Pro',sans-serif",
    "fontBodyS": "400 13px/16px 'Source Sans Pro',sans-serif",
    "fontButton": "600 15px/20px 'Source Sans Pro',sans-serif",
    "fontButtonS": "600 13px/16px 'Source Sans Pro',sans-serif",
    "fontCaption": "600 15px/20px 'Source Sans Pro',sans-serif",
    "fontCaptionS": "600 13px/16px 'Source Sans Pro',sans-serif",
    "fontBadge": "600 11px/16px 'Source Sans Pro',sans-serif",
    "fontMonospace": "400 13px/16px 'Menlo','Consolas','Courier',monospace"
};
exports.spacings = {
    "spacingXs": "4px",
    "spacingS": "8px",
    "spacingM": "16px",
    "spacingL": "24px",
    "spacingXl": "32px",
    "spacingXxl": "40px"
};
});

unwrapExports(variables);
var variables_1 = variables.spacings;
var variables_2 = variables.fonts;
var variables_3 = variables.elevations;
var variables_4 = variables.colors;

var zeroRight = '0px';
/**
 * @typedef {Object} GetHeightPayload
 * @property {boolean} isResizing - is a column being resized.
 * @property {number} rootRectHeight - root rect height.
 */

/**
 * @summary Gets handle's height.
 * @param {GetHeightPayload} payload - info for calculation.
 * @returns {string} - handle's height.
 */

function getHeight(_ref) {
  var isResizing = _ref.isResizing,
      rootRectHeight = _ref.rootRectHeight;

  if (isResizing) {
    return "".concat(rootRectHeight, "px");
  }

  return cellStyle.height;
}
/**
 * @typedef {Object} GetRightPayload
 * @property {boolean} isResizing - is a column being resized.
 * @property {number} resizeDifferenceX - horizontal resize difference.
 * @property {string} isOnRightEdge - is the handle on the right
 * edge of the table.
 */

/**
 * @summary Gets handle's right property.
 * @param {GetRightPayload} payload - info for calculation.
 * @returns {string} - handle's right property.
 */

function getRight(_ref2) {
  var isResizing = _ref2.isResizing,
      resizeDifferenceX = _ref2.resizeDifferenceX,
      isOnRightEdge = _ref2.isOnRightEdge;

  if (isResizing) {
    return "".concat(resizeHandleRightOffset - resizeDifferenceX, "px");
  }

  if (isOnRightEdge) {
    return zeroRight;
  }

  return "".concat(resizeHandleRightOffset, "px");
}
/**
 * @typedef {Object} GetBackgroundColorPayload
 * @property {boolean} isResizing - is a column being resized.
 */

/**
 * @summary Gets handle's background color.
 * @param {GetBackgroundColorPayload} payload - info for calculation.
 * @returns {string|undefined} - handle's background color.
 */

function getBackgroundColor(_ref3) {
  var isResizing = _ref3.isResizing;

  if (isResizing) {
    return variables_4.blue;
  } // eslint-disable-next-line no-undefined


  return undefined;
}
/**
 * @typedef {Object} UseResizeHandleStylePayload
 * @property {boolean} isResizing - is a column being resized.
 * @property {number} resizeDifferenceX - horizontal resize difference.
 * @property {number} rootRectHeight - root rect height.
 */

/**
 * @typedef {Object} UseResizeHandleStyleResult
 * @property {string} height - height.
 * @property {string} right - right property.
 * @property {string} backgroundColor - background color.
 * @property {string} isOnRightEdge - is the handle on the right
 * edge of the table.
 */

/**
 * @summary Gets handle's style property.
 * @param {UseResizeHandleStylePayload} payload - info for calculation.
 * @returns {UseResizeHandleStyleResult} - handle's style property.
 */

function useResizeHandleStyle(_ref4) {
  var isResizing = _ref4.isResizing,
      resizeDifferenceX = _ref4.resizeDifferenceX,
      rootRectHeight = _ref4.rootRectHeight,
      isOnRightEdge = _ref4.isOnRightEdge;
  return useMemo(function () {
    var height = getHeight({
      isResizing: isResizing,
      rootRectHeight: rootRectHeight
    });
    var right = getRight({
      isResizing: isResizing,
      resizeDifferenceX: resizeDifferenceX,
      isOnRightEdge: isOnRightEdge
    });
    var backgroundColor = getBackgroundColor({
      isResizing: isResizing
    });
    return {
      height: height,
      right: right,
      backgroundColor: backgroundColor
    };
  }, [isResizing, resizeDifferenceX, rootRectHeight]);
}

/**
 * @typedef {Object} Payload
 * @property {boolean} isPlaceholder - is it a placeholder.
 */

/**
 * @summary Gets sticky column classname.
 * @param {Payload} payload - info for calculation.
 * @returns {string} - sticky column classname.
 */

function useRowActionsStyle() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$isPlaceholder = _ref.isPlaceholder,
      isPlaceholder = _ref$isPlaceholder === void 0 ? false : _ref$isPlaceholder;

  var position = isPlaceholder ? cssProps.position.relative : cssProps.position.sticky;
  return useMemo(function () {
    return _objectSpread2(_objectSpread2({}, stickyColumnStyle), {}, {
      position: position,
      right: 0,
      width: rowActionsTriggerStyle.width
    });
  }, [position]);
}

var BEFORE = dropDirections.BEFORE,
    AFTER = dropDirections.AFTER,
    NONE = dropDirections.NONE;
/**
 * @typedef {Object} DOMRect
 * @property {number} left - left coordinate.
 */

/**
 * @typedef {Object} Offset
 * @property {number} x - x coordinate.
 */

/**
 * @typedef {Object} GetDropDirectionPayload
 * @property {DOMRect} rect - head cell DOM rect.
 * @property {Offset} clientOffset - cursor coordinates.
 */

/**
 * @summary Gets drop direction.
 * @param {GetDropDirectionPayload} payload - coordinates to calculate
 * the drop direction.
 * @returns {string} - drop direction.
 */

function getDropDirection(_ref) {
  var rect = _ref.rect,
      clientOffset = _ref.clientOffset;
  var width = rect.width;
  var middleX = width / 2;
  var clientOffsetDifference = (clientOffset === null || clientOffset === void 0 ? void 0 : clientOffset.x) - rect.left;

  if (clientOffsetDifference <= middleX) {
    return BEFORE;
  }

  if (clientOffsetDifference > middleX) {
    return AFTER;
  }

  return NONE;
}

/**
 * @typedef {Object} DOMRect
 * @property {number} left - left coordinate.
 */

/**
 * @typedef {Object} Offset
 * @property {number} x - x coordinate.
 */

/**
 * @typedef {Object} UseDropDirectionPayload
 * @property {DOMRect} rect - head cell DOM rect.
 * @property {Offset} clientOffset - cursor coordinates.
 */

/**
 * @summary useMemo wrapper for getDropDirection.
 * @param {UseDropDirectionPayload} payload - coordinates to calculate
 * the drop direction.
 * @returns {string} - drop direction.
 */

function useDropDirection(_ref) {
  var rect = _ref.rect,
      clientOffset = _ref.clientOffset;
  return useMemo(function () {
    return getDropDirection({
      rect: rect,
      clientOffset: clientOffset
    });
  }, [rect.width, rect.left, clientOffset === null || clientOffset === void 0 ? void 0 : clientOffset.x]);
}

var colors = {
	"$color-white-hex": "#ffffff",
	"$color-white-rgba": "rgb(255,255,255)",
	"$color-white-rgba-64": "rgba(255,255,255,.64)",
	"$color-white-rgba-32": "rgba(255,255,255,.32)",
	"$color-white-rgba-16": "rgba(255,255,255,.16)",
	"$color-black-hex": "#26292c",
	"$color-black-rgba": "rgb(38,41,44)",
	"$color-black-hex-shade-16": "#202225",
	"$color-black-rgba-shade-16": "rgb(32,34,37)",
	"$color-black-hex-88": "#404346",
	"$color-black-rgba-88": "rgba(38,41,44,.88)",
	"$color-black-hex-64": "#747678",
	"$color-black-rgba-64": "rgba(38,41,44,.64)",
	"$color-black-hex-32": "#b9babb",
	"$color-black-rgba-32": "rgba(38,41,44,.32)",
	"$color-black-hex-24": "#cbcccd",
	"$color-black-rgba-24": "rgba(38,41,44,.24)",
	"$color-black-hex-16": "#dcdddd",
	"$color-black-rgba-16": "rgba(38,41,44,.16)",
	"$color-black-hex-12": "#e5e5e5",
	"$color-black-rgba-12": "rgba(38,41,44,.12)",
	"$color-black-hex-8": "#eeeeee",
	"$color-black-rgba-8": "rgba(38,41,44,.08)",
	"$color-black-hex-5": "#f4f4f4",
	"$color-black-rgba-5": "rgba(38,41,44,.05)",
	"$color-black-hex-4": "#f7f7f7",
	"$color-black-rgba-4": "rgba(38,41,44,.04)",
	"$color-green-hex": "#08a742",
	"$color-green-rgba": "rgb(8,167,66)",
	"$color-green-hex-shade-16": "#0c923e",
	"$color-green-rgba-shade-16": "rgb(12,146,62)",
	"$color-green-hex-88": "#26b259",
	"$color-green-rgba-88": "rgba(8,167,66,.88)",
	"$color-green-hex-64": "#61c786",
	"$color-green-rgba-64": "rgba(8,167,66,.64)",
	"$color-green-hex-32": "#b0e2c2",
	"$color-green-rgba-32": "rgba(8,167,66,.32)",
	"$color-green-hex-24": "#c4ead2",
	"$color-green-rgba-24": "rgba(8,167,66,.24)",
	"$color-green-hex-16": "#d7f1e1",
	"$color-green-rgba-16": "rgba(8,167,66,.16)",
	"$color-green-hex-12": "#e1f4e8",
	"$color-green-rgba-12": "rgba(8,167,66,.12)",
	"$color-green-hex-8": "#ecf8f0",
	"$color-green-rgba-8": "rgba(8,167,66,.08)",
	"$color-blue-hex": "#317ae2",
	"$color-blue-rgba": "rgb(49,122,226)",
	"$color-blue-hex-shade-16": "#2f6cc5",
	"$color-blue-rgba-shade-16": "rgb(47,108,197)",
	"$color-blue-hex-88": "#4a8ae6",
	"$color-blue-rgba-88": "rgba(49,122,226,.88)",
	"$color-blue-hex-64": "#7baaed",
	"$color-blue-rgba-64": "rgba(49,122,226,.64)",
	"$color-blue-hex-32": "#bdd4f5",
	"$color-blue-rgba-32": "rgba(49,122,226,.32)",
	"$color-blue-hex-24": "#cedff8",
	"$color-blue-rgba-24": "rgba(49,122,226,.24)",
	"$color-blue-hex-16": "#deeafa",
	"$color-blue-rgba-16": "rgba(49,122,226,.16)",
	"$color-blue-hex-12": "#e6effb",
	"$color-blue-rgba-12": "rgba(49,122,226,.12)",
	"$color-blue-hex-8": "#eff5fd",
	"$color-blue-rgba-8": "rgba(49,122,226,.08)",
	"$color-red-hex": "#f94839",
	"$color-red-rgba": "rgb(249,72,57)",
	"$color-red-hex-shade-16": "#d64336",
	"$color-red-rgba-shade-16": "rgb(214,67,54)",
	"$color-red-hex-88": "#fa5e51",
	"$color-red-rgba-88": "rgba(249,72,57,.88)",
	"$color-red-hex-64": "#fb8a80",
	"$color-red-rgba-64": "rgba(249,72,57,.64)",
	"$color-red-hex-32": "#fdc4bf",
	"$color-red-rgba-32": "rgba(249,72,57,.32)",
	"$color-red-hex-24": "#fed3d0",
	"$color-red-rgba-24": "rgba(249,72,57,.24)",
	"$color-red-hex-16": "#fee2df",
	"$color-red-rgba-16": "rgba(249,72,57,.16)",
	"$color-red-hex-12": "#fee9e7",
	"$color-red-rgba-12": "rgba(249,72,57,.12)",
	"$color-red-hex-8": "#fff1f0",
	"$color-red-rgba-8": "rgba(249,72,57,.08)",
	"$color-yellow-hex": "#ffcc00",
	"$color-yellow-rgba": "rgb(255,204,0)",
	"$color-yellow-hex-shade-16": "#ddb207",
	"$color-yellow-rgba-shade-16": "rgb(221,178,7)",
	"$color-yellow-hex-64": "#ffdf5c",
	"$color-yellow-rgba-64": "rgba(255,204,0,.64)",
	"$color-yellow-hex-16": "#fff7d6",
	"$color-yellow-rgba-16": "rgba(255,204,0,.16)",
	"$color-purple-hex": "#721ea9",
	"$color-purple-rgba": "rgb(114,30,169)",
	"$color-purple-hex-shade-16": "#661f95",
	"$color-purple-rgba-shade-16": "rgb(102,31,149)",
	"$color-purple-hex-64": "#a56fc8",
	"$color-purple-rgba-64": "rgba(114,30,169,.64)",
	"$color-purple-hex-16": "#e8dbf1",
	"$color-purple-rgba-16": "rgba(114,30,169,.16)",
	"$color-highlight-yellow-hex": "#fff570",
	"$color-highlight-yellow-rgba": "rgb(255,245,112)",
	"$color-note-yellow-hex": "#fffcdc",
	"$color-note-yellow-rgba": "rgb(255,252,220)",
	"$color-orchid-hex": "#c762ce",
	"$color-steel-hex": "#8ba5af",
	"$color-sky-hex": "#42b7fc",
	"$color-turquoise-hex": "#00d3e4",
	"$color-lime-hex": "#69c97d",
	"$color-kiwi-hex": "#a3d776",
	"$color-lemon-hex": "#ffed27",
	"$color-apricot-hex": "#ffb32b",
	"$color-salmon-hex": "#ff827b",
	"$color-flamingo-hex": "#ff5592"
};

var BEFORE$1 = dropDirections.BEFORE,
    AFTER$1 = dropDirections.AFTER;
var possibleDirections = [BEFORE$1, AFTER$1];
var xOffset = '-2px';
var defaultStyles = {
  position: 'absolute',
  top: 0,
  zIndex: zIndexes.columnDndBorder,
  width: '3px',
  backgroundColor: colors['$color-blue-hex']
};
/**
 * @typedef {Object} GetDisplayPayload
 * @property {boolean} isDropping - is column dropping.
 * @property {string} dropDirection - drop direction.
 */

/**
 * @summary Gets display property.
 * @param {GetDisplayPayload} payload - info to calculate display property.
 * @returns {string} - display property.
 */

function getDisplay(_ref) {
  var isDropping = _ref.isDropping,
      dropDirection = _ref.dropDirection;

  if (isDropping && possibleDirections.includes(dropDirection)) {
    return 'block';
  }

  return 'none';
}
/**
 * @typedef {Object} GetXCoordinatesPayload
 * @property {string} dropDirection - drop direction.
 */

/**
 * @typedef {Object} GetXCoordinatesResult
 * @property {string} [left] - left coordinate.
 * @property {string} [right] - right coordinate.
 */

/**
 * @summary Gets x coordinates.
 * @param {GetXCoordinatesPayload} payload - info to calculate x coordinates.
 * @returns {GetXCoordinatesResult} - x coordinates.
 */

function getXCoordinates(_ref2) {
  var dropDirection = _ref2.dropDirection;

  if (dropDirection === BEFORE$1) {
    return {
      left: xOffset
    };
  }

  if (dropDirection === AFTER$1) {
    return {
      right: xOffset
    };
  }

  return {};
}
/**
 * @typedef {Object} GetStylePayload
 * @property {boolean} isDropping - is column dropping.
 * @property {string} dropDirection - drop direction.
 * @property {string} height - column's dnd border height in px.
 */

/**
 * @summary Gets column's dnd style.
 * @param {GetStylePayload} payload - info to calculate style prop.
 * @returns {Object} - column's dnd style.
 */

function getStyle(_ref3) {
  var isDropping = _ref3.isDropping,
      dropDirection = _ref3.dropDirection,
      height = _ref3.height;
  var display = getDisplay({
    isDropping: isDropping,
    dropDirection: dropDirection
  });
  var xCoordinates = getXCoordinates({
    dropDirection: dropDirection
  });
  return _objectSpread2(_objectSpread2(_objectSpread2({}, defaultStyles), xCoordinates), {}, {
    display: display,
    height: height
  });
}
/**
 * @summary useMemo wrapper for getStyle.
 * @param {GetStylePayload} payload - info to calculate style prop.
 * @returns {Object} - column's dnd style.
 */

function useDndColumnBorderStyle(_ref4) {
  var isDropping = _ref4.isDropping,
      dropDirection = _ref4.dropDirection,
      height = _ref4.height;
  return useMemo(function () {
    return getStyle({
      isDropping: isDropping,
      dropDirection: dropDirection,
      height: height
    });
  }, [isDropping, dropDirection, height]);
}

/**
 * @typedef {Object} GetTransformResult
 * @property {string} [transform] - transform property.
 */

/**
 * @summary Gets transform property.
 * @param {string} translateX - translateX in px.
 * @returns {GetTransformResult} - transform property inside an object.
 */

function getTransform(translateX) {
  if (translateX) {
    return {
      transform: "translateX(".concat(translateX, ")")
    };
  }

  return {};
}
/**
 * @summary Gets style property.
 * @param {Object} styles - passed styles.
 * @returns {Object} - style property.
 */

function getStyle$1(styles) {
  var translateX = styles.translateX;
  var transform = getTransform(translateX);
  return _objectSpread2(_objectSpread2({}, styles), transform);
}
/**
 * @summary useMemo wrapper for getStyle.
 * @param {Object} styles - passed styles.
 * @returns {Object} - style property.
 */

function useDndColumnOverlayStyle() {
  var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return useMemo(function () {
    return getStyle$1(styles);
  }, [styles]);
}

var defaultTranslateX = '0px';
/**
 * @typedef {Object} Offset
 * @property {number} x - x coordinate.
 */

/**
 * @typedef {Object} DOMRect
 * @property {number} left - left coordinate.
 * @property {number} right - right coordinate.
 */

/**
 * @typedef {Object} GetAreOffsetsOkPayload
 * @property {Offset} clientOffset - cursor coordinates.
 * @property {Offset} initialOffset - initial cursor coordinates.
 * @property {Offset} differenceFromInitialOffset -
 * difference between the current and the initial cursor coordinates.
 */

/**
 * @summary Checks are offsets ok or not.
 * @param {GetAreOffsetsOkPayload} payload - info to check if offsets are ok.
 * @returns {boolean} - are offsets ok or not.
 */

function getAreOffsetsOk(_ref) {
  var clientOffset = _ref.clientOffset,
      initialOffset = _ref.initialOffset,
      differenceFromInitialOffset = _ref.differenceFromInitialOffset;
  return !!(clientOffset && initialOffset && differenceFromInitialOffset);
}
/**
 * @typedef {Object} GetCellOffsetPayload
 * @property {Offset} initialOffset - initial cursor coordinates.
 * @property {DOMRect} rect - head cell DOM rect.
 */

/**
 * @summary Gets cell's left offset.
 * @param {GetCellOffsetPayload} payload - coordinates to calculate
 * the cell's left offset.
 * @returns {number} - cell's left offset.
 */

function getCellLeftOffset(_ref2) {
  var initialOffset = _ref2.initialOffset,
      rect = _ref2.rect;
  return initialOffset.x - rect.left;
}
/**
 * @summary Gets cell's right offset.
 * @param {GetCellOffsetPayload} payload - coordinates to calculate
 * the cell's right offset.
 * @returns {number} - cell's right offset.
 */

function getCellRightOffset(_ref3) {
  var initialOffset = _ref3.initialOffset,
      rect = _ref3.rect;
  return rect.right - initialOffset.x;
}
/**
 * @typedef {Object} GetLeftEdgeXPayload
 * @property {DOMRect} rootRect - table's root DOM rect.
 * @property {number} cellLeftOffset - cell's left offset.
 * @property {boolean} selectable - is the table selectable.
 * @property {string} tableType - table type.
 */

/**
 * @summary Gets left edge X coordinate.
 * @param {GetLeftEdgeXPayload} payload - info to calculate
 * the left edge X coordinate.
 * @returns {number} - left edge X coordinate.
 */

function getLeftEdgeX(_ref4) {
  var rootRect = _ref4.rootRect,
      cellLeftOffset = _ref4.cellLeftOffset,
      selectable = _ref4.selectable,
      tableType = _ref4.tableType;
  var base = rootRect.left + borderWidth + cellLeftOffset;

  if (selectable) {
    return base + checkboxesStyleDecimal[tableType].width;
  }

  return base;
}
/**
 * @typedef {Object} GetRightEdgeXPayload
 * @property {number} lastColumnRight - last column right coordinate.
 * @property {number} cellRightOffset - cell's right offset.
 */

/**
 * @summary Gets right edge X coordinate.
 * @param {GetRightEdgeXPayload} payload - info to calculate
 * the right edge X coordinate.
 * @returns {number} - right edge X coordinate.
 */

function getRightEdgeX(_ref5) {
  var lastColumnRight = _ref5.lastColumnRight,
      cellRightOffset = _ref5.cellRightOffset;
  return lastColumnRight - cellRightOffset;
}
/**
 * @typedef {Object} GetTranslateXPayload
 * @property {boolean} isDragging - is the column dragging.
 * @property {DOMRect} rect - head cell DOM rect.
 * @property {DOMRect} rootRect - table's root DOM rect.
 * @property {number} lastColumnRight - last column right coordinate.
 * @property {Offset} clientOffset - cursor coordinates.
 * @property {Offset} initialOffset - initial cursor coordinates.
 * @property {Offset} differenceFromInitialOffset -
 * difference between the current and the initial cursor coordinates.
 * @property {boolean} selectable - is the table selectable.
 * @property {string} tableType - table type.
 */

/**
 * @summary Gets dragging overlay's translateX to be used in CSS transform.
 * @param {GetTranslateXPayload} payload - info to calculate translateX.
 * @returns {string} - dragging overlay's translateX to be used in
 * CSS transform.
 */

function getTranslateX(_ref6) {
  var isDragging = _ref6.isDragging,
      rect = _ref6.rect,
      rootRect = _ref6.rootRect,
      lastColumnRight = _ref6.lastColumnRight,
      clientOffset = _ref6.clientOffset,
      initialOffset = _ref6.initialOffset,
      differenceFromInitialOffset = _ref6.differenceFromInitialOffset,
      selectable = _ref6.selectable,
      tableType = _ref6.tableType;
  var areOffsetsOk = getAreOffsetsOk({
    clientOffset: clientOffset,
    initialOffset: initialOffset,
    differenceFromInitialOffset: differenceFromInitialOffset
  });

  if (!isDragging || !areOffsetsOk) {
    return defaultTranslateX;
  }

  if (differenceFromInitialOffset.x < 0) {
    var cellLeftOffset = getCellLeftOffset({
      initialOffset: initialOffset,
      rect: rect
    });
    var leftEdgeX = getLeftEdgeX({
      rootRect: rootRect,
      cellLeftOffset: cellLeftOffset,
      selectable: selectable,
      tableType: tableType
    });

    if (clientOffset.x <= leftEdgeX) {
      return "-".concat(initialOffset.x - leftEdgeX, "px");
    }
  }

  if (differenceFromInitialOffset.x > 0) {
    var cellRightOffset = getCellRightOffset({
      initialOffset: initialOffset,
      rect: rect
    });
    var rightEdgeX = getRightEdgeX({
      lastColumnRight: lastColumnRight,
      cellRightOffset: cellRightOffset
    });

    if (clientOffset.x >= rightEdgeX) {
      return "".concat(lastColumnRight - initialOffset.x - cellRightOffset, "px");
    }
  }

  return "".concat(differenceFromInitialOffset.x, "px");
}
/**
 * @typedef {Object && GetTranslateXPayload} UseDraggingOverlayPayload
 */

/**
 * @typedef {Object} UseDraggingOverlayResult
 * @property {string} draggingOverlayTranslateX - translateX.
 */

/**
 * @summary Hook to get dragging overlay's data.
 * @param {UseDraggingOverlayPayload} payload - info for calculation.
 * @returns {UseDraggingOverlayResult} - dragging overlay's translateX to be * used in CSS transform.
 */

function useDraggingOverlay(_ref7) {
  var isDragging = _ref7.isDragging,
      rect = _ref7.rect,
      rootRect = _ref7.rootRect,
      lastColumnRight = _ref7.lastColumnRight,
      clientOffset = _ref7.clientOffset,
      initialOffset = _ref7.initialOffset,
      differenceFromInitialOffset = _ref7.differenceFromInitialOffset,
      selectable = _ref7.selectable,
      tableType = _ref7.tableType;
  return useMemo(function () {
    var draggingOverlayTranslateX = getTranslateX({
      isDragging: isDragging,
      rect: rect,
      rootRect: rootRect,
      lastColumnRight: lastColumnRight,
      clientOffset: clientOffset,
      initialOffset: initialOffset,
      differenceFromInitialOffset: differenceFromInitialOffset,
      selectable: selectable,
      tableType: tableType
    });
    return {
      draggingOverlayTranslateX: draggingOverlayTranslateX
    };
  }, [clientOffset === null || clientOffset === void 0 ? void 0 : clientOffset.x]);
}

var defaultX = '0';
/**
 * @typedef {Object} DOMRect
 * @property {number} left - left coordinate.
 * @property {number} right - right coordinate.
 * @property {number} width - width.
 */

/**
 * @typedef {Object} GetLeftPayload
 * @property {boolean} isFirstColumn - is it first column.
 * @property {DOMRect} rect - head cell DOM rect.
 */

/**
 * @summary Gets dropping overlay's left CSS property in px.
 * @param {GetLeftPayload} payload - info for calculation.
 * @returns {string} - dropping overlay's left CSS property in px.
 */

function getLeft(_ref) {
  var isFirstColumn = _ref.isFirstColumn,
      rect = _ref.rect;

  if (isFirstColumn) {
    return defaultX;
  }

  return "".concat(rect.left, "px");
}
/**
 * @typedef {Object} GetRightPayload
 * @property {boolean} isLastColumn - is it last column.
 */

/**
 * @summary Gets dropping overlay's right CSS property in px.
 * @param {GetRightPayload} payload - info for calculation.
 * @returns {string} - dropping overlay's right CSS property in px.
 */

function getRight$1(_ref2) {
  var isLastColumn = _ref2.isLastColumn;

  if (isLastColumn) {
    return defaultX;
  }

  return 'auto';
}
/**
 * @typedef {Object} GetWidthPayload
 * @property {boolean} isFirstColumn - is it first column.
 * @property {boolean} isLastColumn - is it last column.
 * @property {DOMRect} rect - head cell DOM rect.
 */

/**
 * @summary Gets dropping overlay's width CSS property in px or just auto.
 * @param {GetWidthPayload} payload - info for calculation.
 * @returns {string} - dropping overlay's width CSS property in px or just auto.
 */

function getWidth(_ref3) {
  var isFirstColumn = _ref3.isFirstColumn,
      isLastColumn = _ref3.isLastColumn,
      rect = _ref3.rect;

  if (isFirstColumn) {
    return "".concat(rect.left + rect.width, "px");
  }

  if (isLastColumn) {
    return 'auto';
  }

  return "".concat(rect.width, "px");
}
/**
 * @typedef {Object && GetWidthPayload} UseDroppingOverlayPayload
 */

/**
 * @typedef {Object} UseDroppingOverlayResult
 * @property {string} droppingOverlayWidth - width CSS property.
 * @property {string} droppingOverlayLeft - left CSS property.
 * @property {string} droppingOverlayRight - right CSS property.
 */

/**
 * @summary Gets dropping overlay's info.
 * @param {UseDroppingOverlayPayload} payload - info for calculation.
 * @returns {UseDroppingOverlayResult} - dropping overlay's info.
 */

function useDroppingOverlay(_ref4) {
  var isFirstColumn = _ref4.isFirstColumn,
      isLastColumn = _ref4.isLastColumn,
      rect = _ref4.rect;
  var droppingOverlayWidth = getWidth({
    isFirstColumn: isFirstColumn,
    isLastColumn: isLastColumn,
    rect: rect
  });
  var droppingOverlayLeft = getLeft({
    isFirstColumn: isFirstColumn,
    rect: rect
  });
  var droppingOverlayRight = getRight$1({
    isLastColumn: isLastColumn,
    rect: rect
  });
  return useMemo(function () {
    return {
      droppingOverlayWidth: droppingOverlayWidth,
      droppingOverlayLeft: droppingOverlayLeft,
      droppingOverlayRight: droppingOverlayRight
    };
  }, [droppingOverlayWidth, droppingOverlayLeft, droppingOverlayRight]);
}

var BEFORE$2 = dropDirections.BEFORE,
    AFTER$2 = dropDirections.AFTER;
/**
 * @typedef {Object} UseHeadCellDndConditionsPayload
 * @property {boolean} isDragging - is the current column dragging.
 * @property {boolean} isGloballyDragging - is any column dragging.
 * @property {boolean} isDropping - is the current column dropping.
 * @property {string} dropDirection - column's drop direction.
 */

/**
 * @typedef {Object} UseHeadCellDndConditionsResult
 * @property {boolean} isDraggingOverlayShown - is dragging overlay shown.
 * @property {boolean} isStaticOverlayShown - is static overlay shown.
 * @property {boolean} isDroppingOverlayShown - is dropping overlay shown.
 * @property {boolean} isDroppingBefore - is the column dropping before.
 * @property {boolean} isDroppingAfter - is the column dropping after.
 */

/**
 * @summary Gets head cell's drag and drop conditions.
 * @param {UseHeadCellDndConditionsPayload} payload - info to
 * calculate the head cell's conditions.
 * @returns {UseHeadCellDndConditionsResult} - head cell's
 * drag and drop conditions.
 */

function useHeadCellDndConditions(_ref) {
  var isDragging = _ref.isDragging,
      isGloballyDragging = _ref.isGloballyDragging,
      isDropping = _ref.isDropping,
      dropDirection = _ref.dropDirection;
  return useMemo(function () {
    return {
      isDraggingOverlayShown: isDragging,
      isStaticOverlayShown: isDragging,
      isDroppingOverlayShown: isGloballyDragging,
      isDroppingBefore: isDropping && dropDirection === BEFORE$2,
      isDroppingAfter: isDropping && dropDirection === AFTER$2
    };
  }, [isDragging, isGloballyDragging, isDropping, dropDirection]);
}

/**
 * @typedef {Object} ColumnsRef
 * @property {Array} current.children - rendered head cells.
 */

/**
 * @summary Gets last column's DOM rect.
 * @param {Array} columns - rendered head cells.
 * @returns {Object} - last column's DOM rect.
 */

function getLastColumnRect(columns) {
  if (!columns.length) {
    return {};
  }

  return columns[columns.length - 1].getBoundingClientRect();
}
/**
 * @summary Hook to obtain last column's DOM rect.
 * @param {ColumnsRef} columnsRef - columns DOM reference.
 * @returns {Object} - last column's DOM rect.
 */

function useLastColumnRect(columnsRef) {
  var _columnsRef$children;

  var columns = Array.from((_columnsRef$children = columnsRef === null || columnsRef === void 0 ? void 0 : columnsRef.children) !== null && _columnsRef$children !== void 0 ? _columnsRef$children : []);
  var lastColumnRect = getLastColumnRect(columns);
  return useMemo(function () {
    return lastColumnRect;
  }, [lastColumnRect]);
}

/**
 * @summary Checks is children a text or not.
 * @param {ReactNode} children - component children.
 * @returns {boolean} - is children a text or not.
 */

function getIsText(children) {
  return typeof children === 'string' || typeof children === 'number';
}

function ContentWrapper(_ref) {
  var children = _ref.children;
  var isText = getIsText(children);

  if (isText) {
    return /*#__PURE__*/React__default.createElement("span", {
      className: cellTextClassName
    }, children);
  }

  return children;
}

ContentWrapper.propTypes = {
  children: PropTypes.node
};
var ContentWrapper$1 = /*#__PURE__*/memo(ContentWrapper);

function DndColumnOverlay(_ref) {
  var styles = _ref.styles,
      dataTest = _ref.dataTest;
  var style = useDndColumnOverlayStyle(styles);
  return /*#__PURE__*/React__default.createElement("div", {
    style: style
  });
}

DndColumnOverlay.propTypes = {
  styles: PropTypes.object,
  dataTest: PropTypes.string
};
var DndColumnOverlay$1 = /*#__PURE__*/memo(DndColumnOverlay);

function DndColumnBorder(_ref) {
  var options = _ref.options,
      dataTest = _ref.dataTest;
  var isDropping = options.isDropping,
      dropDirection = options.dropDirection,
      height = options.height;
  var style = useDndColumnBorderStyle({
    isDropping: isDropping,
    dropDirection: dropDirection,
    height: height
  });
  return /*#__PURE__*/React__default.createElement("div", {
    style: style
  });
}

DndColumnBorder.propTypes = {
  options: PropTypes.shape({
    isDropping: PropTypes.bool.isRequired,
    dropDirection: dropDirectionPropTypes.isRequired,
    height: PropTypes.string.isRequired
  }).isRequired,
  dataTest: PropTypes.string
};
var DndColumnBorder$1 = /*#__PURE__*/memo(DndColumnBorder);

var insetOverlayStyles = {
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%'
};

function DndColumnIndicators(_ref) {
  var isDragging = _ref.isDragging,
      isGloballyDragging = _ref.isGloballyDragging,
      isDropping = _ref.isDropping,
      dropDirection = _ref.dropDirection,
      rootRect = _ref.rootRect,
      draggingOverlayOptions = _ref.draggingOverlayOptions,
      droppingOverlayOptions = _ref.droppingOverlayOptions;

  var _useHeadCellDndCondit = useHeadCellDndConditions({
    isDragging: isDragging,
    isGloballyDragging: isGloballyDragging,
    isDropping: isDropping,
    dropDirection: dropDirection
  }),
      isDraggingOverlayShown = _useHeadCellDndCondit.isDraggingOverlayShown,
      isStaticOverlayShown = _useHeadCellDndCondit.isStaticOverlayShown,
      isDroppingOverlayShown = _useHeadCellDndCondit.isDroppingOverlayShown,
      isDroppingBefore = _useHeadCellDndCondit.isDroppingBefore,
      isDroppingAfter = _useHeadCellDndCondit.isDroppingAfter;

  var _useDraggingOverlay = useDraggingOverlay(draggingOverlayOptions),
      draggingOverlayTranslateX = _useDraggingOverlay.draggingOverlayTranslateX;

  var _useDroppingOverlay = useDroppingOverlay(droppingOverlayOptions),
      droppingOverlayWidth = _useDroppingOverlay.droppingOverlayWidth,
      droppingOverlayLeft = _useDroppingOverlay.droppingOverlayLeft,
      droppingOverlayRight = _useDroppingOverlay.droppingOverlayRight;

  var height = "".concat(rootRect.height, "px");
  var dndColumnBorderOptions = {
    isDropping: isDropping,
    dropDirection: dropDirection,
    height: height
  };

  var staticOverlayStyles = _objectSpread2(_objectSpread2({}, insetOverlayStyles), {}, {
    zIndex: zIndexes.columnDraggingOverlay,
    height: height,
    backgroundColor: colors['$color-black-hex-12'],
    opacity: 0.36
  });

  var draggingOverlayStyles = _objectSpread2(_objectSpread2({}, insetOverlayStyles), {}, {
    zIndex: zIndexes.columnDraggingOverlay,
    height: height,
    translateX: draggingOverlayTranslateX,
    backgroundColor: colors['$color-black-rgba-8']
  });

  var droppingOverlayStyles = {
    position: 'fixed',
    zIndex: zIndexes.columnDroppingOverlay,
    top: 0,
    bottom: 0,
    left: droppingOverlayLeft,
    right: droppingOverlayRight,
    width: droppingOverlayWidth
  };
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isStaticOverlayShown && /*#__PURE__*/React__default.createElement(DndColumnOverlay$1, {
    styles: staticOverlayStyles,
    dataTest: testAttrs.dndStaticOverlay
  }), isDraggingOverlayShown && /*#__PURE__*/React__default.createElement(DndColumnOverlay$1, {
    styles: draggingOverlayStyles,
    dataTest: testAttrs.dndDraggingOverlay
  }), isDroppingOverlayShown && /*#__PURE__*/React__default.createElement(DndColumnOverlay$1, {
    styles: droppingOverlayStyles,
    dataTest: testAttrs.dndDroppingOverlay
  }), isDroppingBefore && /*#__PURE__*/React__default.createElement(DndColumnBorder$1, {
    options: dndColumnBorderOptions,
    dataTest: testAttrs.dndColumnLeftBorder
  }), isDroppingAfter && /*#__PURE__*/React__default.createElement(DndColumnBorder$1, {
    options: dndColumnBorderOptions,
    dataTest: testAttrs.dndColumnRightBorder
  }));
}

DndColumnIndicators.propTypes = {
  isDragging: PropTypes.bool,
  isGloballyDragging: PropTypes.bool.isRequired,
  isDropping: PropTypes.bool,
  dropDirection: dropDirectionPropTypes.isRequired,
  rootRect: rectPropTypes,
  draggingOverlayOptions: PropTypes.shape({
    rect: rectPropTypes.isRequired,
    rootRect: rectPropTypes.isRequired,
    isDragging: PropTypes.bool,
    clientOffset: offsetPropTypes,
    initialOffset: offsetPropTypes,
    differenceFromInitialOffset: offsetPropTypes,
    lastColumnRight: PropTypes.number,
    selectable: PropTypes.bool
  }).isRequired,
  droppingOverlayOptions: PropTypes.shape({
    rect: rectPropTypes,
    isFirstColumn: PropTypes.bool.isRequired,
    isLastColumn: PropTypes.bool.isRequired
  })
};
var DndColumnIndicators$1 = /*#__PURE__*/memo(DndColumnIndicators);

var ColumnResizeHandle = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var style = _ref.style;
  return /*#__PURE__*/React__default.createElement("div", {
    ref: ref,
    className: columnResizeHandleClassName,
    style: style
  });
});
ColumnResizeHandle.displayName = 'ColumnResizeHandle';
ColumnResizeHandle.propTypes = {
  style: PropTypes.shape({
    height: PropTypes.string.isRequired,
    right: PropTypes.string.isRequired,
    backgroundColor: PropTypes.string
  })
};
var ColumnResizeHandle$1 = /*#__PURE__*/memo(ColumnResizeHandle);

var NONE$1 = sortingOrders.NONE,
    ASC = sortingOrders.ASC,
    DESC = sortingOrders.DESC;
function Indicator$1(_ref) {
  var isPending = _ref.isPending,
      order = _ref.order;

  if (isPending) {
    return /*#__PURE__*/React__default.createElement(Spinner, {
      size: "s",
      light: true
    });
  }

  if (order === ASC) {
    return /*#__PURE__*/React__default.createElement(Icon, {
      icon: "triangle-up"
    });
  }

  if (order === DESC) {
    return /*#__PURE__*/React__default.createElement(Icon, {
      icon: "triangle-down"
    });
  }

  return null;
}
Indicator$1.propTypes = {
  isPending: PropTypes.bool.isRequired,
  order: PropTypes.string
};

function ColumnSortingIndicator(_ref2) {
  var isPending = _ref2.isPending,
      order = _ref2.order;

  if (!isPending && order === NONE$1) {
    return null;
  }

  return /*#__PURE__*/React__default.createElement("div", {
    className: columnSortingIndicatorClassName
  }, /*#__PURE__*/React__default.createElement(Indicator$1, {
    isPending: isPending,
    order: order
  }));
}

ColumnSortingIndicator.propTypes = {
  isPending: PropTypes.bool.isRequired,
  order: PropTypes.string
};
var ColumnSortingIndicator$1 = /*#__PURE__*/memo(ColumnSortingIndicator);

function HeadCell(_ref) {
  var _dndRef$current$getBo, _dndRef$current, _dndRef$current$getBo2;

  var cell = _ref.cell,
      columnSorting = _ref.columnSorting,
      index = _ref.index,
      rootRect = _ref.rootRect,
      lastColumnRight = _ref.lastColumnRight,
      isGloballyDragging = _ref.isGloballyDragging,
      startGloballyDragging = _ref.startGloballyDragging,
      finishGloballyDragging = _ref.finishGloballyDragging,
      hasRightEmptySpace = _ref.hasRightEmptySpace;
  var name = cell.name,
      type = cell.type,
      content = cell.content,
      options = cell.options,
      globalOptions = cell.globalOptions;
  var style = options.style,
      isFirst = options.isFirst,
      isLast = options.isLast;
  var handlers = globalOptions.handlers,
      selectable = globalOptions.selectable,
      tableType = globalOptions.tableType,
      areColumnsResizable = globalOptions.areColumnsResizable,
      areColumnsDnd = globalOptions.areColumnsDnd;
  var useColumnResize = handlers.useColumnResize,
      useDndColumn = handlers.useDndColumn,
      getRowActions = handlers.getRowActions;
  var isSortingPending = columnSorting.isPending,
      sortingOrder = columnSorting.order;
  var isSorted = sortingOrder !== sortingOrders.NONE;
  var withRightBorder = isLast && hasRightEmptySpace;
  var onColumnClick = useCallback(function (event) {
    handlers.onColumnClick({
      name: name,
      event: event
    });
  }, [name, isSortingPending, sortingOrder]);

  var _useDndColumn = useDndColumn(index),
      dndRef = _useDndColumn.dndRef,
      isDropping = _useDndColumn.isDropping,
      isDragging = _useDndColumn.isDragging,
      clientOffset = _useDndColumn.clientOffset,
      initialOffset = _useDndColumn.initialOffset,
      differenceFromInitialOffset = _useDndColumn.differenceFromInitialOffset;

  var rect = (_dndRef$current$getBo = dndRef === null || dndRef === void 0 ? void 0 : (_dndRef$current = dndRef.current) === null || _dndRef$current === void 0 ? void 0 : (_dndRef$current$getBo2 = _dndRef$current.getBoundingClientRect) === null || _dndRef$current$getBo2 === void 0 ? void 0 : _dndRef$current$getBo2.call(_dndRef$current)) !== null && _dndRef$current$getBo !== void 0 ? _dndRef$current$getBo : {};
  var dropDirection = useDropDirection({
    rect: rect,
    clientOffset: clientOffset
  });

  var _useColumnResize = useColumnResize({
    index: index,
    initialWidth: rect.width
  }),
      resizeHandleRef = _useColumnResize.resizeHandleRef,
      resizeDifferenceX = _useColumnResize.resizeDifferenceX,
      isResizing = _useColumnResize.isResizing;

  var resizeHandleStyle = useResizeHandleStyle({
    isResizing: isResizing,
    resizeDifferenceX: resizeDifferenceX,
    rootRectHeight: rootRect.height,
    isOnRightEdge: isLast && (getRowActions === null || getRowActions === void 0 ? void 0 : getRowActions.isPlaceholder)
  });
  var cellClassName = useCellClassName({
    types: [type],
    options: {
      isDragging: isDragging,
      isSorted: isSorted,
      isLast: isLast,
      withRightBorder: withRightBorder
    },
    globalOptions: globalOptions
  });
  var draggingOverlayOptions = {
    isDragging: isDragging,
    rect: rect,
    rootRect: rootRect,
    lastColumnRight: lastColumnRight,
    clientOffset: clientOffset,
    initialOffset: initialOffset,
    differenceFromInitialOffset: differenceFromInitialOffset,
    selectable: selectable,
    tableType: tableType
  };
  var droppingOverlayOptions = {
    rect: rect,
    isFirstColumn: isFirst,
    isLastColumn: isLast
  };
  useEffect(function () {
    if (isDragging) {
      startGloballyDragging();
    } else {
      finishGloballyDragging();
    }
  }, [isDragging]);
  return /*#__PURE__*/React__default.createElement("div", {
    ref: dndRef // onDragStart={disableTooltip}
    // onDragEnd={enableTooltip}
    ,
    className: cellClassName,
    style: style,
    onClick: onColumnClick
  }, areColumnsDnd && /*#__PURE__*/React__default.createElement(DndColumnIndicators$1, {
    isDragging: isDragging,
    isGloballyDragging: isGloballyDragging,
    isDropping: isDropping,
    dropDirection: dropDirection,
    rootRect: rootRect,
    draggingOverlayOptions: draggingOverlayOptions,
    droppingOverlayOptions: droppingOverlayOptions
  }), /*#__PURE__*/React__default.createElement(ContentWrapper$1, null, content), /*#__PURE__*/React__default.createElement(ColumnSortingIndicator$1, {
    isPending: isSortingPending,
    order: sortingOrder
  }), areColumnsResizable && /*#__PURE__*/React__default.createElement(ColumnResizeHandle$1, {
    ref: resizeHandleRef,
    style: resizeHandleStyle
  }));
}

HeadCell.propTypes = {
  cell: cellPropTypes,
  columnSorting: columnSortingItemPropTypes,
  index: PropTypes.number.isRequired,
  rootRect: rectPropTypes,
  lastColumnRight: PropTypes.number,
  isGloballyDragging: PropTypes.bool.isRequired,
  startGloballyDragging: PropTypes.func.isRequired,
  finishGloballyDragging: PropTypes.func.isRequired,
  hasRightEmptySpace: PropTypes.bool.isRequired
};
var HeadCell$1 = /*#__PURE__*/memo(HeadCell);

var Head = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var columnEntries = _ref.columnEntries,
      columnSorting = _ref.columnSorting,
      globalOptions = _ref.globalOptions,
      checkboxState = _ref.checkboxState,
      onCheckboxChange = _ref.onCheckboxChange,
      rootRect = _ref.rootRect,
      isGloballyDragging = _ref.isGloballyDragging,
      startGloballyDragging = _ref.startGloballyDragging,
      finishGloballyDragging = _ref.finishGloballyDragging,
      lastColumnRight = _ref.lastColumnRight,
      isHorizontallyScrolling = _ref.isHorizontallyScrolling,
      headMessages = _ref.headMessages,
      style = _ref.style,
      hasRightEmptySpace = _ref.hasRightEmptySpace;

  var _useHeadRefs = useHeadRefs(ref),
      rowRef = _useHeadRefs.rowRef,
      columnsRef = _useHeadRefs.columnsRef;

  var handlers = globalOptions.handlers,
      selectable = globalOptions.selectable;
  var getRowActions = handlers.getRowActions,
      onHeadCornerClick = handlers.onHeadCornerClick;
  var checked = checkboxState.checked,
      indeterminate = checkboxState.indeterminate;
  var withHeadCorner = !(getRowActions !== null && getRowActions !== void 0 && getRowActions.isPlaceholder) || !(onHeadCornerClick !== null && onHeadCornerClick !== void 0 && onHeadCornerClick.isPlaceholder);
  var rowClassName = useRowClassName({
    types: [rowTypes.head],
    globalOptions: globalOptions
  });
  var checkboxClassName = useHeadCheckboxClassName({
    options: {
      isHorizontallyScrolling: isHorizontallyScrolling
    },
    globalOptions: globalOptions
  });
  return /*#__PURE__*/React__default.createElement("div", {
    className: headClassNames.root,
    style: style
  }, /*#__PURE__*/React__default.createElement("div", {
    ref: rowRef,
    className: rowClassName,
    role: "row"
  }, selectable && /*#__PURE__*/React__default.createElement(CheckboxCell$1, {
    className: checkboxClassName,
    checked: checked,
    indeterminate: indeterminate,
    onCheckboxChange: onCheckboxChange
  }), /*#__PURE__*/React__default.createElement("div", {
    ref: columnsRef,
    className: headContentWrapperClassName
  }, columnEntries.map(function (_ref2, index) {
    var _ref3 = _slicedToArray(_ref2, 2),
        name = _ref3[0],
        column = _ref3[1];

    return /*#__PURE__*/React__default.createElement(HeadCell$1, {
      key: name,
      index: index,
      cell: column,
      columnSorting: columnSorting[name],
      rootRect: rootRect,
      isGloballyDragging: isGloballyDragging,
      startGloballyDragging: startGloballyDragging,
      finishGloballyDragging: finishGloballyDragging,
      lastColumnRight: lastColumnRight,
      hasRightEmptySpace: hasRightEmptySpace
    });
  })), withHeadCorner && /*#__PURE__*/React__default.createElement(HeadCorner, {
    globalOptions: globalOptions
  })), /*#__PURE__*/React__default.createElement(HeadMessages, {
    messages: headMessages
  }));
});
Head.displayName = 'Head';
Head.propTypes = {
  columnEntries: PropTypes.array,
  columnSorting: PropTypes.objectOf(columnSortingItemPropTypes),
  globalOptions: globalOptionsPropTypes,
  checkboxState: PropTypes.shape({
    checked: PropTypes.bool,
    indeterminate: PropTypes.bool,
    isNoneSelected: PropTypes.bool
  }),
  onCheckboxChange: PropTypes.func,
  rootRect: rectPropTypes,
  isGloballyDragging: PropTypes.bool.isRequired,
  startGloballyDragging: PropTypes.func.isRequired,
  finishGloballyDragging: PropTypes.func.isRequired,
  lastColumnRight: PropTypes.number.isRequired,
  isHorizontallyScrolling: PropTypes.bool.isRequired,
  headMessages: headMessagesPropTypes,
  style: PropTypes.object.isRequired,
  hasRightEmptySpace: PropTypes.bool.isRequired
};
var Head$1 = /*#__PURE__*/memo(Head);

/**
 * @typedef {Object} GlobalOptions
 * @property {boolean} selectable - is Table selectable.
 * @property {boolean} fullWidth - is Table full width.
 * @property {('none'|'horizontal')} [borderType] - border type.
 * @property {Object} handlers - different handlers/functions.
 */

/**
 * @typedef {Object} CellOptions
 * @property {Object} style - Style object passed to a cell.
 *
 */

/**
 * @typedef {Object} Cell
 * @property {CellOptions} cellOptions - Cell options.
 * @property {ReactNode} content - Cell content to render.
 */

/**
 * @typedef {GlobalOptions & Object} RowOptions
 * @property {number} rowIndex - row index.
 * @property {Object} style - style object.
 * @property {number} style.height - row's height.
 */

/**
 * @typedef {Object} Row
 * @property {Cell[]} cells - Cells to render.
 * @property {RowOptions} rowOptions - Row options.
 */

/**
 * @typedef {Object} ColumnOptions
 * @property {Object} style - column styles.
 */

/**
 * @typedef {Object} Column
 * @property {string} content - column content.
 * @property {string} description - column description.
 * @property {ColumnOptions} options - column options.
 */

/**
 * @typedef {Object} GetRowCellsPayload
 * @property {Row} row - row info.
 * @property {[string, Column][]} columnEntries - column entry from Object.entries().
 * @property {GlobalOptions} globalOptions - global options passed to Table.
 */

/**
 * @summary Gets cells for a row.
 * @param {GetRowCellsPayload} payload - Initial data to obtain the cells.
 * @returns {Cell[]} - An array of cells for a row.
 */

function getRowCells(_ref) {
  var row = _ref.row,
      columnEntries = _ref.columnEntries,
      globalOptions = _ref.globalOptions;
  return columnEntries.map(function (_ref2) {
    var _column$options, _row$data$columnName;

    var _ref3 = _slicedToArray(_ref2, 2),
        columnName = _ref3[0],
        column = _ref3[1];

    var options = (_column$options = column === null || column === void 0 ? void 0 : column.options) !== null && _column$options !== void 0 ? _column$options : {};
    return {
      content: (_row$data$columnName = row.data[columnName]) !== null && _row$data$columnName !== void 0 ? _row$data$columnName : null,
      type: cellTypes.body,
      options: options,
      globalOptions: globalOptions
    };
  });
}
/**
 * @summary Gets the total row's height.
 * @param {number} rowIndex - row index.
 * @returns {number} - total row's height.
 */

function getRowHeight(rowIndex) {
  if (rowIndex === 0) {
    return cellStyleDecimal.height;
  }

  return cellStyleDecimal.height + borderWidth;
}
/**
 * @typedef {Object} GetRowOptionsPayload
 * @property {Row} row - row info.
 * @property {number} rowIndex - row index.
 * @property {GlobalOptions} globalOptions - global options passed to Table.
 */

/**
 * @summary Gets row options.
 * @param {GetRowOptionsPayload} payload - Initial data to get the row options.
 * @returns {RowOptions} - row options.
 */

function getRowOptions(_ref4) {
  var _row$options;

  var row = _ref4.row,
      rowIndex = _ref4.rowIndex;
  var height = getRowHeight(rowIndex);
  var defaultRowOptions = {
    rowIndex: rowIndex,
    style: {}
  };
  var localRowOptions = (_row$options = row === null || row === void 0 ? void 0 : row.options) !== null && _row$options !== void 0 ? _row$options : {};

  var style = _objectSpread2(_objectSpread2({}, localRowOptions.style), {}, {
    height: height
  });

  return _objectSpread2(_objectSpread2(_objectSpread2({}, defaultRowOptions), localRowOptions), {}, {
    style: style
  });
}
/**
 * @typedef {Object} GetBodyRowsPayload
 * @property {Array} rows - initial array of rows passed to the Table.
 * @property {[string, Column][]} columnEntries - column entries from Object.entries().
 * @property {Object} globalOptions - global options passed to the Table component.
 */

/**
 * @summary Gets body rows with cells and row options to render.
 * @param {GetBodyRowsPayload} payload - Initial data to obtain the rows.
 * @returns {Row[]} - An array of body rows to render.
 */

function getBodyRows(_ref5) {
  var rows = _ref5.rows,
      columnEntries = _ref5.columnEntries,
      globalOptions = _ref5.globalOptions;
  return rows.map(function (row, rowIndex) {
    var cells = getRowCells({
      row: row,
      columnEntries: columnEntries,
      globalOptions: globalOptions
    });
    var options = getRowOptions({
      row: row,
      rowIndex: rowIndex
    });
    return {
      cells: cells,
      options: options,
      globalOptions: globalOptions
    };
  });
}

var NONE$2 = sortingOrders.NONE;
/**
 * @typedef {Object} ColumnSortingItem
 * @property {boolean} isPending - is the sorting pending.
 * @property {string} order - sorting order.
 */

/**
 * @typedef {Object} Payload
 * @property {Array} initColumnEntries - initial column entries.
 * @property {Object<string, ColumnSortingItem>} columnSortingState - initial
 * state.columnSorting.
 */

/**
 * @summary Gets state.columnSorting for the table.
 * @param {Payload} payload - info for calculation.
 * @returns {Object<string, ColumnSortingItem>} - state.columnSorting
 * for the table.
 */

function getColumnSorting(_ref) {
  var initColumnEntries = _ref.initColumnEntries,
      columnSortingState = _ref.columnSortingState;
  return initColumnEntries.reduce(function (acc, _ref2) {
    var _columnSortingState$c, _column$isPending, _column$order;

    var _ref3 = _slicedToArray(_ref2, 1),
        columnName = _ref3[0];

    var column = (_columnSortingState$c = columnSortingState === null || columnSortingState === void 0 ? void 0 : columnSortingState[columnName]) !== null && _columnSortingState$c !== void 0 ? _columnSortingState$c : {};
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, columnName, _objectSpread2(_objectSpread2({}, column), {}, {
      isPending: (_column$isPending = column.isPending) !== null && _column$isPending !== void 0 ? _column$isPending : false,
      order: (_column$order = column.order) !== null && _column$order !== void 0 ? _column$order : NONE$2
    })));
  }, {});
}

/**
 * @typedef {Object} AccValue
 * @property {Object} staticWidths - static width value per each unit.
 * @property {number} fluidColumnsAmount - an amount of fluid columns
 * without the fixed width defined.
 */

/**
 * @summary Gets the initial accumulator value for the reduce
 * inside the getColumnsLayout function.
 * @returns {AccValue} - initial accumulator value.
 */

function getAccInitValue() {
  return widthUnits.reduce(function (acc, unit) {
    return _objectSpread2(_objectSpread2({}, acc), {}, {
      staticWidths: _objectSpread2(_objectSpread2({}, acc.staticWidths), {}, _defineProperty({}, unit, 0)),
      fluidColumnsAmount: 0
    });
  }, {});
}
var accInitValue = getAccInitValue();
/**
 * @typedef {Object} Column
 * @property {string} content - column content.
 * @property {string} description - column description.
 * @property {ColumnOptions} options - column options.
 */

/**
 * @typedef {Object} ColumnStyle
 * @property {string} width - column defined width.
 * @property {string} flexBasis - column defined flexBasis.
 */

/**
 * @typedef {Object} ColumnOptions
 * @property {Object} style - column styles.
 */

/**
 * @summary Gets the columns layout info.
 * @param {[string, Column][]} columnEntries - column entries.
 * @returns {AccValue} - columns layout info.
 */

function getColumnsLayout(columnEntries) {
  return columnEntries.reduce(function (acc, _ref) {
    var _column$options, _style$width;

    var _ref2 = _slicedToArray(_ref, 2),
        column = _ref2[1];

    var style = column === null || column === void 0 ? void 0 : (_column$options = column.options) === null || _column$options === void 0 ? void 0 : _column$options.style;
    var width = (_style$width = style === null || style === void 0 ? void 0 : style.width) !== null && _style$width !== void 0 ? _style$width : style === null || style === void 0 ? void 0 : style.flexBasis;

    if (!width) {
      return _objectSpread2(_objectSpread2({}, acc), {}, {
        fluidColumnsAmount: acc.fluidColumnsAmount + 1
      });
    }

    var unit = widthUnits.find(function (un) {
      return width.includes(un);
    });
    var staticWidth = parseFloat(width, 10);
    return _objectSpread2(_objectSpread2({}, acc), {}, {
      staticWidths: _objectSpread2(_objectSpread2({}, acc.staticWidths), {}, _defineProperty({}, unit, acc.staticWidths[unit] + staticWidth))
    });
  }, accInitValue);
}

/**
 * @summary Gets the sum of all static widths.
 * @param {Object} staticWidths - static widths for each supported css unit.
 * @returns {string} - static widths sum.
 */
function getStaticWidthSum(staticWidths) {
  var sum = Object.entries(staticWidths).reduce(function (acc, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        unit = _ref2[0],
        value = _ref2[1];

    if (!value) return acc;
    if (!acc) return "".concat(value).concat(unit);
    return "".concat(acc, " + ").concat(value).concat(unit);
  }, '');
  if (sum.includes('+')) return "(".concat(sum, ")");
  return sum;
}
/**
 * @summary Gets the static width sum expression with
 * the corresponding operator to use in css calc().
 * @param {string} operator - preceding math operator.
 * @param {Object} staticWidths - static widths for each supported css unit.
 * @returns {string} - static width expression to use in css calc().
 */

function getStaticWidthCalc(operator, staticWidths) {
  if (!operator) throw new Error('Math operator must be specified.');
  var sum = getStaticWidthSum(staticWidths);
  if (!sum) return '';
  return " ".concat(operator, " ").concat(sum);
}

/**
 * @summary Gets normalized css calc() function value.
 * @param {string} calc - initial calc value.
 * @returns {string} - normalized calc value.
 */
function getNormalizedCalc(calc) {
  return calc.replace(/\n|\t{2,}| {2}/gm, '');
}

/**
 * @typedef {Object} Handlers
 * @property {(() => {})[]} rowActions - a set of row actions.
 * @property {() => {}} onHeadCornerClick - on head corner click handler.
 */

/**
 * @typedef {Object} GlobalOptions
 * @property {boolean} selectable - is the table selectable.
 * @property {string} tableType - table type.
 * @property {Handlers} handlers - table handler functions.
 */

/**
 * @typedef {Object && GlobalOptions} GetCheckboxWidthSubstractionPayload
 * @property {number} columnsAmount - columns amount.
 */

/**
 * @summary Gets checkbox width substraction expression.
 * @param {GetCheckboxWidthSubstractionPayload} payload - info for calculation.
 * @returns {string} - checkbox width substraction expression.
 */

function getCheckboxWidthSubstraction(_ref) {
  var columnsAmount = _ref.columnsAmount,
      selectable = _ref.selectable,
      tableType = _ref.tableType;

  if (selectable) {
    return " - ".concat(checkboxesStyleDecimal[tableType].width / columnsAmount, "px");
  }

  return '';
}
/**
 * @typedef {Object && GlobalOptions} GetActionCellWidthSubstraction
 * @property {number} columnsAmount - columns amount.
 */

/**
 * @summary Gets action cell width substraction expression.
 * @param {GetActionCellWidthSubstraction} payload - info for calculation.
 * @returns {string} - action cell width substraction expression.
 */

function getActionCellWidthSubstraction(_ref2) {
  var columnsAmount = _ref2.columnsAmount,
      handlers = _ref2.handlers;
  var getRowActions = handlers.getRowActions,
      onHeadCornerClick = handlers.onHeadCornerClick;
  var withRowActions = !(getRowActions !== null && getRowActions !== void 0 && getRowActions.isPlaceholder) || !(onHeadCornerClick !== null && onHeadCornerClick !== void 0 && onHeadCornerClick.isPlaceholder);

  if (withRowActions) {
    return " - ".concat(rowActionsStyleDecimal.width / columnsAmount, "px");
  }

  return '';
}
/**
 * @typedef {Object} Column
 * @property {string} content - column content.
 * @property {string} description - column description.
 * @property {ColumnOptions} options - column options.
 */

/**
 * @typedef {Object} ColumnStyle
 * @property {string} width - column defined width.
 * @property {string} flexBasis - column defined flexBasis.
 */

/**
 * @typedef {Object} ColumnOptions
 * @property {Object} style - column styles.
 */

/**
 * @typedef {Object} GetFluidWidthpayload
 * @property {[string, Column][]} columnEntries - column entries.
 * @property {GlobalOptions} globalOptions - table options.
 */

/**
 * @summary Gets fluid width calc() for each fluid column.
 * @param {GetFluidWidthpayload} payload - info for calculation.
 * @returns {string} - fluid column width calc().
 */

function getFluidWidth(_ref3) {
  var columnEntries = _ref3.columnEntries,
      globalOptions = _ref3.globalOptions;
  var columnsAmount = columnEntries.length;

  var _getColumnsLayout = getColumnsLayout(columnEntries),
      staticWidths = _getColumnsLayout.staticWidths;

  var selectable = globalOptions.selectable,
      tableType = globalOptions.tableType,
      handlers = globalOptions.handlers;
  var fluidPercentage = "".concat(100 / columnsAmount, "%");
  var staticWidthSubstraction = getStaticWidthCalc('-', staticWidths);
  var checkboxWidthSubstraction = getCheckboxWidthSubstraction({
    columnsAmount: columnsAmount,
    selectable: selectable,
    tableType: tableType
  });
  var actionCellWidthSubstraction = getActionCellWidthSubstraction({
    columnsAmount: columnsAmount,
    handlers: handlers
  });
  var calc = "calc(\n\t\t".concat(fluidPercentage, "\n\t\t").concat(staticWidthSubstraction, "\n\t\t").concat(checkboxWidthSubstraction, "\n\t\t").concat(actionCellWidthSubstraction, ")");
  return getNormalizedCalc(calc);
}
/**
 * @summary Gets column options adjusting the style.
 * @param {Column} column - column configuration.
 * @param {string} fluidWidth - fluid column width calc().
 * @returns {ColumnOptions} - options with the adjusted style.
 */

function getOptions(_ref4) {
  var _column$options, _initOptions$style, _initStyle$width;

  var column = _ref4.column,
      fluidWidth = _ref4.fluidWidth,
      isFirst = _ref4.isFirst,
      isLast = _ref4.isLast;
  var initOptions = (_column$options = column === null || column === void 0 ? void 0 : column.options) !== null && _column$options !== void 0 ? _column$options : {};
  var initStyle = (_initOptions$style = initOptions === null || initOptions === void 0 ? void 0 : initOptions.style) !== null && _initOptions$style !== void 0 ? _initOptions$style : {};
  var definedWidth = (_initStyle$width = initStyle.width) !== null && _initStyle$width !== void 0 ? _initStyle$width : initStyle.flexBasis;
  var width = definedWidth !== null && definedWidth !== void 0 ? definedWidth : fluidWidth;
  var flexGrow = definedWidth ? 0 : 1;

  var style = _objectSpread2(_objectSpread2({}, initStyle), {}, {
    width: width,
    flexGrow: flexGrow,
    flexBasis: 'auto'
  });

  var localOptions = {
    style: style,
    isFirst: isFirst,
    isLast: isLast
  };
  return _objectSpread2(_objectSpread2({}, initOptions), localOptions);
}
/**
 * @typedef {Object} GetStyledColumnsPayload
 * @property {[string, Column][]} columnEntries - column entries.
 * @property {GlobalOptions} globalOptions - table options.
 */

/**
 * @summary Gets columns with the adjusted styles.
 * @param {GetStyledColumnsPayload} payload - info for calculation.
 * @returns {Object} - columns with the adjusted styles.
 */

function getStyledColumns(_ref5) {
  var columnEntries = _ref5.columnEntries,
      globalOptions = _ref5.globalOptions;
  var fluidWidth = getFluidWidth({
    columnEntries: columnEntries,
    globalOptions: globalOptions
  });
  return columnEntries.reduce(function (acc, _ref6, index) {
    var _ref7 = _slicedToArray(_ref6, 2),
        name = _ref7[0],
        column = _ref7[1];

    var isFirst = index === 0;
    var isLast = index === columnEntries.length - 1;
    var options = getOptions({
      column: column,
      fluidWidth: fluidWidth,
      isFirst: isFirst,
      isLast: isLast
    });
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, name, _objectSpread2(_objectSpread2({}, column), {}, {
      name: name,
      type: cellTypes.head,
      options: options,
      globalOptions: globalOptions
    })));
  }, {});
}

/**
 * @typedef {Object} GlobalOptions
 * @property {Object} handlers - different Table handlers.
 */

/**
 * @summary Gets the proper columns prop handling optional fields.
 * @param {Object} columns - Table columns.
 * @param {Object} globalOptions - Table options.
 * @returns {Object} - normalized columns prop.
 */

function getColumns(_ref) {
  var options = _ref.options,
      initColumnEntries = _ref.initColumnEntries;
  return getStyledColumns({
    columnEntries: initColumnEntries,
    globalOptions: options
  });
}
/**
 * @summary Gets missing flags with the default values.
 * @param {Object} options - Table options.
 * @returns {Object} - Missing flags with the default values.
 */

function getMissingFlags(options) {
  var definedOptions = Object.keys(options);
  return flags.filter(function (flag) {
    return !definedOptions.includes(flag);
  }).reduce(function (acc, flag) {
    return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, flag, false));
  }, {});
}
/**
 * @summary Gets internal flags.
 * @param {Object} options - Table options.
 * @returns {Object} - internal flags.
 */

function getInternalFlags(options) {
  var _options$handlers, _options$handlers2;

  var areColumnsResizable = !!(options !== null && options !== void 0 && (_options$handlers = options.handlers) !== null && _options$handlers !== void 0 && _options$handlers.useColumnResize);
  var areColumnsDnd = !!(options !== null && options !== void 0 && (_options$handlers2 = options.handlers) !== null && _options$handlers2 !== void 0 && _options$handlers2.useDndColumn);
  return {
    areColumnsResizable: areColumnsResizable,
    areColumnsDnd: areColumnsDnd
  };
}
/**
 * @summary Gets handlers including the required ones if the latter are missing.
 * @param {Object} handlers - handlers passed to options.handlers.
 * @returns {Object} - handlers to use.
 */

function getHandlers() {
  var handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var placeholders = requiredHandlers.reduce(function (acc, _ref2) {
    var name = _ref2.name,
        _ref2$value = _ref2.value,
        value = _ref2$value === void 0 ? function () {} : _ref2$value;

    if (!(handlers !== null && handlers !== void 0 && handlers[name])) {
      var handler = value;
      handler.isPlaceholder = true;
      return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, name, value));
    }

    return acc;
  }, {});
  return _objectSpread2(_objectSpread2({}, handlers), placeholders);
}
/**
 * @summary Gets options.infiniteScroll with missing fields set.
 * @param {Object} infiniteScroll - passed options.infiniteScroll.
 * @returns {Object} - options.infiniteScroll with missing fields set.
 */

function getInfiniteScroll(infiniteScroll) {
  var _infiniteScroll$thres;

  var isDisabled = !infiniteScroll;
  var threshold = (_infiniteScroll$thres = infiniteScroll === null || infiniteScroll === void 0 ? void 0 : infiniteScroll.threshold) !== null && _infiniteScroll$thres !== void 0 ? _infiniteScroll$thres : defaultInfiniteScrollThreshold;
  return _objectSpread2(_objectSpread2({}, infiniteScroll), {}, {
    isDisabled: isDisabled,
    threshold: threshold
  });
}
/**
 * @summary Gets options.rowSelection with missing fields set.
 * @param {Object} rowSelection - passed options.rowSelection.
 * @returns {Object} - options.rowSelection with missing fields set.
 */

function getRowSelection() {
  var _rowSelection$limit;

  var rowSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var limit = (_rowSelection$limit = rowSelection.limit) !== null && _rowSelection$limit !== void 0 ? _rowSelection$limit : defaultRowSelectionLimit;
  return _objectSpread2(_objectSpread2({}, rowSelection), {}, {
    limit: limit
  });
}
/**
 * @summary Gets the proper options prop handling missing optional fields.
 * @param {Object} prop - Table options.
 * @returns {Object} - normalized options prop.
 */

function getOptions$1(prop) {
  var _options$borderType, _options$tableType;

  var options = prop !== null && prop !== void 0 ? prop : {};
  var handlers = getHandlers(options === null || options === void 0 ? void 0 : options.handlers);
  var missingFlags = getMissingFlags(options);
  var internalFlags = getInternalFlags(options);
  var borderType = (_options$borderType = options === null || options === void 0 ? void 0 : options.borderType) !== null && _options$borderType !== void 0 ? _options$borderType : borderTypes.DEFAULT;
  var tableType = (_options$tableType = options === null || options === void 0 ? void 0 : options.tableType) !== null && _options$tableType !== void 0 ? _options$tableType : tableTypes.DEFAULT;
  var infiniteScroll = getInfiniteScroll(options === null || options === void 0 ? void 0 : options.infiniteScroll);
  var rowSelection = getRowSelection(options === null || options === void 0 ? void 0 : options.rowSelection);
  return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, options), missingFlags), internalFlags), {}, {
    handlers: handlers,
    borderType: borderType,
    tableType: tableType,
    infiniteScroll: infiniteScroll,
    rowSelection: rowSelection
  });
}
/**
 * @summary Gets the proper state prop handling missing optional fields.
 * @param {Object} prop - Table state.
 * @returns {Object} - Normalized state prop.
 */

function getState(_ref3) {
  var _state$selectedRows, _state$highlightedRow, _state$unseenRows, _state$columnSorting, _state$headMessages;

  var initState = _ref3.initState,
      initColumnEntries = _ref3.initColumnEntries;
  var state = initState !== null && initState !== void 0 ? initState : {};
  var selectedRows = (_state$selectedRows = state === null || state === void 0 ? void 0 : state.selectedRows) !== null && _state$selectedRows !== void 0 ? _state$selectedRows : [];
  var highlightedRows = (_state$highlightedRow = state === null || state === void 0 ? void 0 : state.highlightedRows) !== null && _state$highlightedRow !== void 0 ? _state$highlightedRow : [];
  var unseenRows = (_state$unseenRows = state === null || state === void 0 ? void 0 : state.unseenRows) !== null && _state$unseenRows !== void 0 ? _state$unseenRows : [];
  var columnSorting = getColumnSorting({
    initColumnEntries: initColumnEntries,
    columnSortingState: (_state$columnSorting = state === null || state === void 0 ? void 0 : state.columnSorting) !== null && _state$columnSorting !== void 0 ? _state$columnSorting : {}
  });
  var headMessages = (_state$headMessages = state === null || state === void 0 ? void 0 : state.headMessages) !== null && _state$headMessages !== void 0 ? _state$headMessages : [];
  return _objectSpread2(_objectSpread2({}, state), {}, {
    selectedRows: selectedRows,
    highlightedRows: highlightedRows,
    unseenRows: unseenRows,
    columnSorting: columnSorting,
    headMessages: headMessages
  });
}
/**
 * @typedef {Object} InitProps
 * @property {Object} initColumns - columns object passed to the Table.
 * @property {Object} initOptions - options object passed to the Table.
 * @property {Object} initState - state object passed to the Table.
 */

/**
 * @typedef {Object} Props
 * @property {Object} columns - normalized columns object.
 * @property {Object} options - normalized options object.
 * @property {Object} state - normalized state object.
 */

/**
 * @summary Gets normalized init props handling missing optional props
 * on the top level.
 * @param {InitProps} payload - default props to normalize.
 * @returns {Props} - normalized props.
 */

function getProps() {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      initColumnEntries = _ref4.initColumnEntries,
      initOptions = _ref4.initOptions,
      initState = _ref4.initState;

  var options = getOptions$1(initOptions);
  var columns = getColumns({
    options: options,
    initColumnEntries: initColumnEntries
  });
  var state = getState({
    initState: initState,
    initColumnEntries: initColumnEntries
  });
  return {
    columns: columns,
    options: options,
    state: state
  };
}

var ALL = selectedStates.ALL,
    NONE$3 = selectedStates.NONE,
    INDETERMINATE = selectedStates.INDETERMINATE;
/**
 * @summary Gets the current head checkbox selected state.
 * @param {number} selected - Selected rows number.
 * @param {number} total - Total rows number.
 * @returns {(ALL, NONE, INDETERMINATE)} - Current selected state.
 */

function getSelectedState(selected, total) {
  if (selected === total) return ALL;
  if (selected === 0) return NONE$3;
  return INDETERMINATE;
}
/**
 * @summary A hook to obtain memoized head checkbox selected state.
 * @param {number} selected - Selected rows number.
 * @param {number} total - Total rows number.
 * @returns {(ALL, NONE, INDETERMINATE)} - Current memoized selected state.
 */

function useSelectedState(selected, total) {
  return useMemo(function () {
    return getSelectedState(selected, total);
  }, [selected, total]);
}
/**
 * @typedef {Object} CheckboxState
 * @property {boolean} checked - checked state.
 * @property {boolean} indeterminate - indeterminate.
 * @property {boolean} isNoneSelected - is none of the rows selected.
 */

/**
 * @summary A hook to obtain the head checkbox state.
 * @param {number} selected - Selected rows number.
 * @param {number} total - Total rows number.
 * @returns {CheckboxState} - Memoized checkbox state.
 */

function useHeadCheckboxState(selected, total) {
  var selectedState = useSelectedState(selected, total);
  return useMemo(function () {
    var checked = selectedState === ALL;
    var indeterminate = selectedState === INDETERMINATE;
    var isNoneSelected = selectedState === NONE$3;
    return {
      checked: checked,
      indeterminate: indeterminate,
      isNoneSelected: isNoneSelected
    };
  }, [selectedState]);
}

/**
 * @summary Gets the borders sum of all of the rows in px.
 * @param {number} rowsToDisplay - the amount of rows to display.
 * @returns {number} - the borders sum of all of the rows in px.
 */

function getRowBordersSum(rowsToDisplay) {
  if (rowsToDisplay <= 1) {
    return 0;
  }

  var topBorderRows = rowsToDisplay - borderWidth;
  return borderWidth * topBorderRows;
}
/**
 * @summary Gets the body's height in px based on the amount of
 * rows to display.
 * @param {number} rowsToDisplay - the amount of rows to display.
 * @returns {number} - the body's height in px based on the amount of
 * rows to display.
 */

function getHeight$1(rowsToDisplay) {
  var rowBordersSum = getRowBordersSum(rowsToDisplay);
  return rowsToDisplay * cellStyleDecimal.height + rowBordersSum;
}
/**
 * @summary Gets the body's maximum possible height in px based on
 * the total amount of rows.
 * @param {number} rowsLength - total amount of rows.
 * @returns {number} - the body's maximum possible height in px based on
 * the total amount of rows.
 */

function getMaxHeight$1(rowsLength) {
  if (rowsLength > maxRowsToDisplay) {
    return getHeight$1(maxRowsToDisplay);
  }

  return getHeight$1(rowsLength);
}
var minHeight = getHeight$1(minRowsToDisplay);
/**
 * @typedef {Object} UseBodyHeightPayload
 * @property {React.Ref} rootRef - table's root node DOM ref.
 * @property {number} rowsLength - total amount of rows.
 */

/**
 * @summary Gets the table's body height for virtualization.
 * @param {UseBodyHeightPayload} payload - data to obtain the
 * table's height.
 * @returns {number} - the table's body height for virtualization.
 */

function useBodyHeight(_ref) {
  var _rootRef$current, _parentNode$getBoundi;

  var rootRef = _ref.rootRef,
      rowsLength = _ref.rowsLength;
  var parentNode = rootRef === null || rootRef === void 0 ? void 0 : (_rootRef$current = rootRef.current) === null || _rootRef$current === void 0 ? void 0 : _rootRef$current.parentNode;
  var parentRect = parentNode === null || parentNode === void 0 ? void 0 : (_parentNode$getBoundi = parentNode.getBoundingClientRect) === null || _parentNode$getBoundi === void 0 ? void 0 : _parentNode$getBoundi.call(parentNode);
  return useMemo(function () {
    if (!parentRect) {
      return;
    }

    var rootRect = rootRef.current.getBoundingClientRect();
    var topDifference = rootRect.top - parentRect.top;
    var bodyHeight = parentRect.height - topDifference - headCellStyleDecimal.height - borderWidth;

    if (bodyHeight < minHeight) {
      return minHeight;
    }

    var maxHeight = getMaxHeight$1(rowsLength);

    if (bodyHeight > maxHeight) {
      return maxHeight;
    }

    return bodyHeight;
  }, [parentRect === null || parentRect === void 0 ? void 0 : parentRect.top, rowsLength]);
}

/**
 * @typedef {Object} Row
 * @property {options.style.height} number - row height.
 */

/**
 * @summary Gets getItemSize function for the react-window's
 * itemSize VariableSizeList prop.
 * @param {Row[]} rows - body rows to render.
 * @returns {(i:number) => number} - getItemSize function for the
 * react-window's itemSize VariableSizeList prop.
 */

function useBodyGetItemSize(rows) {
  return useCallback(function (index) {
    var _rows$index$options$s, _rows$index, _rows$index$options, _rows$index$options$s2;

    if (!rows.length) {
      return 0;
    }

    return (_rows$index$options$s = (_rows$index = rows[index]) === null || _rows$index === void 0 ? void 0 : (_rows$index$options = _rows$index.options) === null || _rows$index$options === void 0 ? void 0 : (_rows$index$options$s2 = _rows$index$options.style) === null || _rows$index$options$s2 === void 0 ? void 0 : _rows$index$options$s2.height) !== null && _rows$index$options$s !== void 0 ? _rows$index$options$s : cellStyleDecimal.height + borderWidth;
  }, [rows]);
}

function useIsHorizontallyScrolling(ref) {
  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isIntersecting = _useState2[0],
      setIsIntersecting = _useState2[1];

  useEffect(function () {
    if (!(ref !== null && ref !== void 0 && ref.current)) {
      return;
    }

    var observer = new IntersectionObserver(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          entry = _ref2[0];

      setIsIntersecting(entry.isIntersecting);
    }, {
      root: null,
      threshold: 1
    });
    observer.observe(ref.current);
    return function () {
      observer.unobserve(ref.current);
    };
  }, [!!(ref !== null && ref !== void 0 && ref.current)]);
  return useMemo(function () {
    return !isIntersecting;
  }, [isIntersecting]);
}

/**
 * @typedef {Object} Payload
 * @property {Object} rootRef - root ref.
 * @property {Object} refRect - root ref rect.
 */

/**
 * @summary Gets root rect.
 * @param {Payload} payload - info for calculation.
 * @returns {Object} - root rect.
 */

function useRootRect(_ref) {
  var rootRef = _ref.rootRef,
      refRect = _ref.refRect;

  var _useState = useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      rootRect = _useState2[0],
      setRootRect = _useState2[1];

  useEffect(function () {
    var _rootRef$current, _rootRef$current$getB;

    var mountedRect = rootRef === null || rootRef === void 0 ? void 0 : (_rootRef$current = rootRef.current) === null || _rootRef$current === void 0 ? void 0 : (_rootRef$current$getB = _rootRef$current.getBoundingClientRect) === null || _rootRef$current$getB === void 0 ? void 0 : _rootRef$current$getB.call(_rootRef$current);

    if (!mountedRect) {
      return;
    }

    var tempRect = {
      width: mountedRect.width,
      height: mountedRect.height,
      left: mountedRect.left,
      right: mountedRect.right,
      top: mountedRect.top
    };
    var roundedRect = Object.entries(tempRect).reduce(function (acc, _ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          key = _ref3[0],
          value = _ref3[1];

      return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, key, Math.round(value)));
    }, {});
    var width = roundedRect.width,
        height = roundedRect.height,
        left = roundedRect.left,
        right = roundedRect.right,
        top = roundedRect.top;
    setRootRect({
      width: width,
      height: height,
      left: left,
      right: right,
      top: top
    });
  }, [refRect === null || refRect === void 0 ? void 0 : refRect.width, refRect === null || refRect === void 0 ? void 0 : refRect.height, refRect === null || refRect === void 0 ? void 0 : refRect.left, refRect === null || refRect === void 0 ? void 0 : refRect.right, refRect === null || refRect === void 0 ? void 0 : refRect.top]);
  return rootRect;
}

/**
 * @typedef {Object} GetStickyColumnWidthPayload
 * @property {Function} onHeadCornerClick - handler.
 * @property {Function} getRowActions - handler.
 */

/**
 * @summary Gets sticky column width.
 * @param {GetStickyColumnWidthPayload} payload - info for calculation.
 * @returns {number} - sticky column width.
 */

function getStickyColumnWidth(_ref) {
  var onHeadCornerClick = _ref.onHeadCornerClick,
      getRowActions = _ref.getRowActions;
  var withStickyColumn = !(onHeadCornerClick !== null && onHeadCornerClick !== void 0 && onHeadCornerClick.isPlaceholder) || !(getRowActions !== null && getRowActions !== void 0 && getRowActions.isPlaceholder);
  return withStickyColumn ? rowActionsStyleDecimal.width : 0;
}
/**
 * @typedef {Object} GetHasRightEmptySpacePayload
 * @property {Object} rootRef - root ref.
 * @property {Object} rootRect - root ref's bounding client rect.
 * @property {Object} lastColumnRect - last column's bounding client rect.
 * @property {Object} globalOptions - table global options.
 */

/**
 * @summary Gets a boolean if the table has empty right space.
 * @param {GetHasRightEmptySpacePayload} payload - info for calculation.
 * @returns {boolean} - a boolean if the table has empty right space.
 */

function getHasRightEmptySpace(_ref2) {
  var _rootRef$current, _rootRef$current2;

  var rootRef = _ref2.rootRef,
      rootRect = _ref2.rootRect,
      lastColumnRect = _ref2.lastColumnRect,
      globalOptions = _ref2.globalOptions;
  var areColumnsResizable = globalOptions.areColumnsResizable;
  var _globalOptions$handle = globalOptions.handlers,
      onHeadCornerClick = _globalOptions$handle.onHeadCornerClick,
      getRowActions = _globalOptions$handle.getRowActions;
  var scrollBarWidth = (rootRef === null || rootRef === void 0 ? void 0 : (_rootRef$current = rootRef.current) === null || _rootRef$current === void 0 ? void 0 : _rootRef$current.offsetWidth) - (rootRef === null || rootRef === void 0 ? void 0 : (_rootRef$current2 = rootRef.current) === null || _rootRef$current2 === void 0 ? void 0 : _rootRef$current2.clientWidth) || 0;
  var resizeHandleWidth = areColumnsResizable ? resizeHandleStyleDecimal.width : 0;
  var stickyColumnWidth = getStickyColumnWidth({
    onHeadCornerClick: onHeadCornerClick,
    getRowActions: getRowActions
  });
  var emptySpace = rootRect.right - lastColumnRect.right;
  return emptySpace - stickyColumnWidth - resizeHandleWidth - scrollBarWidth > 0;
}

function _extends$4() {
  _extends$4 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$4.apply(this, arguments);
}

function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$1(o, p);
}

function _inheritsLoose$2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}

function _assertThisInitialized$3(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
        return typeof value === 'number' && value !== value;
    };
function isEqual(first, second) {
    if (first === second) {
        return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
    }
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

// Animation frame based implementation of setTimeout.
// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js
var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
var now$1 = hasNativePerformanceNow ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  var start = now$1();

  function tick() {
    if (now$1() - start >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }

  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}
var cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).
// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.
// The safest way to check this is to intentionally set a negative offset,
// and then verify that the subsequent "scroll" event matches the negative offset.
// If it does not match, then we can assume a non-standard RTL scroll implementation.

function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }

  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement('div');
    var outerStyle = outerDiv.style;
    outerStyle.width = '50px';
    outerStyle.height = '50px';
    outerStyle.overflow = 'scroll';
    outerStyle.direction = 'rtl';
    var innerDiv = document.createElement('div');
    var innerStyle = innerDiv.style;
    innerStyle.width = '100px';
    innerStyle.height = '100px';
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);

    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = 'positive-descending';
    } else {
      outerDiv.scrollLeft = 1;

      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = 'negative';
      } else {
        cachedRTLResult = 'positive-ascending';
      }
    }

    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }

  return cachedRTLResult;
}

var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;

var defaultItemKey$1 = function defaultItemKey(index, data) {
  return index;
}; // In DEV mode, this Set helps us only log a warning once per component instance.
// This avoids spamming the console every time a render happens.


var devWarningsDirection = null;
var devWarningsTagName$1 = null;

{
  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {
    devWarningsDirection =
    /*#__PURE__*/
    new WeakSet();
    devWarningsTagName$1 =
    /*#__PURE__*/
    new WeakSet();
  }
}

function createListComponent(_ref) {
  var _class, _temp;

  var getItemOffset = _ref.getItemOffset,
      getEstimatedTotalSize = _ref.getEstimatedTotalSize,
      getItemSize = _ref.getItemSize,
      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,
      getStartIndexForOffset = _ref.getStartIndexForOffset,
      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,
      initInstanceProps = _ref.initInstanceProps,
      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,
      validateProps = _ref.validateProps;
  return _temp = _class =
  /*#__PURE__*/
  function (_PureComponent) {
    _inheritsLoose$2(List, _PureComponent);

    // Always use explicit constructor for React components.
    // It produces less code after transpilation. (#26)
    // eslint-disable-next-line no-useless-constructor
    function List(props) {
      var _this;

      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized$3(_assertThisInitialized$3(_this)));
      _this._outerRef = void 0;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: _assertThisInitialized$3(_assertThisInitialized$3(_this)),
        isScrolling: false,
        scrollDirection: 'forward',
        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex: overscanStartIndex,
          overscanStopIndex: overscanStopIndex,
          visibleStartIndex: visibleStartIndex,
          visibleStopIndex: visibleStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection: scrollDirection,
          scrollOffset: scrollOffset,
          scrollUpdateWasRequested: scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;

      _this._getItemStyle = function (index) {
        var _this$props = _this.props,
            direction = _this$props.direction,
            itemSize = _this$props.itemSize,
            layout = _this$props.layout;

        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);

        var style;

        if (itemStyleCache.hasOwnProperty(index)) {
          style = itemStyleCache[index];
        } else {
          var _offset = getItemOffset(_this.props, index, _this._instanceProps);

          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction "horizontal"

          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
          var isRtl = direction === 'rtl';
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index] = style = {
            position: 'absolute',
            left: isRtl ? undefined : offsetHorizontal,
            right: isRtl ? offsetHorizontal : undefined,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size : '100%',
            width: isHorizontal ? size : '100%'
          };
        }

        return style;
      };

      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {
        return {};
      });

      _this._onScrollHorizontal = function (event) {
        var _event$currentTarget = event.currentTarget,
            clientWidth = _event$currentTarget.clientWidth,
            scrollLeft = _event$currentTarget.scrollLeft,
            scrollWidth = _event$currentTarget.scrollWidth;

        _this.setState(function (prevState) {
          if (prevState.scrollOffset === scrollLeft) {
            // Scroll position may have been updated by cDM/cDU,
            // In which case we don't need to trigger another render,
            // And we don't want to update state.isScrolling.
            return null;
          }

          var direction = _this.props.direction;
          var scrollOffset = scrollLeft;

          if (direction === 'rtl') {
            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.
            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.
            switch (getRTLOffsetType()) {
              case 'negative':
                scrollOffset = -scrollLeft;
                break;

              case 'positive-descending':
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.


          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',
            scrollOffset: scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };

      _this._onScrollVertical = function (event) {
        var _event$currentTarget2 = event.currentTarget,
            clientHeight = _event$currentTarget2.clientHeight,
            scrollHeight = _event$currentTarget2.scrollHeight,
            scrollTop = _event$currentTarget2.scrollTop;

        _this.setState(function (prevState) {
          if (prevState.scrollOffset === scrollTop) {
            // Scroll position may have been updated by cDM/cDU,
            // In which case we don't need to trigger another render,
            // And we don't want to update state.isScrolling.
            return null;
          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.


          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',
            scrollOffset: scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };

      _this._outerRefSetter = function (ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;

        if (typeof outerRef === 'function') {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {
          outerRef.current = ref;
        }
      };

      _this._resetIsScrollingDebounced = function () {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }

        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };

      _this._resetIsScrolling = function () {
        _this._resetIsScrollingTimeoutId = null;

        _this.setState({
          isScrolling: false
        }, function () {
          // Clear style cache after state update has been committed.
          // This way we don't break pure sCU for items that don't use isScrolling param.
          _this._getItemStyleCache(-1, null);
        });
      };

      return _this;
    }

    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps(nextProps);
      return null;
    };

    var _proto = List.prototype;

    _proto.scrollTo = function scrollTo(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function (prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }

        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',
          scrollOffset: scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };

    _proto.scrollToItem = function scrollToItem(index, align) {
      if (align === void 0) {
        align = 'auto';
      }

      var itemCount = this.props.itemCount;
      var scrollOffset = this.state.scrollOffset;
      index = Math.max(0, Math.min(index, itemCount - 1));
      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));
    };

    _proto.componentDidMount = function componentDidMount() {
      var _this$props2 = this.props,
          direction = _this$props2.direction,
          initialScrollOffset = _this$props2.initialScrollOffset,
          layout = _this$props2.layout;

      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {
        var outerRef = this._outerRef; // TODO Deprecate direction "horizontal"

        if (direction === 'horizontal' || layout === 'horizontal') {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }

      this._callPropsCallbacks();
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props3 = this.props,
          direction = _this$props3.direction,
          layout = _this$props3.layout;
      var _this$state = this.state,
          scrollOffset = _this$state.scrollOffset,
          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;

      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef; // TODO Deprecate direction "horizontal"

        if (direction === 'horizontal' || layout === 'horizontal') {
          if (direction === 'rtl') {
            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
            // So we need to determine which browser behavior we're dealing with, and mimic it.
            switch (getRTLOffsetType()) {
              case 'negative':
                outerRef.scrollLeft = -scrollOffset;
                break;

              case 'positive-ascending':
                outerRef.scrollLeft = scrollOffset;
                break;

              default:
                var clientWidth = outerRef.clientWidth,
                    scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }

      this._callPropsCallbacks();
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };

    _proto.render = function render() {
      var _this$props4 = this.props,
          children = _this$props4.children,
          className = _this$props4.className,
          direction = _this$props4.direction,
          height = _this$props4.height,
          innerRef = _this$props4.innerRef,
          innerElementType = _this$props4.innerElementType,
          innerTagName = _this$props4.innerTagName,
          itemCount = _this$props4.itemCount,
          itemData = _this$props4.itemData,
          _this$props4$itemKey = _this$props4.itemKey,
          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,
          layout = _this$props4.layout,
          outerElementType = _this$props4.outerElementType,
          outerTagName = _this$props4.outerTagName,
          style = _this$props4.style,
          useIsScrolling = _this$props4.useIsScrolling,
          width = _this$props4.width;
      var isScrolling = this.state.isScrolling; // TODO Deprecate direction "horizontal"

      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;

      var _this$_getRangeToRend = this._getRangeToRender(),
          startIndex = _this$_getRangeToRend[0],
          stopIndex = _this$_getRangeToRend[1];

      var items = [];

      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items.push(createElement(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : undefined,
            style: this._getItemStyle(_index)
          }));
        }
      } // Read this value AFTER items have been created,
      // So their actual sizes (if variable) are taken into consideration.


      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);
      return createElement(outerElementType || outerTagName || 'div', {
        className: className,
        onScroll: onScroll,
        ref: this._outerRefSetter,
        style: _extends$4({
          position: 'relative',
          height: height,
          width: width,
          overflow: 'auto',
          WebkitOverflowScrolling: 'touch',
          willChange: 'transform',
          direction: direction
        }, style)
      }, createElement(innerElementType || innerTagName || 'div', {
        children: items,
        ref: innerRef,
        style: {
          height: isHorizontal ? '100%' : estimatedTotalSize,
          pointerEvents: isScrolling ? 'none' : undefined,
          width: isHorizontal ? estimatedTotalSize : '100%'
        }
      }));
    };

    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === 'function') {
        var itemCount = this.props.itemCount;

        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(),
              _overscanStartIndex = _this$_getRangeToRend2[0],
              _overscanStopIndex = _this$_getRangeToRend2[1],
              _visibleStartIndex = _this$_getRangeToRend2[2],
              _visibleStopIndex = _this$_getRangeToRend2[3];

          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }

      if (typeof this.props.onScroll === 'function') {
        var _this$state2 = this.state,
            _scrollDirection = _this$state2.scrollDirection,
            _scrollOffset = _this$state2.scrollOffset,
            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;

        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    }; // Lazily create and cache item styles while scrolling,
    // So that pure component sCU will prevent re-renders.
    // We maintain this cache, and pass a style prop rather than index,
    // So that List can clear cached styles and force item re-render if necessary.


    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props5 = this.props,
          itemCount = _this$props5.itemCount,
          overscanCount = _this$props5.overscanCount;
      var _this$state3 = this.state,
          isScrolling = _this$state3.isScrolling,
          scrollDirection = _this$state3.scrollDirection,
          scrollOffset = _this$state3.scrollOffset;

      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }

      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.
      // If there isn't at least one extra item, tab loops back around.

      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };

    return List;
  }(PureComponent), _class.defaultProps = {
    direction: 'ltr',
    itemData: undefined,
    layout: 'vertical',
    overscanCount: 2,
    useIsScrolling: false
  }, _temp;
} // NOTE: I considered further wrapping individual items with a pure ListItem component.
// This would avoid ever calling the render function for the same index more than once,
// But it would also add the overhead of a lot of components/fibers.
// I assume people already do this (render function returning a class component),
// So my doing it would just unnecessarily double the wrappers.

var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
  var children = _ref2.children,
      direction = _ref2.direction,
      height = _ref2.height,
      layout = _ref2.layout,
      innerTagName = _ref2.innerTagName,
      outerTagName = _ref2.outerTagName,
      width = _ref2.width;
  var instance = _ref3.instance;

  {
    if (innerTagName != null || outerTagName != null) {
      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {
        devWarningsTagName$1.add(instance);
        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');
      }
    } // TODO Deprecate direction "horizontal"


    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';

    switch (direction) {
      case 'horizontal':
      case 'vertical':
        if (devWarningsDirection && !devWarningsDirection.has(instance)) {
          devWarningsDirection.add(instance);
          console.warn('The direction prop should be either "ltr" (default) or "rtl". ' + 'Please use the layout prop to specify "vertical" (default) or "horizontal" orientation.');
        }

        break;

      case 'ltr':
      case 'rtl':
        // Valid values
        break;

      default:
        throw Error('An invalid "direction" prop has been specified. ' + 'Value should be either "ltr" or "rtl". ' + ("\"" + direction + "\" was specified."));
    }

    switch (layout) {
      case 'horizontal':
      case 'vertical':
        // Valid values
        break;

      default:
        throw Error('An invalid "layout" prop has been specified. ' + 'Value should be either "horizontal" or "vertical". ' + ("\"" + layout + "\" was specified."));
    }

    if (children == null) {
      throw Error('An invalid "children" prop has been specified. ' + 'Value should be a React component. ' + ("\"" + (children === null ? 'null' : typeof children) + "\" was specified."));
    }

    if (isHorizontal && typeof width !== 'number') {
      throw Error('An invalid "width" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + ("\"" + (width === null ? 'null' : typeof width) + "\" was specified."));
    } else if (!isHorizontal && typeof height !== 'number') {
      throw Error('An invalid "height" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + ("\"" + (height === null ? 'null' : typeof height) + "\" was specified."));
    }
  }
};

var DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;

var getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {
  var _ref = props,
      itemSize = _ref.itemSize;
  var itemMetadataMap = instanceProps.itemMetadataMap,
      lastMeasuredIndex = instanceProps.lastMeasuredIndex;

  if (index > lastMeasuredIndex) {
    var offset = 0;

    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset = itemMetadata.offset + itemMetadata.size;
    }

    for (var i = lastMeasuredIndex + 1; i <= index; i++) {
      var size = itemSize(i);
      itemMetadataMap[i] = {
        offset: offset,
        size: size
      };
      offset += size;
    }

    instanceProps.lastMeasuredIndex = index;
  }

  return itemMetadataMap[index];
};

var findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {
  var itemMetadataMap = instanceProps.itemMetadataMap,
      lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;

  if (lastMeasuredItemOffset >= offset) {
    // If we've already measured items within this range just use a binary search as it's faster.
    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);
  } else {
    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.
    // The overall complexity for this approach is O(log n).
    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);
  }
};

var findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;

    if (currentOffset === offset) {
      return middle;
    } else if (currentOffset < offset) {
      low = middle + 1;
    } else if (currentOffset > offset) {
      high = middle - 1;
    }
  }

  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};

var findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {
  var itemCount = props.itemCount;
  var interval = 1;

  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {
    index += interval;
    interval *= 2;
  }

  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);
};

var getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {
  var itemCount = _ref2.itemCount;
  var itemMetadataMap = _ref3.itemMetadataMap,
      estimatedItemSize = _ref3.estimatedItemSize,
      lastMeasuredIndex = _ref3.lastMeasuredIndex;
  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.
  // https://github.com/bvaughn/react-window/pull/138

  if (lastMeasuredIndex >= itemCount) {
    lastMeasuredIndex = itemCount - 1;
  }

  if (lastMeasuredIndex >= 0) {
    var itemMetadata = itemMetadataMap[lastMeasuredIndex];
    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;
  }

  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};

var VariableSizeList =
/*#__PURE__*/
createListComponent({
  getItemOffset: function getItemOffset(props, index, instanceProps) {
    return getItemMetadata$1(props, index, instanceProps).offset;
  },
  getItemSize: function getItemSize(props, index, instanceProps) {
    return instanceProps.itemMetadataMap[index].size;
  },
  getEstimatedTotalSize: getEstimatedTotalSize,
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {
    var direction = props.direction,
        height = props.height,
        layout = props.layout,
        width = props.width; // TODO Deprecate direction "horizontal"

    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var size = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,
    // To ensure it reflects actual measurements instead of just estimates.

    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);
    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));
    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);

    if (align === 'smart') {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        return Math.round(minOffset + (maxOffset - minOffset) / 2);

      case 'auto':
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {
    return findNearestItem$1(props, instanceProps, offset);
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {
    var direction = props.direction,
        height = props.height,
        itemCount = props.itemCount,
        layout = props.layout,
        width = props.width; // TODO Deprecate direction "horizontal"

    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var size = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);
    var maxOffset = scrollOffset + size;
    var offset = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;

    while (stopIndex < itemCount - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;
    }

    return stopIndex;
  },
  initInstanceProps: function initInstanceProps(props, instance) {
    var _ref4 = props,
        estimatedItemSize = _ref4.estimatedItemSize;
    var instanceProps = {
      itemMetadataMap: {},
      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,
      lastMeasuredIndex: -1
    };

    instance.resetAfterIndex = function (index, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }

      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,
      // But since styles are only cached while scrolling is in progress-
      // It seems an unnecessary optimization.
      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.

      instance._getItemStyleCache(-1);

      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };

    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps(_ref5) {
    var itemSize = _ref5.itemSize;

    {
      if (typeof itemSize !== 'function') {
        throw Error('An invalid "itemSize" prop has been specified. ' + 'Value should be a function. ' + ("\"" + (itemSize === null ? 'null' : typeof itemSize) + "\" was specified."));
      }
    }
  }
});

// Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349
function shallowDiffers(prev, next) {
  for (var attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }

  for (var _attribute in next) {
    if (prev[_attribute] !== next[_attribute]) {
      return true;
    }
  }

  return false;
}

// It knows to compare individual style props and ignore the wrapper object.
// See https://reactjs.org/docs/react-api.html#reactmemo

function areEqual(prevProps, nextProps) {
  var prevStyle = prevProps.style,
      prevRest = _objectWithoutPropertiesLoose$3(prevProps, ["style"]);

  var nextStyle = nextProps.style,
      nextRest = _objectWithoutPropertiesLoose$3(nextProps, ["style"]);

  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
}

function CheckboxVirtualized(_ref) {
  var index = _ref.index,
      style = _ref.style,
      data = _ref.data;
  var rows = data.rows,
      selectedRows = data.selectedRows,
      highlightedRows = data.highlightedRows,
      unseenRows = data.unseenRows,
      hoveredRowIndex = data.hoveredRowIndex,
      setHoveredRowIndex = data.setHoveredRowIndex;
  var row = rows[index];
  var options = row.options,
      globalOptions = row.globalOptions;
  var rowSelection = globalOptions.rowSelection;
  var toggleRowSelection = globalOptions.handlers.toggleRowSelection;
  var rowIndex = options.rowIndex;
  var isUnseen = unseenRows.includes(index);
  var isHovered = index === hoveredRowIndex;
  var checkboxSelected = selectedRows.includes(index);
  var checkboxDisabled = selectedRows.length >= rowSelection.limit && !checkboxSelected;
  var rowSelected = selectedRows.includes(index) || highlightedRows.includes(index);
  var onCheckboxChange = useCallback(function (event) {
    if (checkboxDisabled) {
      return;
    }

    event.preventDefault();
    toggleRowSelection(rowIndex, checkboxSelected);
  }, [rowIndex, checkboxSelected, checkboxDisabled]);
  var rowClassName = useRowClassName({
    types: [rowTypes.body],
    options: {
      selected: rowSelected,
      isHovered: isHovered
    },
    globalOptions: globalOptions
  });
  var checkboxClassName = useBodyCheckboxClassName({
    options: {
      isUnseen: isUnseen,
      isHovered: isHovered
    },
    globalOptions: globalOptions
  });
  var onMouseEnter = useCallback(function () {
    return setHoveredRowIndex(rowIndex);
  }, [rowIndex]);
  var onMouseLeave = useCallback(function () {
    return setHoveredRowIndex();
  }, []);
  return /*#__PURE__*/React__default.createElement("div", {
    className: rowClassName,
    style: style,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave
  }, /*#__PURE__*/React__default.createElement(CheckboxCell$1, {
    className: checkboxClassName,
    checked: checkboxSelected,
    disabled: checkboxDisabled,
    onCheckboxChange: onCheckboxChange
  }));
}

CheckboxVirtualized.propTypes = {
  index: PropTypes.number.isRequired,
  style: PropTypes.object.isRequired,
  data: PropTypes.shape({
    rows: PropTypes.array.isRequired,
    selectedRows: PropTypes.arrayOf(PropTypes.number).isRequired,
    highlightedRows: PropTypes.arrayOf(PropTypes.number).isRequired,
    unseenRows: PropTypes.arrayOf(PropTypes.number).isRequired,
    hoveredRowIndex: PropTypes.number,
    setHoveredRowIndex: PropTypes.func.isRequired
  }).isRequired
};
var CheckboxVirtualized$1 = /*#__PURE__*/memo(CheckboxVirtualized, areEqual);

var Checkboxes = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var _checkboxesStyle$tabl;

  var height = _ref.height,
      rowsLength = _ref.rowsLength,
      getItemSize = _ref.getItemSize,
      itemData = _ref.itemData,
      tableType = _ref.tableType,
      isHorizontallyScrolling = _ref.isHorizontallyScrolling;
  var width = (_checkboxesStyle$tabl = checkboxesStyle[tableType].width) !== null && _checkboxesStyle$tabl !== void 0 ? _checkboxesStyle$tabl : checkboxesStyle[tableTypes.DEFAULT].width;
  var style = useCheckboxesStyle({
    width: width
  });
  var className = useCheckboxesClassName({
    options: {
      isHorizontallyScrolling: isHorizontallyScrolling,
      tableType: tableType
    }
  });
  return /*#__PURE__*/React__default.createElement(VariableSizeList, {
    ref: ref,
    className: className,
    height: height,
    itemCount: rowsLength,
    itemSize: getItemSize,
    itemData: itemData,
    layout: "vertical",
    style: style
  }, CheckboxVirtualized$1);
});
Checkboxes.displayName = 'Checkboxes';
Checkboxes.propTypes = {
  height: PropTypes.number.isRequired,
  rowsLength: PropTypes.number.isRequired,
  getItemSize: PropTypes.func.isRequired,
  itemData: PropTypes.shape({
    rows: PropTypes.array.isRequired,
    selectedRows: PropTypes.arrayOf(PropTypes.number).isRequired,
    unseenRows: PropTypes.arrayOf(PropTypes.number).isRequired
  }).isRequired,
  tableType: PropTypes.string.isRequired,
  isHorizontallyScrolling: PropTypes.bool.isRequired
};

function isInteger(value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
}

function isRangeVisible(_ref) {
  var lastRenderedStartIndex = _ref.lastRenderedStartIndex,
      lastRenderedStopIndex = _ref.lastRenderedStopIndex,
      startIndex = _ref.startIndex,
      stopIndex = _ref.stopIndex;

  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);
}

function scanForUnloadedRanges(_ref) {
  var isItemLoaded = _ref.isItemLoaded,
      itemCount = _ref.itemCount,
      minimumBatchSize = _ref.minimumBatchSize,
      startIndex = _ref.startIndex,
      stopIndex = _ref.stopIndex;

  var unloadedRanges = [];

  var rangeStartIndex = null;
  var rangeStopIndex = null;

  for (var _index = startIndex; _index <= stopIndex; _index++) {
    var loaded = isItemLoaded(_index);

    if (!loaded) {
      rangeStopIndex = _index;
      if (rangeStartIndex === null) {
        rangeStartIndex = _index;
      }
    } else if (rangeStopIndex !== null) {
      unloadedRanges.push(rangeStartIndex, rangeStopIndex);

      rangeStartIndex = rangeStopIndex = null;
    }
  }

  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.
  // Scan forward to try filling our :minimumBatchSize.
  if (rangeStopIndex !== null) {
    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), itemCount - 1);

    for (var _index2 = rangeStopIndex + 1; _index2 <= potentialStopIndex; _index2++) {
      if (!isItemLoaded(_index2)) {
        rangeStopIndex = _index2;
      } else {
        break;
      }
    }

    unloadedRanges.push(rangeStartIndex, rangeStopIndex);
  }

  // Check to see if our first range ended prematurely.
  // In this case we should scan backwards to try filling our :minimumBatchSize.
  if (unloadedRanges.length) {
    while (unloadedRanges[1] - unloadedRanges[0] + 1 < minimumBatchSize && unloadedRanges[0] > 0) {
      var _index3 = unloadedRanges[0] - 1;

      if (!isItemLoaded(_index3)) {
        unloadedRanges[0] = _index3;
      } else {
        break;
      }
    }
  }

  return unloadedRanges;
}

var classCallCheck$1 = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass$1 = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var InfiniteLoader = function (_PureComponent) {
  inherits(InfiniteLoader, _PureComponent);

  function InfiniteLoader() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck$1(this, InfiniteLoader);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = InfiniteLoader.__proto__ || Object.getPrototypeOf(InfiniteLoader)).call.apply(_ref, [this].concat(args))), _this), _this._lastRenderedStartIndex = -1, _this._lastRenderedStopIndex = -1, _this._memoizedUnloadedRanges = [], _this._onItemsRendered = function (_ref2) {
      var visibleStartIndex = _ref2.visibleStartIndex,
          visibleStopIndex = _ref2.visibleStopIndex;

      {
        if (!isInteger(visibleStartIndex) || !isInteger(visibleStopIndex)) {
          console.warn('Invalid onItemsRendered signature; please refer to InfiniteLoader documentation.');
        }

        if (typeof _this.props.loadMoreRows === 'function') {
          console.warn('InfiniteLoader "loadMoreRows" prop has been renamed to "loadMoreItems".');
        }
      }

      _this._lastRenderedStartIndex = visibleStartIndex;
      _this._lastRenderedStopIndex = visibleStopIndex;

      _this._ensureRowsLoaded(visibleStartIndex, visibleStopIndex);
    }, _this._setRef = function (listRef) {
      _this._listRef = listRef;
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass$1(InfiniteLoader, [{
    key: 'resetloadMoreItemsCache',
    value: function resetloadMoreItemsCache() {
      var autoReload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      this._memoizedUnloadedRanges = [];

      if (autoReload) {
        this._ensureRowsLoaded(this._lastRenderedStartIndex, this._lastRenderedStopIndex);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      {
        if (this._listRef == null) {
          console.warn('Invalid list ref; please refer to InfiniteLoader documentation.');
        }
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var children = this.props.children;


      return children({
        onItemsRendered: this._onItemsRendered,
        ref: this._setRef
      });
    }
  }, {
    key: '_ensureRowsLoaded',
    value: function _ensureRowsLoaded(startIndex, stopIndex) {
      var _props = this.props,
          isItemLoaded = _props.isItemLoaded,
          itemCount = _props.itemCount,
          _props$minimumBatchSi = _props.minimumBatchSize,
          minimumBatchSize = _props$minimumBatchSi === undefined ? 10 : _props$minimumBatchSi,
          _props$threshold = _props.threshold,
          threshold = _props$threshold === undefined ? 15 : _props$threshold;


      var unloadedRanges = scanForUnloadedRanges({
        isItemLoaded: isItemLoaded,
        itemCount: itemCount,
        minimumBatchSize: minimumBatchSize,
        startIndex: Math.max(0, startIndex - threshold),
        stopIndex: Math.min(itemCount - 1, stopIndex + threshold)
      });

      // Avoid calling load-rows unless range has changed.
      // This shouldn't be strictly necessary, but is maybe nice to do.
      if (this._memoizedUnloadedRanges.length !== unloadedRanges.length || this._memoizedUnloadedRanges.some(function (startOrStop, index) {
        return unloadedRanges[index] !== startOrStop;
      })) {
        this._memoizedUnloadedRanges = unloadedRanges;
        this._loadUnloadedRanges(unloadedRanges);
      }
    }
  }, {
    key: '_loadUnloadedRanges',
    value: function _loadUnloadedRanges(unloadedRanges) {
      var _this2 = this;

      // loadMoreRows was renamed to loadMoreItems in v1.0.3; will be removed in v2.0
      var loadMoreItems = this.props.loadMoreItems || this.props.loadMoreRows;

      var _loop = function _loop(i) {
        var startIndex = unloadedRanges[i];
        var stopIndex = unloadedRanges[i + 1];
        var promise = loadMoreItems(startIndex, stopIndex);
        if (promise != null) {
          promise.then(function () {
            // Refresh the visible rows if any of them have just been loaded.
            // Otherwise they will remain in their unloaded visual state.
            if (isRangeVisible({
              lastRenderedStartIndex: _this2._lastRenderedStartIndex,
              lastRenderedStopIndex: _this2._lastRenderedStopIndex,
              startIndex: startIndex,
              stopIndex: stopIndex
            })) {
              // Handle an unmount while promises are still in flight.
              if (_this2._listRef == null) {
                return;
              }

              // Resize cached row sizes for VariableSizeList,
              // otherwise just re-render the list.
              if (typeof _this2._listRef.resetAfterIndex === 'function') {
                _this2._listRef.resetAfterIndex(startIndex, true);
              } else {
                // HACK reset temporarily cached item styles to force PureComponent to re-render.
                // This is pretty gross, but I'm okay with it for now.
                // Don't judge me.
                if (typeof _this2._listRef._getItemStyleCache === 'function') {
                  _this2._listRef._getItemStyleCache(-1);
                }
                _this2._listRef.forceUpdate();
              }
            }
          });
        }
      };

      for (var i = 0; i < unloadedRanges.length; i += 2) {
        _loop(i);
      }
    }
  }]);
  return InfiniteLoader;
}(PureComponent);

function InfiniteScroll(_ref) {
  var _itemData$rows$length, _itemData$rows;

  var children = _ref.children,
      itemData = _ref.itemData,
      infiniteScroll = _ref.infiniteScroll,
      hasMore = _ref.hasMore,
      loadMore = _ref.loadMore;
  var infiniteThreshold = itemData.infiniteThreshold,
      setIsSpinnerShown = itemData.setIsSpinnerShown;
  var rowCount = (_itemData$rows$length = itemData === null || itemData === void 0 ? void 0 : (_itemData$rows = itemData.rows) === null || _itemData$rows === void 0 ? void 0 : _itemData$rows.length) !== null && _itemData$rows$length !== void 0 ? _itemData$rows$length : 0;
  var hasMoreItems = hasMore();
  var isItemLoaded = useCallback(function (index) {
    return !hasMoreItems || index !== rowCount - 1;
  }, [rowCount, hasMoreItems]);
  var data = useMemo(function () {
    return _objectSpread2(_objectSpread2({}, itemData), {}, {
      isItemLoaded: isItemLoaded,
      infiniteScroll: infiniteScroll
    });
  }, [itemData, isItemLoaded, infiniteScroll]);
  var loadMoreItems = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!hasMoreItems) {
              _context.next = 5;
              break;
            }

            setIsSpinnerShown(true);
            _context.next = 4;
            return loadMore();

          case 4:
            setIsSpinnerShown(false);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })), [hasMoreItems, loadMore]);

  if (!hasMore || !loadMore || infiniteScroll.isDisabled) {
    return children({
      itemData: itemData,
      itemCount: rowCount
    });
  }

  var itemCount = hasMoreItems ? rowCount + 1 : rowCount;
  return /*#__PURE__*/React__default.createElement(InfiniteLoader, {
    loadMoreItems: loadMoreItems,
    itemCount: itemCount,
    isItemLoaded: isItemLoaded,
    threshold: infiniteThreshold
  }, function (_ref3) {
    var onItemsRendered = _ref3.onItemsRendered,
        ref = _ref3.ref;
    return children({
      onItemsRendered: onItemsRendered,
      ref: ref,
      itemCount: itemCount,
      itemData: data
    });
  });
}

InfiniteScroll.propTypes = {
  children: PropTypes.func.isRequired,
  itemData: PropTypes.object.isRequired,
  infiniteScroll: infiniteScrollPropTypes,
  hasMore: PropTypes.func,
  loadMore: PropTypes.func
};

function BodyCell(_ref) {
  var cell = _ref.cell,
      globalOptions = _ref.globalOptions,
      withRightBorder = _ref.withRightBorder;
  var content = cell.content,
      options = cell.options;
  var style = options.style;
  var className = useCellClassName({
    types: ['body'],
    options: {
      withRightBorder: withRightBorder
    },
    globalOptions: globalOptions
  });
  return /*#__PURE__*/React__default.createElement("div", {
    className: className,
    style: style
  }, /*#__PURE__*/React__default.createElement(ContentWrapper$1, null, content));
}

BodyCell.propTypes = {
  cell: cellPropTypes,
  globalOptions: globalOptionsPropTypes,
  withRightBorder: PropTypes.bool
};
var BodyCell$1 = /*#__PURE__*/memo(BodyCell);

function BodyRow(_ref) {
  var cells = _ref.cells,
      options = _ref.options,
      globalOptions = _ref.globalOptions,
      setHoveredRowIndex = _ref.setHoveredRowIndex;
  var rowIndex = options.rowIndex,
      style = options.style,
      selected = options.selected,
      isHovered = options.isHovered,
      hasRightEmptySpace = options.hasRightEmptySpace;
  var handlers = globalOptions.handlers;
  var onRowClick = handlers.onRowClick;
  var rowClassName = useRowClassName({
    types: [rowTypes.body],
    options: {
      selected: selected,
      isHovered: isHovered
    },
    globalOptions: globalOptions
  });
  var onClick = useCallback(function () {
    onRowClick(rowIndex);
  }, [rowIndex, onRowClick]);
  var onMouseEnter = useCallback(function () {
    return setHoveredRowIndex(rowIndex);
  }, [rowIndex]);
  var onMouseLeave = useCallback(function () {
    return setHoveredRowIndex();
  }, []);
  return /*#__PURE__*/React__default.createElement("div", {
    className: rowClassName,
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    role: "row",
    style: style
  }, cells.map(function (cell, index) {
    if (cell.options.isLast) {
      return /*#__PURE__*/React__default.createElement(BodyCell$1, {
        key: index,
        cell: cell,
        globalOptions: globalOptions,
        withRightBorder: hasRightEmptySpace
      });
    }

    return /*#__PURE__*/React__default.createElement(BodyCell$1, {
      key: index,
      cell: cell,
      globalOptions: globalOptions
    });
  }));
}

BodyRow.propTypes = {
  cells: PropTypes.array.isRequired,
  options: PropTypes.shape({
    rowIndex: PropTypes.number.isRequired,
    style: PropTypes.object,
    selected: PropTypes.bool.isRequired,
    isHovered: PropTypes.bool.isRequired,
    hasRightEmptySpace: PropTypes.bool.isRequired
  }).isRequired,
  globalOptions: globalOptionsPropTypes,
  setHoveredRowIndex: PropTypes.func.isRequired
};
var BodyRow$1 = /*#__PURE__*/memo(BodyRow);

function BodyVirtualizedRow(_ref) {
  var index = _ref.index,
      virtualizedStyle = _ref.style,
      data = _ref.data;
  var rows = data.rows,
      selectedRows = data.selectedRows,
      highlightedRows = data.highlightedRows,
      unseenRows = data.unseenRows,
      setHoveredRowIndex = data.setHoveredRowIndex,
      hoveredRowIndex = data.hoveredRowIndex,
      isSpinnerShown = data.isSpinnerShown,
      hasRightEmptySpace = data.hasRightEmptySpace;
  var row = rows[index];
  var selected = selectedRows.includes(index) || highlightedRows.includes(index);
  var isUnseen = unseenRows.includes(index);
  var isHovered = index === hoveredRowIndex;
  var options = useMemo(function () {
    var _row$options, _row$options$style, _row$options2;

    return _objectSpread2(_objectSpread2({}, (_row$options = row === null || row === void 0 ? void 0 : row.options) !== null && _row$options !== void 0 ? _row$options : {}), {}, {
      style: _objectSpread2(_objectSpread2({}, (_row$options$style = row === null || row === void 0 ? void 0 : (_row$options2 = row.options) === null || _row$options2 === void 0 ? void 0 : _row$options2.style) !== null && _row$options$style !== void 0 ? _row$options$style : {}), virtualizedStyle),
      selected: selected,
      isUnseen: isUnseen,
      isHovered: isHovered,
      setHoveredRowIndex: setHoveredRowIndex,
      hasRightEmptySpace: hasRightEmptySpace
    });
  }, [row, selected, isUnseen, isHovered, setHoveredRowIndex, virtualizedStyle, hasRightEmptySpace]);

  if (!row && isSpinnerShown) {
    return /*#__PURE__*/React__default.createElement("div", {
      style: _objectSpread2(_objectSpread2({}, virtualizedStyle), {}, {
        height: infiniteLoaderStyle.height
      })
    });
  }

  if (!row) {
    return null;
  }

  var cells = row.cells,
      globalOptions = row.globalOptions;
  return /*#__PURE__*/React__default.createElement(BodyRow$1, {
    key: index,
    cells: cells,
    options: options,
    globalOptions: globalOptions,
    setHoveredRowIndex: setHoveredRowIndex
  });
}

BodyVirtualizedRow.propTypes = {
  index: PropTypes.number.isRequired,
  style: PropTypes.object,
  data: PropTypes.shape({
    rows: PropTypes.array.isRequired,
    selectedRows: PropTypes.arrayOf(PropTypes.number).isRequired,
    highlightedRows: PropTypes.arrayOf(PropTypes.number).isRequired,
    unseenRows: PropTypes.arrayOf(PropTypes.number).isRequired,
    isItemLoaded: PropTypes.func,
    infiniteScroll: infiniteScrollPropTypes,
    setHoveredRowIndex: PropTypes.func.isRequired,
    hoveredRowIndex: PropTypes.number,
    isSpinnerShown: PropTypes.bool.isRequired,
    hasRightEmptySpace: PropTypes.bool.isRequired
  })
};
var BodyVirtualizedRow$1 = /*#__PURE__*/memo(BodyVirtualizedRow, areEqual);

var style = {
  overflow: 'visible',
  flexGrow: 1
};
var BodyRows = /*#__PURE__*/forwardRef(function (_ref, _ref3) {
  var height = _ref.height,
      bodyRowsItemData = _ref.itemData,
      getItemSize = _ref.getItemSize,
      globalOptions = _ref.globalOptions;
  var _globalOptions$handle = globalOptions.handlers.infiniteScroll,
      hasMore = _globalOptions$handle.hasMore,
      loadMore = _globalOptions$handle.loadMore;
  return /*#__PURE__*/React__default.createElement(InfiniteScroll, {
    itemData: bodyRowsItemData,
    infiniteScroll: globalOptions.infiniteScroll,
    loadMore: loadMore,
    hasMore: hasMore
  }, function (_ref2) {
    var itemData = _ref2.itemData,
        itemCount = _ref2.itemCount,
        onItemsRendered = _ref2.onItemsRendered,
        infiniteScrollRef = _ref2.ref;
    return /*#__PURE__*/React__default.createElement(VariableSizeList, {
      ref: function ref(list) {
        // Give InfiniteLoader a reference to the list
        if (typeof infiniteScrollRef === 'function') {
          infiniteScrollRef(list);
        }

        if (list) {
          _ref3.current = list;
        }
      },
      className: bodyRowsClassName,
      height: height,
      itemCount: itemCount,
      itemSize: getItemSize,
      itemData: itemData,
      onItemsRendered: onItemsRendered,
      layout: "vertical",
      style: style,
      overscanCount: defaultOverscanRowsCount
    }, BodyVirtualizedRow$1);
  });
});
BodyRows.displayName = 'BodyRows';
BodyRows.propTypes = {
  height: PropTypes.number.isRequired,
  itemData: PropTypes.shape({
    rows: PropTypes.array.isRequired,
    selectedRows: PropTypes.arrayOf(PropTypes.number).isRequired,
    unseenRows: PropTypes.arrayOf(PropTypes.number).isRequired
  }).isRequired,
  getItemSize: PropTypes.func.isRequired,
  globalOptions: globalOptionsPropTypes.isRequired
};

function Action(_ref) {
  var rowIndex = _ref.rowIndex,
      action = _ref.action,
      hideActions = _ref.hideActions;
  var title = action.title,
      handler = action.handler;
  var onClick = useCallback(function () {
    handler(rowIndex);
    hideActions();
  }, [handler]);
  return /*#__PURE__*/React__default.createElement(Option, {
    style: rowActionStyle,
    onClick: onClick
  }, title);
}
Action.propTypes = {
  rowIndex: PropTypes.number.isRequired,
  action: rowActionPropTypes,
  hideActions: PropTypes.func.isRequired
};
function Actions(_ref2) {
  var rowIndex = _ref2.rowIndex,
      actions = _ref2.actions,
      hide = _ref2.hide;
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, actions.map(function (action, index) {
    if ((action === null || action === void 0 ? void 0 : action.type) === rowActionsTypes.SEPARATOR) {
      return /*#__PURE__*/React__default.createElement(Separator, {
        key: index
      });
    }

    return /*#__PURE__*/React__default.createElement(Action, {
      key: index,
      rowIndex: rowIndex,
      action: action,
      hideActions: hide
    });
  }));
}
Actions.propTypes = {
  rowIndex: PropTypes.number.isRequired,
  actions: PropTypes.arrayOf(rowActionPropTypes),
  hide: PropTypes.func.isRequired
};

function RowActionsCell(_ref3) {
  var rowIndex = _ref3.rowIndex,
      actions = _ref3.actions,
      globalOptions = _ref3.globalOptions;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      visible = _useState2[0],
      setVisible = _useState2[1];

  var hide = useCallback(function () {
    return setVisible(false);
  }, []);
  var onPopupVisibleChange = useCallback(function (status) {
    setVisible(status);
  }, []);
  return /*#__PURE__*/React__default.createElement(ActionCell, {
    type: cellTypes.body,
    globalOptions: globalOptions
  }, /*#__PURE__*/React__default.createElement(Popover, {
    visible: visible,
    placement: "bottom-end",
    spacing: {
      top: 's',
      bottom: 's'
    },
    content: /*#__PURE__*/React__default.createElement(Actions, {
      rowIndex: rowIndex,
      actions: actions,
      hide: hide
    }),
    onPopupVisibleChange: onPopupVisibleChange,
    portalTo: document.body
  }, /*#__PURE__*/React__default.createElement(Button, {
    style: {
      padding: 0,
      height: '24px',
      minWidth: '24px'
    },
    color: "ghost"
  }, /*#__PURE__*/React__default.createElement(Icon, {
    icon: "ellipsis",
    color: "black-64"
  }))));
}

RowActionsCell.propTypes = {
  rowIndex: PropTypes.number.isRequired,
  actions: PropTypes.arrayOf(rowActionPropTypes),
  globalOptions: globalOptionsPropTypes
};

function RowActionVirtualized(_ref) {
  var index = _ref.index,
      style = _ref.style,
      data = _ref.data;
  var rows = data.rows,
      setHoveredRowIndex = data.setHoveredRowIndex,
      hoveredRowIndex = data.hoveredRowIndex,
      selectedRows = data.selectedRows,
      highlightedRows = data.highlightedRows;
  var row = rows[index];
  var globalOptions = row.globalOptions;
  var getRowActions = globalOptions.handlers.getRowActions;
  var isHovered = index === hoveredRowIndex;
  var selected = selectedRows.includes(index) || highlightedRows.includes(index);
  var rowClassName = useRowClassName({
    types: [rowTypes.body],
    options: {
      selected: selected,
      isHovered: isHovered
    },
    globalOptions: globalOptions
  });
  var rowActions = getRowActions(index);
  var onMouseEnter = useCallback(function () {
    return setHoveredRowIndex(index);
  }, [index]);
  var onMouseLeave = useCallback(function () {
    return setHoveredRowIndex();
  }, []);

  if (!(rowActions !== null && rowActions !== void 0 && rowActions.length)) {
    return null;
  }

  return /*#__PURE__*/React__default.createElement("div", {
    className: rowClassName,
    style: style,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave
  }, /*#__PURE__*/React__default.createElement(RowActionsCell, {
    rowIndex: index,
    actions: rowActions,
    globalOptions: globalOptions
  }));
}

RowActionVirtualized.propTypes = {
  index: PropTypes.number.isRequired,
  style: PropTypes.object.isRequired,
  data: PropTypes.shape({
    rows: PropTypes.array.isRequired,
    setHoveredRowIndex: PropTypes.func.isRequired,
    hoveredRowIndex: PropTypes.number,
    selectedRows: PropTypes.arrayOf(PropTypes.number),
    highlightedRows: PropTypes.arrayOf(PropTypes.number)
  }).isRequired
};
var RowActionVirtualized$1 = /*#__PURE__*/memo(RowActionVirtualized, areEqual);

var RowActions = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var height = _ref.height,
      rowsLength = _ref.rowsLength,
      getItemSize = _ref.getItemSize,
      itemData = _ref.itemData;
  var isPlaceholder = itemData.isPlaceholder;
  var style = useRowActionsStyle({
    isPlaceholder: isPlaceholder
  });
  return /*#__PURE__*/React__default.createElement(VariableSizeList, {
    ref: ref,
    className: rowActionsClassName,
    height: height,
    itemCount: rowsLength,
    itemSize: getItemSize,
    itemData: itemData,
    layout: "vertical",
    style: style
  }, RowActionVirtualized$1);
});
RowActions.displayName = 'RowActions';
RowActions.propTypes = {
  height: PropTypes.number.isRequired,
  rowsLength: PropTypes.number.isRequired,
  getItemSize: PropTypes.func.isRequired,
  itemData: PropTypes.shape({
    rows: PropTypes.array.isRequired,
    isPlaceholder: PropTypes.bool
  }).isRequired
};

function InfiniteSpinner(_ref) {
  var _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options;
  var spinner = options.spinner;
  return /*#__PURE__*/React__default.createElement("div", {
    className: infiniteLoaderClassNames.root
  }, /*#__PURE__*/React__default.createElement(Spinner, {
    size: "s"
  }), (spinner === null || spinner === void 0 ? void 0 : spinner.caption) && /*#__PURE__*/React__default.createElement("div", {
    className: infiniteLoaderClassNames.caption
  }, spinner === null || spinner === void 0 ? void 0 : spinner.caption));
}

InfiniteSpinner.propTypes = {
  options: PropTypes.shape({
    spinner: PropTypes.shape({
      caption: PropTypes.string
    })
  })
};

var Body = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var rows = _ref.rows,
      selectedRows = _ref.selectedRows,
      highlightedRows = _ref.highlightedRows,
      unseenRows = _ref.unseenRows,
      height = _ref.height,
      globalOptions = _ref.globalOptions,
      isHorizontallyScrolling = _ref.isHorizontallyScrolling,
      style = _ref.style,
      hasRightEmptySpace = _ref.hasRightEmptySpace;

  var _useBodyRefs = useBodyRefs(ref),
      checkboxesRef = _useBodyRefs.checkboxesRef,
      rowsRef = _useBodyRefs.rowsRef,
      rowActionsRef = _useBodyRefs.rowActionsRef;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isSpinnerShown = _useState2[0],
      setIsSpinnerShown = _useState2[1];

  var _useState3 = useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      hoveredRowIndex = _useState4[0],
      setHoveredRowIndex = _useState4[1];

  var selectable = globalOptions.selectable,
      tableType = globalOptions.tableType;
  var _globalOptions$handle = globalOptions.handlers,
      getRowActions = _globalOptions$handle.getRowActions,
      onHeadCornerClick = _globalOptions$handle.onHeadCornerClick;
  var infiniteThreshold = globalOptions.infiniteScroll.threshold;
  var withRowActions = !(getRowActions !== null && getRowActions !== void 0 && getRowActions.isPlaceholder) || !(onHeadCornerClick !== null && onHeadCornerClick !== void 0 && onHeadCornerClick.isPlaceholder);
  var getItemSize = useBodyGetItemSize(rows);
  var checkboxesItemData = useMemo(function () {
    return {
      rows: rows,
      selectedRows: selectedRows,
      unseenRows: unseenRows,
      setHoveredRowIndex: setHoveredRowIndex,
      hoveredRowIndex: hoveredRowIndex,
      highlightedRows: highlightedRows
    };
  }, [rows, selectedRows, unseenRows, setHoveredRowIndex, hoveredRowIndex, highlightedRows]);
  var bodyRowsItemData = useMemo(function () {
    return {
      rows: rows,
      selectedRows: selectedRows,
      highlightedRows: highlightedRows,
      unseenRows: unseenRows,
      isSpinnerShown: isSpinnerShown,
      setIsSpinnerShown: setIsSpinnerShown,
      setHoveredRowIndex: setHoveredRowIndex,
      hoveredRowIndex: hoveredRowIndex,
      infiniteThreshold: infiniteThreshold,
      hasRightEmptySpace: hasRightEmptySpace
    };
  }, [rows, selectedRows, highlightedRows, unseenRows, isSpinnerShown, setIsSpinnerShown, setHoveredRowIndex, hoveredRowIndex, infiniteThreshold, hasRightEmptySpace]);
  var rowActionsItemData = useMemo(function () {
    return {
      rows: rows,
      setHoveredRowIndex: setHoveredRowIndex,
      hoveredRowIndex: hoveredRowIndex,
      selectedRows: selectedRows,
      highlightedRows: highlightedRows,
      isPlaceholder: getRowActions === null || getRowActions === void 0 ? void 0 : getRowActions.isPlaceholder
    };
  }, [rows, setHoveredRowIndex, hoveredRowIndex, selectedRows, highlightedRows, getRowActions === null || getRowActions === void 0 ? void 0 : getRowActions.isPlaceholder]);

  if (!height || !rows.length) {
    return null;
  }

  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
    className: bodyClassName,
    style: style,
    role: "rowgroup"
  }, /*#__PURE__*/React__default.createElement("div", {
    className: bodySectionsClassName
  }, selectable && /*#__PURE__*/React__default.createElement(Checkboxes, {
    ref: checkboxesRef,
    height: height,
    rowsLength: rows.length,
    getItemSize: getItemSize,
    itemData: checkboxesItemData,
    tableType: tableType,
    isHorizontallyScrolling: isHorizontallyScrolling
  }), /*#__PURE__*/React__default.createElement(BodyRows, {
    ref: rowsRef,
    height: height,
    getItemSize: getItemSize,
    itemData: bodyRowsItemData,
    globalOptions: globalOptions
  }), withRowActions && /*#__PURE__*/React__default.createElement(RowActions, {
    ref: rowActionsRef,
    height: height,
    rowsLength: rows.length,
    getItemSize: getItemSize,
    itemData: rowActionsItemData
  }))), isSpinnerShown && /*#__PURE__*/React__default.createElement(InfiniteSpinner, {
    options: globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.infiniteScroll
  }));
});
Body.displayName = 'Body';
Body.propTypes = {
  rows: PropTypes.array.isRequired,
  selectedRows: PropTypes.arrayOf(PropTypes.number),
  highlightedRows: PropTypes.arrayOf(PropTypes.number),
  unseenRows: PropTypes.arrayOf(PropTypes.number),
  height: PropTypes.number,
  globalOptions: globalOptionsPropTypes.isRequired,
  isHorizontallyScrolling: PropTypes.bool.isRequired,
  style: PropTypes.object.isRequired,
  hasRightEmptySpace: PropTypes.bool.isRequired
};

/**
 * @typedef {Object} Handlers
 * @property {Function[]} rowActions - a set of row actions.
 * @property {Function} onHeadCornerClick - on head corner click handler.
 */

/**
 * @typedef {Object} Options
 * @property {boolean} selectable - is the table selectable.
 * @property {string} tableType - table type.
 * @property {Handlers} handlers - table handler functions.
 */

/**
 * @summary Gets checkbox width addition expression to use in calc().
 * @param {Options} options - table options.
 * @returns {string} - checkbox width addition expression to use in calc().
 */

function getCheckboxesWidthAddition(_ref) {
  var selectable = _ref.selectable,
      tableType = _ref.tableType;

  if (!selectable) {
    return '';
  }

  return " + ".concat(checkboxesStyle[tableType].width);
}
/**
 * @summary Gets actions width addition expression to use in calc().
 * @param {Options} options - table options.
 * @returns {string} - actions width addition expression to use in calc().
 */

function getActionsWidthAddition(options) {
  var _options$handlers;

  var getRowActions = options.handlers.getRowActions;
  var onHeadCornerClick = (_options$handlers = options.handlers) === null || _options$handlers === void 0 ? void 0 : _options$handlers.onHeadCornerClick;
  var withRowActions = !(getRowActions !== null && getRowActions !== void 0 && getRowActions.isPlaceholder) || !(onHeadCornerClick !== null && onHeadCornerClick !== void 0 && onHeadCornerClick.isPlaceholder);

  if (withRowActions) {
    return " + ".concat(rowActionsStyle.width);
  }

  return '';
}
/**
 * @typedef {Object} GetTableStylePayload
 * @property {Object} staticWidths - static width value per each unit.
 * @property {number} fluidColumnsAmount - an amount of fluid columns
 * without the fixed width defined.
 * @property {Options} options - table options.
 */

/**
 * @typedef {Object} GetTableStyleResult
 * @property {string} minWidth - table min-width.
 */

/**
 * @summary Gets table style prop.
 * @param {GetTableStylePayload} payload - payload to calc the style.
 * @returns {GetTableStyleResult} - table style.
 */

function getTableStyle(_ref2) {
  var staticWidths = _ref2.staticWidths,
      fluidColumnsAmount = _ref2.fluidColumnsAmount,
      options = _ref2.options;
  var staticWidthAddition = getStaticWidthCalc('+', staticWidths);
  var checkboxWidthAddition = getCheckboxesWidthAddition(options);
  var actionsWidthAddition = getActionsWidthAddition(options);
  var minWidthCalc = "calc(\n\t\t".concat(fluidColumnsAmount, " * ").concat(cellStyle.minWidth, "\n\t\t").concat(staticWidthAddition, "\n\t\t").concat(checkboxWidthAddition, "\n\t\t").concat(actionsWidthAddition, ")");
  var minWidth = getNormalizedCalc(minWidthCalc);
  return {
    minWidth: minWidth
  };
}

var Table = /*#__PURE__*/forwardRef(function (_ref, passedRef) {
  var _rootRef$current, _rootRef$current$getB, _headRefs$current;

  var className = _ref.className,
      rows = _ref.rows,
      initColumns = _ref.columns,
      initOptions = _ref.options,
      initState = _ref.state;

  var _useTableRefs = useTableRefs(passedRef),
      initialRef = _useTableRefs.initialRef,
      rootRef = _useTableRefs.rootRef,
      horizontalScrollIndicatorRef = _useTableRefs.horizontalScrollIndicatorRef,
      headRefs = _useTableRefs.headRefs,
      bodyRefs = _useTableRefs.bodyRefs;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isGloballyDragging = _useState2[0],
      setIsGloballyDragging = _useState2[1];

  var initColumnEntries = Object.entries(initColumns);

  var _getColumnsLayout = getColumnsLayout(initColumnEntries),
      staticWidths = _getColumnsLayout.staticWidths,
      fluidColumnsAmount = _getColumnsLayout.fluidColumnsAmount;

  var _getProps = getProps({
    initColumnEntries: initColumnEntries,
    initOptions: initOptions,
    initState: initState
  }),
      columns = _getProps.columns,
      options = _getProps.options,
      state = _getProps.state;

  var columnEntries = Object.entries(columns);
  var rootClassName = useRootClassName({
    className: className,
    options: options
  });
  var tableStyle = getTableStyle({
    staticWidths: staticWidths,
    fluidColumnsAmount: fluidColumnsAmount,
    options: options
  });
  var bodyRows = getBodyRows({
    rows: rows,
    columnEntries: columnEntries,
    globalOptions: options
  });
  var columnSorting = state.columnSorting,
      unseenRows = state.unseenRows,
      selectedRows = state.selectedRows,
      highlightedRows = state.highlightedRows,
      headMessages = state.headMessages;
  var selectedCount = selectedRows.length;
  var totalCount = rows.length;
  var headCheckboxState = useHeadCheckboxState(selectedCount, totalCount);
  var isNoneSelected = headCheckboxState.isNoneSelected;
  var handlers = options.handlers;
  var toggleAllRowsSelection = handlers.toggleAllRowsSelection,
      useDndColumn = handlers.useDndColumn;
  var onHeadCheckboxChange = useCallback(function (event) {
    event.preventDefault();
    toggleAllRowsSelection(isNoneSelected);
  }, [isNoneSelected]);
  var startGloballyDragging = useCallback(function () {
    return setIsGloballyDragging(true);
  }, []);
  var finishGloballyDragging = useCallback(function () {
    return setIsGloballyDragging(false);
  }, []);
  var refRect = rootRef === null || rootRef === void 0 ? void 0 : (_rootRef$current = rootRef.current) === null || _rootRef$current === void 0 ? void 0 : (_rootRef$current$getB = _rootRef$current.getBoundingClientRect) === null || _rootRef$current$getB === void 0 ? void 0 : _rootRef$current$getB.call(_rootRef$current);
  var rootRect = useRootRect({
    rootRef: rootRef,
    refRect: refRect
  });
  var bodyHeight = useBodyHeight({
    rootRef: rootRef,
    rowsLength: rows.length
  });
  var lastColumnRect = useLastColumnRect((_headRefs$current = headRefs.current) === null || _headRefs$current === void 0 ? void 0 : _headRefs$current.columns);
  var lastColumnRight = useMemo(function () {
    var _lastColumnRect$right;

    return (_lastColumnRect$right = lastColumnRect.right) !== null && _lastColumnRect$right !== void 0 ? _lastColumnRect$right : 0;
  }, [lastColumnRect.right]);
  var hasRightEmptySpace = getHasRightEmptySpace({
    rootRef: rootRef,
    rootRect: rootRect,
    lastColumnRect: lastColumnRect,
    globalOptions: options
  });
  var isHorizontallyScrolling = useIsHorizontallyScrolling(horizontalScrollIndicatorRef);

  var onScroll = function onScroll(event) {
    var _initialRef$current, _initialRef$current$b, _initialRef$current$b2, _initialRef$current2, _initialRef$current2$, _initialRef$current2$2, _initialRef$current3, _initialRef$current3$, _initialRef$current3$2;

    initialRef === null || initialRef === void 0 ? void 0 : (_initialRef$current = initialRef.current) === null || _initialRef$current === void 0 ? void 0 : (_initialRef$current$b = _initialRef$current.body) === null || _initialRef$current$b === void 0 ? void 0 : (_initialRef$current$b2 = _initialRef$current$b.checkboxes) === null || _initialRef$current$b2 === void 0 ? void 0 : _initialRef$current$b2.scrollTo(event.target.scrollTop);
    initialRef === null || initialRef === void 0 ? void 0 : (_initialRef$current2 = initialRef.current) === null || _initialRef$current2 === void 0 ? void 0 : (_initialRef$current2$ = _initialRef$current2.body) === null || _initialRef$current2$ === void 0 ? void 0 : (_initialRef$current2$2 = _initialRef$current2$.rows) === null || _initialRef$current2$2 === void 0 ? void 0 : _initialRef$current2$2.scrollTo(event.target.scrollTop);
    initialRef === null || initialRef === void 0 ? void 0 : (_initialRef$current3 = initialRef.current) === null || _initialRef$current3 === void 0 ? void 0 : (_initialRef$current3$ = _initialRef$current3.body) === null || _initialRef$current3$ === void 0 ? void 0 : (_initialRef$current3$2 = _initialRef$current3$.rowActions) === null || _initialRef$current3$2 === void 0 ? void 0 : _initialRef$current3$2.scrollTo(event.target.scrollTop);
  };

  return /*#__PURE__*/React__default.createElement("div", {
    ref: rootRef,
    className: rootClassName,
    onScroll: onScroll,
    role: "grid",
    "aria-colcount": columnEntries.length,
    "aria-rowcount": totalCount
  }, /*#__PURE__*/React__default.createElement("div", {
    ref: horizontalScrollIndicatorRef,
    className: horizontalScrollIndicatorClassName
  }), /*#__PURE__*/React__default.createElement(Head$1, {
    ref: headRefs,
    columnEntries: columnEntries,
    columnSorting: columnSorting,
    globalOptions: options,
    checkboxState: headCheckboxState,
    onCheckboxChange: onHeadCheckboxChange,
    useDndColumn: useDndColumn,
    rootRect: rootRect,
    isGloballyDragging: isGloballyDragging,
    startGloballyDragging: startGloballyDragging,
    finishGloballyDragging: finishGloballyDragging,
    lastColumnRight: lastColumnRight,
    isHorizontallyScrolling: isHorizontallyScrolling,
    headMessages: headMessages,
    style: tableStyle,
    hasRightEmptySpace: hasRightEmptySpace
  }), /*#__PURE__*/React__default.createElement(Body, {
    ref: bodyRefs,
    rows: bodyRows,
    selectedRows: selectedRows,
    highlightedRows: highlightedRows,
    unseenRows: unseenRows,
    height: bodyHeight,
    globalOptions: options,
    infiniteScroll: handlers.infiniteScroll,
    isHorizontallyScrolling: isHorizontallyScrolling,
    style: tableStyle,
    hasRightEmptySpace: hasRightEmptySpace
  }));
});
Table.displayName = 'Table';
Table.propTypes = {
  className: PropTypes.string,
  rows: PropTypes.arrayOf(PropTypes.shape({
    data: PropTypes.object.isRequired,
    options: globalOptionsPropTypes
  })).isRequired,
  columns: PropTypes.object.isRequired,
  options: globalOptionsPropTypes,
  state: PropTypes.shape({
    selectedRows: PropTypes.arrayOf(PropTypes.number),
    highlightedRows: PropTypes.arrayOf(PropTypes.number),
    unseenRows: PropTypes.arrayOf(PropTypes.number),
    columnSorting: PropTypes.objectOf(columnSortingItemPropTypes),
    headMessages: headMessagesPropTypes
  })
};

var wrapChildTextNodes = function wrapChildTextNodes(children) {
  return React__default.Children.map(children, function (child) {
    if (child) {
      if (child.type) {
        return child;
      }

      return /*#__PURE__*/React__default.createElement("span", null, child);
    }
  });
};

var Tab = /*#__PURE__*/function (_Component) {
  _inherits(Tab, _Component);

  var _super = _createSuper(Tab);

  function Tab() {
    _classCallCheck(this, Tab);

    return _super.apply(this, arguments);
  }

  _createClass(Tab, [{
    key: "render",
    value: function render() {
      var _cx;

      var _this$props = this.props,
          active = _this$props.active,
          disabled = _this$props.disabled,
          givenClassName = _this$props.className,
          children = _this$props.children,
          forwardRef = _this$props.forwardRef,
          href = _this$props.href;
      var className = classnames(cuiClassName('tabs__tab'), givenClassName, (_cx = {}, _defineProperty(_cx, cuiClassName('tabs__tab--active'), active), _defineProperty(_cx, cuiClassName('tabs__tab--disabled'), disabled), _cx));

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough()); // Check if child is textNode and wrap it with span


      var content = wrapChildTextNodes(children);

      if (href && !disabled) {
        return /*#__PURE__*/React__default.createElement("a", _extends({
          href: href
        }, props), content);
      }

      return /*#__PURE__*/React__default.createElement("div", props, content);
    }
  }]);

  return Tab;
}(Component);
Tab.propTypes = {
  children: PropTypes.node,
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  renderAsOption: PropTypes.func,
  href: PropTypes.string
};

var tabsWithMenuOption = function tabsWithMenuOption(node) {
  var content = wrapChildTextNodes(node.props.children);

  if (node.props.href && !node.props.disabled) {
    var nodeProps = _objectSpread2({}, node.props);

    delete nodeProps.renderAsOption;
    return /*#__PURE__*/React__default.createElement("a", nodeProps, content);
  }

  return /*#__PURE__*/React__default.createElement("span", null, content);
};

Tab.defaultProps = {
  renderAsOption: function renderAsOption(node) {
    return tabsWithMenuOption(node);
  }
};
passthrough()(Tab);

var getTabsArray = function getTabsArray(props) {
  // Check if Tab was passed without container
  return props.children.type === Tab ? [props.children] : props.children.props.children;
};

var initialState$1 = function initialState(props) {
  return {
    tabsToRender: getTabsArray(props),
    tabsInDropmenu: [],
    tabsFitWithoutMenu: false
  };
};

var checkIfTabsFit = function checkIfTabsFit(tabsWidth, parentWidth) {
  return parentWidth >= tabsWidth;
};

var TabsWithMenu = /*#__PURE__*/function (_Component) {
  _inherits(TabsWithMenu, _Component);

  var _super = _createSuper(TabsWithMenu);

  function TabsWithMenu(props) {
    var _this;

    _classCallCheck(this, TabsWithMenu);

    _this = _super.call(this, props);
    _this.state = initialState$1(_this.props);
    _this.dropmenuTab = /*#__PURE__*/React__default.createRef();
    _this.renderedTabsRefs = [];
    _this.priorityList = [];
    _this.allReceivedTabs = [];
    _this.reArrangeTabs = _this.reArrangeTabs.bind(_assertThisInitialized(_this));
    _this.comparePriority = _this.comparePriority.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(TabsWithMenu, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this2 = this;

      if (getTabsArray(prevProps) !== getTabsArray(this.props)) {
        this.setState(initialState$1(this.props), function () {
          if (_this2.state.tabsToRender) {
            _this2.initializeComponent();
          }
        });
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.state.tabsToRender) {
        this.initializeComponent();
        window.addEventListener('resize', this.reArrangeTabs);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.reArrangeTabs);
    }
  }, {
    key: "initializeComponent",
    value: function initializeComponent() {
      this.allReceivedTabs = getTabsArray(this.props);
      this.priorityList = this.state.tabsToRender.slice();
      this.reArrangeTabs();
    }
  }, {
    key: "reArrangeTabs",
    value: function reArrangeTabs() {
      var _this3 = this;

      // Move the active tab to first place so that it's width would be considered during calculations about which tabs fit.
      var tabs = this.moveActiveTabFirst(); // Render all the tabs in new order first to see how many tabs fit.

      this.setState({
        tabsToRender: tabs
      }, function () {
        var numberOfTabsOutsideOfMenu = _this3.getNumberOfTabsOutsideMenu();

        if (numberOfTabsOutsideOfMenu === -1) {
          // All of the tabs fit without showing dropmenu. Reorder based on priority.
          return _this3.setState({
            tabsToRender: tabs.sort(_this3.comparePriority),
            tabsFitWithoutMenu: true
          });
        } else {
          // Tabs didn't fit rerender with dropmenu
          var tabsToRender = tabs.slice(0, numberOfTabsOutsideOfMenu);
          tabsToRender.sort(_this3.comparePriority);
          return _this3.setState({
            tabsToRender: tabsToRender,
            tabsFitWithoutMenu: false,
            tabsInDropmenu: tabs.slice(numberOfTabsOutsideOfMenu)
          });
        }
      });
    }
  }, {
    key: "moveActiveTabFirst",
    value: function moveActiveTabFirst() {
      var receivedTabs = this.allReceivedTabs.slice();
      var activeTabIndex = receivedTabs.findIndex(function (tab) {
        return tab.props.active;
      });
      var activeTab = receivedTabs.splice(activeTabIndex, 1)[0];
      receivedTabs.unshift(activeTab);
      return receivedTabs;
    } // Detect if dropmenu is needed and return the number of tabs that fit outside the menu.

  }, {
    key: "getNumberOfTabsOutsideMenu",
    value: function getNumberOfTabsOutsideMenu() {
      var numberOfTabsOutsideOfMenu;

      if (this.renderedTabsRefs.length) {
        var parentWidth = this.renderedTabsRefs[0].current.parentNode.clientWidth;
        var menuTabWidth = this.dropmenuTab.current.clientWidth;
        var tabsWidth = 0;

        var _iterator = _createForOfIteratorHelper(this.renderedTabsRefs),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var tab = _step.value;
            tabsWidth += tab.current.clientWidth;

            if (!numberOfTabsOutsideOfMenu && parentWidth <= tabsWidth + menuTabWidth) {
              // The number of elements that fit in parent together with menu tab.
              numberOfTabsOutsideOfMenu = this.renderedTabsRefs.indexOf(tab);
            }

            var tabsFit = checkIfTabsFit(tabsWidth, parentWidth);

            if (!tabsFit) {
              return numberOfTabsOutsideOfMenu;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } // All the tabs fit it the parent container


      return -1;
    }
  }, {
    key: "comparePriority",
    value: function comparePriority(a, b) {
      return this.priorityList.indexOf(a) - this.priorityList.indexOf(b);
    }
  }, {
    key: "getDropmenuContent",
    value: function getDropmenuContent() {
      return this.state.tabsInDropmenu.map(function (tab, index) {
        return /*#__PURE__*/React__default.createElement(Option, {
          key: index,
          onClick: tab.props.onClick,
          disabled: tab.props.disabled
        }, tab.props.renderAsOption(tab));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      this.renderedTabsRefs = [];
      var dropmenuTriggerText = this.props.dropmenuTriggerText;
      var tabsToRender = this.state.tabsToRender;

      if (tabsToRender) {
        // Add reference to each of the passed tabs and store them in renderedTabsRefs
        var renderTabs = tabsToRender.map(function (tab, index) {
          var tabRef = /*#__PURE__*/React__default.createRef();
          var cloneTab = /*#__PURE__*/React__default.cloneElement(tab, {
            key: tab.key || index,
            forwardRef: function forwardRef(node) {
              return triggerReferences(node, tab.props.forwardRef, tabRef);
            }
          });

          _this4.renderedTabsRefs.push(tabRef);

          return cloneTab;
        });
        var dropmenuTab = /*#__PURE__*/React__default.createElement(Dropmenu, {
          closeOnClick: true,
          key: "dropmenuTab",
          content: this.getDropmenuContent(),
          popoverProps: {
            placement: 'bottom-end'
          }
        }, /*#__PURE__*/React__default.createElement(Tab, {
          forwardRef: this.dropmenuTab,
          className: classnames(cuiClassName('tabs__menu-tab'), _defineProperty({}, cuiClassName('tabs__tab--hidden'), this.state.tabsFitWithoutMenu))
        }, dropmenuTriggerText ? /*#__PURE__*/React__default.createElement("span", null, dropmenuTriggerText) : /*#__PURE__*/React__default.createElement(Icon, {
          icon: "ellipsis"
        }), /*#__PURE__*/React__default.createElement(Icon, {
          icon: "triangle-down"
        })));
        renderTabs.push(dropmenuTab);
        return renderTabs;
      }

      return null;
    }
  }]);

  return TabsWithMenu;
}(Component);
TabsWithMenu.propTypes = {
  children: PropTypes.node,
  dropmenuTriggerText: PropTypes.string
};

var Tabs = /*#__PURE__*/function (_Component) {
  _inherits(Tabs, _Component);

  var _super = _createSuper(Tabs);

  function Tabs() {
    _classCallCheck(this, Tabs);

    return _super.apply(this, arguments);
  }

  _createClass(Tabs, [{
    key: "render",
    value: function render() {
      var _cx;

      var _this$props = this.props,
          dropmenuTriggerText = _this$props.dropmenuTriggerText,
          placement = _this$props.placement,
          fill = _this$props.fill,
          border = _this$props.border,
          children = _this$props.children,
          tabs = _this$props.tabs,
          givenClassName = _this$props.className,
          overflowDropmenu = _this$props.overflowDropmenu,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('tabs'), givenClassName, (_cx = {}, _defineProperty(_cx, cuiClassName("tabs--placement-".concat(placement)), placement), _defineProperty(_cx, cuiClassName('tabs--fill'), fill), _defineProperty(_cx, cuiClassName('tabs--border'), border), _cx));

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var tabsContent = overflowDropmenu ? /*#__PURE__*/React__default.createElement(TabsWithMenu, {
        dropmenuTriggerText: dropmenuTriggerText
      }, tabs) : tabs;
      return /*#__PURE__*/React__default.createElement("div", props, /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('tabs__tabs')
      }, tabsContent), /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('tabs__content')
      }, children));
    }
  }]);

  return Tabs;
}(Component);
Tabs.propTypes = {
  tabs: PropTypes.node.isRequired,
  children: PropTypes.node,
  placement: PropTypes.oneOf(['top', 'bottom', 'left', 'right']),
  fill: PropTypes.bool,
  border: PropTypes.bool,
  className: PropTypes.string,
  overflowDropmenu: PropTypes.bool,
  dropmenuTriggerText: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
Tabs.defaultProps = {
  placement: 'top'
};
passthrough()(Tabs);
Tabs.Tab = Tab;

var Toggle = /*#__PURE__*/function (_Component) {
  _inherits(Toggle, _Component);

  var _super = _createSuper(Toggle);

  function Toggle() {
    _classCallCheck(this, Toggle);

    return _super.apply(this, arguments);
  }

  _createClass(Toggle, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          size = _this$props.size,
          children = _this$props.children,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef,
          inputRef = _this$props.inputRef;
      var className = classnames(cuiClassName('toggle'), _defineProperty({}, cuiClassName("toggle--".concat(size)), size), givenClassName);
      var checkboxProps = getCheckboxProps(this.passthrough());

      var props = _objectSpread2(_objectSpread2(_objectSpread2({}, forwardRef && {
        ref: forwardRef
      }), checkboxProps.rest), {}, {
        className: className
      });

      var inputProps = _objectSpread2(_objectSpread2({}, inputRef && {
        ref: inputRef
      }), checkboxProps.checkbox);

      return /*#__PURE__*/React__default.createElement("label", props, /*#__PURE__*/React__default.createElement("input", _extends({
        type: "checkbox",
        role: "switch"
      }, inputProps)), /*#__PURE__*/React__default.createElement("div", {
        className: cuiClassName('toggle__switch')
      }), children && /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('toggle__label')
      }, children));
    }
  }]);

  return Toggle;
}(Component);
Toggle.propTypes = {
  size: PropTypes.oneOf(['l']),
  children: PropTypes.node,
  onChange: PropTypes.func,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  inputRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
Toggle.defaultProps = {
  onChange: function onChange() {}
};
passthrough({
  force: ['onChange'],
  omitKnownPropTypes: true
})(Toggle);

var Trend = /*#__PURE__*/function (_Component) {
  _inherits(Trend, _Component);

  var _super = _createSuper(Trend);

  function Trend() {
    _classCallCheck(this, Trend);

    return _super.apply(this, arguments);
  }

  _createClass(Trend, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          type = _this$props.type,
          direction = _this$props.direction,
          children = _this$props.children,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('trend'), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var iconProps = {
        size: 's',
        className: cuiClassName('trend__icon')
      };

      if (type) {
        iconProps.icon = direction === 'down' ? 'triangle-down' : 'triangle-up';
        iconProps.color = type === 'negative' ? 'red' : 'green';
      } else {
        iconProps.icon = 'triangle-left';
        iconProps.color = 'black-32';
      }

      return /*#__PURE__*/React__default.createElement("div", props, children && /*#__PURE__*/React__default.createElement("span", {
        className: cuiClassName('trend__text')
      }, children), /*#__PURE__*/React__default.createElement(Icon, iconProps));
    }
  }]);

  return Trend;
}(Component);
Trend.propTypes = {
  direction: PropTypes.oneOf(['up', 'down']),
  type: PropTypes.oneOf(['positive', 'negative']),
  children: PropTypes.node,
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(Trend);

var UserChip = /*#__PURE__*/function (_Component) {
  _inherits(UserChip, _Component);

  var _super = _createSuper(UserChip);

  function UserChip() {
    _classCallCheck(this, UserChip);

    return _super.apply(this, arguments);
  }

  _createClass(UserChip, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          type = _this$props.type,
          children = _this$props.children,
          href = _this$props.href,
          additionalText = _this$props.additionalText,
          icon = _this$props.icon,
          tooltipText = _this$props.tooltipText,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef;
      var className = classnames(cuiClassName('user-chip'), _defineProperty({}, cuiClassName("user-chip--".concat(type)), type), givenClassName);

      var props = _objectSpread2(_objectSpread2({
        className: className
      }, forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var linkAllowed = !['deactivated', 'hidden'].includes(type) && href ? true : false;
      return /*#__PURE__*/React__default.createElement(linkAllowed ? 'a' : 'span', _objectSpread2({
        href: href
      }, props), /*#__PURE__*/React__default.createElement(React__default.Fragment, null, children, additionalText && /*#__PURE__*/React__default.createElement("span", null, "(", additionalText, ")"), icon && tooltipText && /*#__PURE__*/React__default.createElement(Tooltip, {
        content: tooltipText,
        placement: "top"
      }, /*#__PURE__*/React__default.createElement(Icon, {
        size: "s",
        icon: icon,
        color: linkAllowed ? 'blue' : 'black-64'
      }))));
    }
  }]);

  return UserChip;
}(Component);
UserChip.propTypes = {
  type: PropTypes.oneOf(['you', 'other', 'deactivated', 'no-permission', 'hidden']),
  children: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  href: PropTypes.string,
  className: PropTypes.string,
  additionalText: PropTypes.string,
  icon: PropTypes.string,
  tooltipText: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func])
};
passthrough()(UserChip);

var wrapperType = 'p';
var baseClassName$5 = cuiClassName('video-overlay');
var videoClassName = "".concat(baseClassName$5, "-video");
var wistiaPlayerContainerClassName = 'wistia-player-container';
var descriptionClassName = "".concat(baseClassName$5, "-info__description");
var textClassName = "".concat(descriptionClassName, "-text");
var linkClassName = "".concat(descriptionClassName, "-link");
var defaultWistiaOptions = {
  embedType: 'async',
  videoFoam: true,
  videoQuality: 'hd-only',
  autoPlay: true
};
var wistiaScriptSrc = 'https://fast.wistia.com/assets/external/E-v1.js';
var wistiaIdentifier = 'wistia';
var vidyardIdentifier = 'vidyard';

function WistiaTemplate(_ref) {
  var id = _ref.id,
      options = _ref.options;

  var allOptions = _objectSpread2(_objectSpread2({}, defaultWistiaOptions), options);

  var optionsString = Object.keys(allOptions).map(function (key) {
    return "".concat(key, "=").concat(allOptions[key]);
  }).join(' ');
  return /*#__PURE__*/React__default.createElement("div", {
    className: "".concat(wistiaPlayerContainerClassName, " wistia_embed wistia_async_").concat(id, " ").concat(optionsString)
  }, /*#__PURE__*/React__default.createElement("div", {
    className: "wistia_swatch"
  }, /*#__PURE__*/React__default.createElement("img", {
    className: "wistia_swatch_img",
    src: "https://fast.wistia.com/embed/medias/".concat(id, "/swatch"),
    alt: "Video placeholder",
    "aria-hidden": "true"
  })));
}
WistiaTemplate.propTypes = {
  id: PropTypes.string.isRequired,
  options: PropTypes.object
};

// The wrapper is needed to test the recursion
var wrapper = {
  /**
   * @summary Recursively gets an entry point
   * for further description constructing.
   * @param {object} element - Initial raw description material to process.
   * @returns {object} - Entry point for further node constructing.
   */
  getEntryPoint: function getEntryPoint(element) {
    var children = element.props.children;

    if (!children) {
      throw new Error("Provided element doesn't have children.");
    }

    if (typeof children === 'string') {
      return element;
    }

    if (children.length) {
      if (typeof children[0] === 'string') {
        return element;
      }

      return children;
    }

    return wrapper.getEntryPoint(children);
  }
};

/**
 * @summary Calls pause method on Wistia video.
 */

function onLinkClick() {
  if (window.wistiaEmbeds.length) {
    window.wistiaEmbeds[0].pause();
  }
}
/**
 * @summary Process the given element and gets
 * specific description node depending on the element type.
 * @param {object} element - Description node to process.
 * @param {number|null} index=null - Iteration index for React key.
 * @returns {object} - Description's child node.
 */

function getChild(element) {
  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (element.type === 'span') {
    return /*#__PURE__*/cloneElement(element, {
      className: textClassName,
      key: index
    });
  }

  if (element.type === 'a') {
    return /*#__PURE__*/cloneElement(element, {
      className: linkClassName,
      children: /*#__PURE__*/React__default.createElement(Fragment, null, /*#__PURE__*/React__default.createElement("span", null, element.props.children), /*#__PURE__*/React__default.createElement(Icon, {
        icon: "redirect",
        size: "s",
        color: "blue"
      })),
      target: '_blank',
      rel: 'noopener noreferrer',
      key: index,
      onClick: onLinkClick
    });
  }

  return null;
}

var getEntryPoint = wrapper.getEntryPoint;
/**
 * @summary Gets description content to render.
 * @param {string|object} description - A string or a node to process.
 * @returns {object} - Ready to render description content.
 */

function getChildren(description) {
  if (typeof description === 'string') {
    return /*#__PURE__*/React__default.createElement("span", {
      className: textClassName
    }, description);
  }

  var entryPoint = getEntryPoint(description);

  if (entryPoint.length) {
    return entryPoint.map(function (child, index) {
      return getChild(child, index);
    });
  }

  return getChild(entryPoint);
}

/**
 * @summary Gets class name for the wrapper.
 * @param {string} className - Initial wrapper's class name.
 * @returns {string} - Processed wrapper's class name.
 */

function getClassName(className) {
  if (!className) {
    return descriptionClassName;
  }

  return "".concat(descriptionClassName, " ").concat(className);
}
/**
 * @summary Gets the final description.
 * @param {string} description - Initial provided description node.
 * @returns {string} - Processed description node.
 */

function getDescription(description) {
  var _description$props;

  var children = getChildren(description);
  var className = getClassName(description === null || description === void 0 ? void 0 : (_description$props = description.props) === null || _description$props === void 0 ? void 0 : _description$props.className);
  return /*#__PURE__*/cloneElement(_objectSpread2(_objectSpread2({}, description), {}, {
    type: wrapperType
  }), {
    className: className,
    children: children
  });
}

/**
 * @summary Gets video id from video url.
 * @param {string} url - Full video url.
 * @returns {string} - Extracted video id.
 */
function getVideoId(url) {
  var lastSlashIndex = url.lastIndexOf('/');

  if (lastSlashIndex === -1) {
    throw new Error('Provided string is not a url.');
  }

  var firstIndex = lastSlashIndex + 1;
  var chunk = url.slice(firstIndex);

  if (chunk.includes('?')) {
    var lastIndex = chunk.indexOf('?');
    return chunk.slice(0, lastIndex);
  }

  return chunk;
}

var v4_umd = createCommonjsModule(function (module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {
 // requires CustomEvent polyfill for IE
// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var CustomEvent = __webpack_require__(14);

var util = __webpack_require__(13); // the main landmark


var mainEl; // the element that will be trapped

var trappedEl; // collection of elements that get 'dirtied' with aria-hidden attr or hidden prop

var dirtyObjects; // filter function for svg elements

var filterSvg = function filterSvg(item) {
  return item.tagName.toLowerCase() !== 'svg';
};

function showElementPrep(el, useHiddenProperty) {
  var preparedElement;

  if (useHiddenProperty === false) {
    preparedElement = prepareElement(el, 'aria-hidden', 'false');
  } else {
    preparedElement = prepareElement(el, 'hidden', false);
  }

  return preparedElement;
}

function hideElementPrep(el, useHiddenProperty) {
  var preparedElement;

  if (useHiddenProperty === false) {
    preparedElement = prepareElement(el, 'aria-hidden', 'true');
  } else {
    preparedElement = prepareElement(el, 'hidden', true);
  }

  return preparedElement;
}

function prepareElement(el, attributeName, dirtyValue) {
  var isProperty = typeof dirtyValue === 'boolean';
  return {
    el: el,
    attributeName: attributeName,
    cleanValue: isProperty ? el[attributeName] : el.getAttribute(attributeName),
    dirtyValue: dirtyValue,
    isProperty: isProperty
  };
}

function dirtyElement(preparedObj) {
  if (preparedObj.isProperty === true) {
    preparedObj.el[preparedObj.attributeName] = preparedObj.dirtyValue;
  } else {
    preparedObj.el.setAttribute(preparedObj.attributeName, preparedObj.dirtyValue);
  }
}

function cleanElement(preparedObj) {
  if (preparedObj.cleanValue) {
    if (preparedObj.isProperty === true) {
      preparedObj.el[preparedObj.attributeName] = preparedObj.cleanValue;
    } else {
      preparedObj.el.setAttribute(preparedObj.attributeName, preparedObj.cleanValue);
    }
  } else {
    preparedObj.el.removeAttribute(preparedObj.attributeName);
  }
}

function untrap() {
  if (trappedEl) {
    // restore 'dirtied' elements to their original state
    dirtyObjects.forEach(function (item) {
      return cleanElement(item);
    });
    dirtyObjects = []; // 're-enable' the main landmark

    if (mainEl) {
      mainEl.setAttribute('role', 'main');
    } // let observers know the screenreader is now untrapped


    trappedEl.dispatchEvent(new CustomEvent('screenreaderUntrap', {
      bubbles: true
    }));
    trappedEl = null;
  }
}

var defaultOptions = {
  useHiddenProperty: false
};

function trap(el, selectedOptions) {
  // ensure current trap is deactivated
  untrap();

  var options = _extends({}, defaultOptions, selectedOptions); // update the trapped el reference


  trappedEl = el; // update the main landmark reference

  mainEl = document.querySelector('main, [role="main"]'); // we must remove the main landmark to avoid issues on voiceover iOS

  if (mainEl) {
    mainEl.setAttribute('role', 'presentation');
  } // cache all ancestors, siblings & siblings of ancestors for trappedEl


  var ancestors = util.getAncestors(trappedEl);
  var siblings = util.getSiblings(trappedEl);
  var siblingsOfAncestors = util.getSiblingsOfAncestors(trappedEl); // if using hidden property, filter out SVG elements as they do not support this property

  if (options.useHiddenProperty === true) {
    siblings = siblings.filter(filterSvg);
    siblingsOfAncestors = siblingsOfAncestors.filter(filterSvg);
  } // prepare elements


  dirtyObjects = [showElementPrep(trappedEl, options.useHiddenProperty)].concat(ancestors.map(function (item) {
    return showElementPrep(item, options.useHiddenProperty);
  })).concat(siblings.map(function (item) {
    return hideElementPrep(item, options.useHiddenProperty);
  })).concat(siblingsOfAncestors.map(function (item) {
    return hideElementPrep(item, options.useHiddenProperty);
  })); // update DOM

  dirtyObjects.forEach(function (item) {
    return dirtyElement(item);
  }); // let observers know the screenreader is now trapped

  trappedEl.dispatchEvent(new CustomEvent('screenreaderTrap', {
    bubbles: true
  }));
}

module.exports = {
  trap: trap,
  untrap: untrap
};


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
}(this, function ErrorStackParser(StackFrame) {

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var Shylog = (function () {
    function Shylog(_a) {
        var _b = _a === void 0 ? { emit: false, logger: console.log } : _a, emit = _b.emit, logger = _b.logger;
        this.emit = emit;
        this.externalLogger = logger;
        this.buffer = [];
        this.customLevel = {};
        this.error = this.setLevel(1);
        this.warn = this.setLevel(2);
        this.info = this.setLevel(3);
        this.log = this.setLevel(4);
    }
    Shylog.prototype.getLogs = function (level) {
        if (typeof level === 'function') {
            return this.buffer.filter(function (log) { return log.level === level.level; });
        }
        else {
            return level ? this.buffer.filter(function (log) { return log.level === level; }) : this.buffer;
        }
    };
    Shylog.prototype.setLevel = function (level) {
        var _this = this;
        var logFn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var message = { level: level, time: Date.now(), msg: args.join(' ') };
            _this.buffer.push(message);
            _this.emit && _this.externalLogger(message);
        };
        logFn.level = level;
        this.customLevel[level] = logFn;
        return logFn;
    };
    return Shylog;
}());
exports.default = Shylog;


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {
/* harmony default export */ __webpack_exports__["a"] = (function(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
});


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {
/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);


// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  this._state = 0;
  this._handled = false;
  this._value = undefined;
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"];

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!arr || typeof arr.length === 'undefined')
      throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(values) {
  return new Promise(function(resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  (typeof setImmediate === 'function' &&
    function(fn) {
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/* harmony default export */ __webpack_exports__["a"] = (Promise);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18).setImmediate));

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/promise-polyfill/src/index.js
var src = __webpack_require__(5);

// CONCATENATED MODULE: ./src/utils/promise.ts

var isFn = function (fn) { return typeof fn === 'function'; };
var checkNativePromise = function (_a) {
    var Promise = (_a === void 0 ? window : _a).Promise;
    return Promise &&
        Promise.all &&
        Promise.race &&
        Promise.resolve &&
        Promise.reject &&
        isFn(Promise) &&
        isFn(Promise.all) &&
        isFn(Promise.race) &&
        isFn(Promise.resolve) &&
        isFn(Promise.reject);
};
var promiseFn = checkNativePromise() ? window.Promise : src["a" /* default */];
/* harmony default export */ var promise = (promiseFn);

// CONCATENATED MODULE: ./src/utils/embed-helpers.ts
/*
* File contains the minimum amount of helper functions to allow embed to work in IE9+
* Has no access to jQuery / Underscore etc
*/

var addListener = function (eventName, oldIeEventName, handler, element) {
    if (element === void 0) { element = window; }
    if (window.addEventListener) {
        element.addEventListener(eventName, handler, false);
    }
    else if (window.attachEvent) {
        element.attachEvent(oldIeEventName, handler);
    }
    return { eventName: eventName, handler: handler, element: element };
};
var removeListener = function (eventName, handler, element) {
    if (element === void 0) { element = window; }
    if (element.removeEventListener) {
        element.removeEventListener(eventName, handler, false);
    }
    else if (element.detachEvent) {
        element.detachEvent('on' + eventName, handler);
    }
    else {
        element['on' + eventName] = null;
    }
};
var createEvent = function (eventName, payload) {
    if (typeof window.CustomEvent === 'function') {
        return new window.CustomEvent(eventName, { detail: payload });
    }
    else if (typeof document.createEvent === 'function') {
        var legacyCustomEvent = document.createEvent('CustomEvent');
        legacyCustomEvent.initCustomEvent(eventName, false, false, payload);
        return legacyCustomEvent;
    }
};
var isObjectEmpty = function (obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            return false;
        }
    }
    return JSON.stringify(obj) === JSON.stringify({});
};
var indexOfArray = function (item, arr) {
    if (arr.indexOf) {
        return arr.indexOf(item);
    }
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === item) {
            return i;
        }
    }
    return -1;
};
var shallowMerge = function (a, b) {
    for (var key in b) {
        if (b.hasOwnProperty(key)) {
            a[key] = b[key];
        }
    }
    return a;
};
// TODO: change to getElementsByClass
var getElementByClass = function (className, tagName, topLevelNode) {
    if (tagName === void 0) { tagName = '*'; }
    if (topLevelNode === void 0) { topLevelNode = document; }
    if (typeof document.getElementsByClassName === 'function') {
        return topLevelNode.getElementsByClassName(className);
    }
    var results = [];
    var re = new RegExp('(^| )' + className + '( |$)');
    var nodes = toArray(topLevelNode.getElementsByTagName(tagName));
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        if (re.test(node.className)) {
            results.push(node);
        }
    }
    return results;
};
var calcAspectRatio = function (imageEl, additionalWidth) {
    if (additionalWidth === void 0) { additionalWidth = 0; }
    var size = getNaturalDimensions(imageEl);
    // fallback to landscape aspect ratio if the image does not have proper size
    return size.height !== 0 || size.width !== 0
        ? ((size.height / (size.width + additionalWidth)) * 100).toFixed(2)
        : ((9 / 16) * 100).toFixed(2); // landscape 16:9 aspect ratio, equals to 56.25%
};
var embed_helpers_log = function (message, logType) {
    if (logType === void 0) { logType = 'log'; }
    if (window.console && typeof window.console[logType] === 'function') {
        console[logType](message);
    }
};
var find = function (array, test) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var item = array_1[_i];
        var res = test(item);
        if (res === true) {
            return item;
        }
    }
};
var includes = function (array, itemToCheck) { return find(array, function (item) { return item === itemToCheck; }); };
var once = function (callback) {
    var expired = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (expired) {
            return;
        }
        if (callback) {
            callback.apply(void 0, args);
        }
        expired = true;
    };
};
var spaceOrEnterKeyPressEvent = function (callback) { return function (e) {
    // spacebar or enter
    if (e.keyCode === 32 || e.keyCode === 13) {
        callback(e);
    }
}; };
var escKeyPressEvent = function (callback) { return function (e) {
    // esc
    if (e.keyCode === 27) {
        callback(e);
    }
}; };
var getCurrentScript = function () {
    // need to check for currentScript because it does not exist in IE
    return document.currentScript
        ? document.currentScript
        : find(toArray(document.getElementsByTagName('script')), function (script) {
            return script.src &&
                (script.src.match('vidyard-embed-code.js') !== null ||
                    script.src.match(/v4(\.umd)?\.js/) !== null);
        });
};
var getNaturalDimensions = function (ele) {
    if (ele.naturalWidth) {
        return { width: ele.naturalWidth, height: ele.naturalHeight };
    }
    var img = new Image();
    img.src = ele.src;
    return { width: img.width, height: img.height };
};
var toArray = function (htmlCollection) { return Array.prototype.slice.call(htmlCollection); };
var checkJSONParse = function (jsonString) {
    return new promise(function (res, rej) {
        try {
            res(JSON.parse(jsonString));
        }
        catch (err) {
            rej(err);
        }
    });
};
var xhrRequest = function (_a) {
    var endpoint = _a.endpoint, _b = _a.payload, payload = _b === void 0 ? {} : _b, _c = _a.method, method = _c === void 0 ? 'GET' : _c;
    return new promise(function (res, rej) {
        // IE 8/9 needs to send CORS requests over XDomainRequest
        var isXDomain = new XMLHttpRequest().withCredentials === undefined && XDomainRequest;
        var xhr = isXDomain ? new XDomainRequest() : new XMLHttpRequest();
        xhr.open(method, endpoint);
        if (xhr instanceof XMLHttpRequest) {
            xhr.setRequestHeader('Content-Type', 'text/plain');
        }
        xhr.onerror = function (e) { return rej(e); };
        xhr.onload = function () {
            if (xhr instanceof XMLHttpRequest) {
                if (Math.floor(xhr.status / 100) === 2) {
                    // 200 range
                    res(xhr.responseText);
                }
                else {
                    rej();
                }
            }
            else {
                // XDomainRequest does not have status
                res(xhr.responseText);
            }
        };
        xhr.send(JSON.stringify(payload));
    });
};
var getFullscreenAPI = function () {
    var apiMap = [
        // Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
        ['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenchange'],
        // WebKit
        [
            'webkitRequestFullscreen',
            'webkitExitFullscreen',
            'webkitFullscreenElement',
            'webkitfullscreenchange',
        ],
        // Mozilla
        ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozfullscreenchange'],
        // Microsoft
        ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'MSFullscreenChange'],
    ];
    var browserAPI = [];
    var fullscreenAPI = {};
    for (var _i = 0, apiMap_1 = apiMap; _i < apiMap_1.length; _i++) {
        var browserMethods = apiMap_1[_i];
        // check for exitFullscreen function
        if (browserMethods[1] in document) {
            browserAPI = browserMethods;
            break;
        }
    }
    // map the browser API names to the spec API names
    if (browserAPI && browserAPI.length) {
        for (var i = 0; i < browserAPI.length; i++) {
            fullscreenAPI[apiMap[0][i]] = browserAPI[i];
        }
        return fullscreenAPI;
    }
    else {
        return null;
    }
};
var dataSet = function (el) {
    var collection = {};
    var parseAttributeName = function (attr) { return attr.name.replace('data-', ''); };
    // can't do for-of here as el.attributes is not an array
    // tslint:disable-next-line
    for (var i = 0; i < el.attributes.length; i += 1) {
        var attr = el.attributes[i];
        if (attr.name.indexOf('data-') < 0) {
            continue;
        }
        collection[parseAttributeName(attr)] = attr.value;
    }
    return collection;
};
var getQueryParam = function (name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    var regexString = '[\\?&]' + name + '=([^&#]*)';
    var regex = new RegExp(regexString);
    var results = regex.exec(window.location.search);
    if (results !== null) {
        return results[1];
    }
};
var parseNestedData = function (encodedData, type) {
    try {
        var nestedData_1 = JSON.parse(decodeURIComponent(encodedData));
        return Object.keys(nestedData_1).reduce(function (acc, key) {
            acc[type + "[" + key + "]"] = nestedData_1[key];
            return acc;
        }, {});
    }
    catch (e) {
        embed_helpers_log("Invalid " + type + " payload", 'warn');
        return {};
    }
};
var parseVyData = function (data) {
    return Object.keys(data).reduce(function (acc, key) {
        if (key === 'vydata') {
            var parsedData_1 = parseNestedData(data[key], 'vydata');
            Object.keys(parsedData_1).forEach(function (parsedKey) {
                acc[parsedKey] = parsedData_1[parsedKey];
            });
        }
        else {
            acc[key] = data[key];
        }
        return acc;
    }, {});
};
// https://stackoverflow.com/questions/6787383/how-to-add-remove-a-class-in-javascript
var toggleClass = function (element, classToToggle, forceBoolean) {
    var hasClass = function (ele, targetClass) {
        return ele.className.indexOf(targetClass) !== -1;
    };
    var addClass = function (ele, targetClass) {
        if (!hasClass(ele, targetClass)) {
            ele.className = ele.className.trim() + " " + targetClass;
        }
    };
    var removeClass = function (ele, targetClass) {
        if (hasClass(ele, targetClass)) {
            ele.className = ele.className.replace(targetClass, ' ').trim();
        }
    };
    if (forceBoolean === true) {
        addClass(element, classToToggle);
    }
    else if (forceBoolean === false) {
        removeClass(element, classToToggle);
    }
    else if (hasClass(element, classToToggle)) {
        removeClass(element, classToToggle);
    }
    else {
        addClass(element, classToToggle);
    }
};

// CONCATENATED MODULE: ./src/utils/constants.ts
var VERSION = "4.2.31";
var ERROR_ORIGIN_RE = /vidyard\.com\/embed\/v4/;
var INTEGRATIONS_URL = '/integrations.js';
var OVERLAY_FADE_TIME = 0.5;
var PLAYLIST_WIDTH = 319;
var SEO_DETAILS_URL = '/details.js';
var STYLE_PATH = '/style.js';

// CONCATENATED MODULE: ./src/utils/config.ts

var dynamicPlaybackURL = (function playbackURL() {
    var playbackURLOverride;
    return {
        setPlaybackURL: function (url) {
            playbackURLOverride = url;
            return playbackURLOverride;
        },
        getPlaybackURL: function () {
            // override the `PLAYBACK_URL` if data-playbackurl exists on the script tag
            var currentScript = getCurrentScript();
            var stagingPlaybackUrl = currentScript
                ? currentScript.getAttribute('data-playbackurl')
                : null;
            return (playbackURLOverride ||
                window.VIDYARD_PLAYBACK_URL ||
                stagingPlaybackUrl ||
                'play.vidyard.com');
        },
    };
})();

var setPlaybackURL = dynamicPlaybackURL.setPlaybackURL;
var getPlaybackURL = dynamicPlaybackURL.getPlaybackURL;
var getBaseURL = function () { return "https://" + getPlaybackURL() + "/v4/"; };
var getErrorURL = function () { return "https://" + getPlaybackURL() + "/v4/error"; };

// CONCATENATED MODULE: ./src/utils/frame-messenger.ts
/*
* Provides an ie7 compatable way of sending messages to iframes
* If in a modern browser, will just use postmessage
*/

// --- Public Functions ---
var send = function (message, targetOrigin, target) {
    if (!targetOrigin || !target) {
        return;
    }
    if (window.postMessage && target.contentWindow) {
        // The browser supports window.postMessage, so call it with a targetOrigin
        // set appropriately, based on the target_url parameter.
        target.contentWindow.postMessage(JSON.stringify(message), targetOrigin);
    }
    else {
        // If the window does not support postmessaging, only 'associateVisitor' events are supported
        // Internally the player will have specific handling for these cases
        if (message.event !== 'associateVisitor') {
            return;
        }
        var stringMessage = message.event + "," + message.data.type + "," + message.data.value + "|";
        var targetSrc = target.src;
        if (targetSrc.indexOf('#') === -1) {
            targetSrc += '#';
        }
        // The browser does not support window.postMessage, so set the location
        // of the target to target_url#message. A bit ugly, but it works!
        targetSrc += stringMessage;
        target.src = targetSrc;
    }
};
var receive = function (callback) { return function (postMessage) {
    var data = parse(postMessage);
    if (!data) {
        return;
    }
    callback(data);
}; };
// --- Private Functions ---
function parse(event) {
    if (typeof event.data !== 'string' || event.data === '') {
        return;
    }
    try {
        var data = JSON.parse(event.data);
        var iframe = getElementByClass('vidyard-iframe-' + data.uuid, 'iframe')[0];
        // event validation
        var contentWindow = iframe ? iframe.contentWindow : null;
        var sameSource = contentWindow === event.source;
        var validEvent = typeof data.event === 'string';
        if (!sameSource || !validEvent) {
            return;
        }
        return data;
    }
    catch (e) {
        embed_helpers_log('Invalid postMessage received', 'warn');
        return;
    }
}

// CONCATENATED MODULE: ./src/models/integrations-watcher.ts



// All possible cookie names we would look for, the message names are different from the cookie keys
var cookieNames = [
    'pardot',
    'hubspotutk',
    '_mkto_trk',
    'vy_dreamforce',
    'eloqua',
];
var messageNames = [
    'pardot',
    'hubspot',
    'marketo',
    'dreamforce',
    'eloqua',
];
function IntegrationsWatcher() {
    var _this = this;
    var cookieCheckInterval = null;
    var loadedEloquaScript = false;
    var organizations = {};
    // --- Public Functions ---
    this.updatePlayer = function (player) {
        // Don't continue if we don't have an iframe and integration information
        if (!player._tmpOrg || !player.iframe) {
            return;
        }
        var orgId = player._tmpOrg.orgId;
        if (!organizations[orgId]) {
            organizations[orgId] = {
                foundIntegrations: {},
                id: orgId,
                // All integrations supported by this organization
                integrations: player._tmpOrg,
                // Store of cookie data found keyed by integration name
                // Each integration has an externalIdentifier set with the tracking cookie/uuid if found
                // as well as an object with which players have been sent the associateVisitor event
                // e.g. {integration: {externalIdentifier: 'cookie_value', sentPlayers: ['player1.uuid']}}
                // In DOM players associated with this organization
                players: [],
            };
        }
        player.org = organizations[orgId];
        // Check if this player has already been added to the organizations list
        // if so, do nothing
        for (var _i = 0, _a = organizations[orgId].players; _i < _a.length; _i++) {
            var currentPlayer = _a[_i];
            if (currentPlayer.iframe === player.iframe) {
                return;
            }
        }
        organizations[orgId].players.push(player);
        var _b = player.org.integrations, eloqua = _b.eloqua, eloquaFirstPartyDomain = _b.eloquaFirstPartyDomain;
        if (eloqua) { // Only load the eloqua script if the player needs it
            // Only load the tracking script if the user has given GDPR consent
            if (player.status !== null && player.status.consent) {
                // Note: This function only does something the first time it is called
                loadEloquaTrackingScript(eloqua, eloquaFirstPartyDomain);
            }
            else {
                player.on('status', function handleStatus() {
                    if (player.status.consent) {
                        loadEloquaTrackingScript(eloqua, eloquaFirstPartyDomain);
                        player.off('status', handleStatus);
                    }
                });
            }
        }
        // Loop over all integrations setup with this org & communicate them to the player
        // making sure to only send the event once per player & integration
        checkForIntegrations();
    };
    // Use function chaining to ensure a Player is only messaged about an integration once
    // It is expected that `updatePlayer` is called on a player before this
    this.safelyCommunicateIntegration = function (player, integration, externalIdentifier) {
        if (player.org !== undefined &&
            externalIdentifier !== undefined &&
            externalIdentifier !== null &&
            !haveSentIntegrationToPlayer(player, integration) &&
            communicateIntegration(player, integration, externalIdentifier)) {
            player.org = setIntegrationSent(player.org, integration, player.uuid);
        }
    };
    this.addKnownVisitor = function (integrationName, visitorData, org) {
        if (!org) {
            return;
        }
        // Go through and message all active players
        for (var _i = 0, _a = org.players; _i < _a.length; _i++) {
            var player = _a[_i];
            communicateKnownVisitor(player, integrationName, visitorData);
        }
    };
    // @TODO: switch the return type form any to unknown once we upgrade TS
    // Loop through all available cookies and return the value for cookieName if found
    this.getCookie = function (integration, organization) {
        var cookies = document.cookie.split(';');
        if (integration === 'eloqua' && typeof window.GetElqCustomerGUID === 'function') {
            // GetElqCustomerGUID is put on the DOM by Eloqua tracking scripts
            return window.GetElqCustomerGUID();
        }
        var cookieName = alterDynamicCookieName(cookieNames[messageNames.indexOf(integration)], organization);
        // Loop through all cookies looking for supplied cookie name
        for (var _i = 0, cookies_1 = cookies; _i < cookies_1.length; _i++) {
            var currentCookie = cookies_1[_i];
            var equalIndex = currentCookie.indexOf('=');
            var foundName = currentCookie.substr(0, equalIndex).replace(/^\s+|\s+$/g, '');
            var foundId = currentCookie.substr(equalIndex + 1);
            if (foundName === cookieName) {
                return decodeURIComponent(foundId);
            }
        }
    };
    // --- Private Functions ---
    // Return true if the integration cookie event has already been sent to this Player
    var haveSentIntegrationToPlayer = function (player, integration) {
        return (player.org &&
            player.org.foundIntegrations &&
            player.org.foundIntegrations[integration] &&
            player.org.foundIntegrations[integration].sentPlayers &&
            indexOfArray(player.uuid, player.org.foundIntegrations[integration].sentPlayers) !== -1);
    };
    // Initialize object to track integration cookies and
    // players which have been sent the cookie already
    var setupFoundIntegration = function (org, integration) {
        if (!org.foundIntegrations[integration]) {
            org.foundIntegrations[integration] = {
                externalIdentifier: null,
                sentPlayers: [],
            };
        }
        return org;
    };
    var setIntegrationSent = function (org, integration, playerUuid) {
        org = setupFoundIntegration(org, integration);
        org.foundIntegrations[integration].sentPlayers.push(playerUuid);
        return org;
    };
    var setIntegrationIdentifier = function (org, integration, externalIdentifier) {
        org = setupFoundIntegration(org, integration);
        org.foundIntegrations[integration].externalIdentifier = externalIdentifier;
        return org;
    };
    // Send event to Player with integration external identifier
    var communicateIntegration = function (player, integration, externalIdentifier) {
        if (!player.ready()) {
            return false;
        }
        // Player iframe already exists, message it about the integration
        var message = {
            data: { type: integration, value: externalIdentifier },
            event: 'associateVisitor',
            uuid: player.uuid,
        };
        embed_helpers_log('IntegrationsWatcher.communicateIntegration ' + message, 'debug');
        send(message, "https://" + getPlaybackURL(), player.iframe);
        return true;
    };
    // Go through and message all active players on DOM which haven't already been sent
    var messagePlayersFoundIntegration = function (players, integration, externalIdentifier) {
        if (players === undefined || externalIdentifier === undefined || externalIdentifier === null) {
            return;
        }
        for (var _i = 0, players_1 = players; _i < players_1.length; _i++) {
            var player = players_1[_i];
            _this.safelyCommunicateIntegration(player, integration, externalIdentifier);
        }
    };
    var sendKnownVisitor = function (player, leadType, leadData) {
        var message = {
            data: { type: leadType, value: leadData },
            event: 'identifyVisitor',
            uuid: player.uuid,
        };
        send(message, "https://" + getPlaybackURL(), player.iframe);
    };
    var communicateKnownVisitor = function (player, leadType, leadData) {
        if (!player.ready()) {
            // Setup callback if Player not ready yet
            player.on('ready', function () {
                sendKnownVisitor(player, leadType, leadData);
            });
        }
        else {
            // Player iframe already exists, message it about the lead
            sendKnownVisitor(player, leadType, leadData);
        }
    };
    // Find any integration trackers on the page and send to each player that hasn't received yet
    var checkForIntegrations = function () {
        // Go through all possible integration
        for (var _i = 0, messageNames_1 = messageNames; _i < messageNames_1.length; _i++) {
            var integration = messageNames_1[_i];
            // Loop through all orgs and see if they care about this integration
            for (var orgKey in organizations) {
                if (organizations.hasOwnProperty(orgKey)) {
                    var currentOrganization = organizations[orgKey];
                    // Do nothing if the org doesn't have this integration
                    if (!currentOrganization.integrations[integration]) {
                        continue;
                    }
                    // Check if integration tracker is present on the page
                    var cookieValue = _this.getCookie(integration, currentOrganization);
                    if (!cookieValue) {
                        continue;
                    }
                    cookieValue = parseCookieValue(integration, cookieValue, currentOrganization);
                    // parseCookieValue can return null if Marketo cookie doesn't match Munchkin ID
                    if (!cookieValue) {
                        continue;
                    }
                    currentOrganization = setIntegrationIdentifier(currentOrganization, integration, cookieValue);
                    messagePlayersFoundIntegration(currentOrganization.players, integration, cookieValue);
                }
            }
        }
    };
    // Pardot uses a dynamic cookie name, set it up here
    var alterDynamicCookieName = function (cookieName, organization) {
        if (cookieName === 'pardot' && organization && organization.integrations.pardot) {
            return 'visitor_id' + organization.integrations.pardot;
        }
        return cookieName;
    };
    var parseCookieValue = function (msgName, cookieValue, org) {
        if (msgName === 'marketo') {
            // Make sure this cookie is actually for this players organization
            if (!org.integrations.marketo ||
                cookieValue.toLowerCase().indexOf(org.integrations.marketo.toLowerCase()) === -1) {
                return null;
            }
            cookieValue = encodeURIComponent(cookieValue);
        }
        return cookieValue;
    };
    var loadEloquaTrackingScript = function (siteId, firstPartyDomain) {
        if (loadedEloquaScript) {
            return;
        }
        loadedEloquaScript = true;
        var createEloquaScriptNode = function () {
            // Only set up Eloqua tracking script once (including v3 & hubs)
            if (document.getElementById('vidyard-eloqua-include')) {
                return;
            }
            window._elqQ = window._elqQ || [];
            window._elqQ.push(['elqSetSiteId', siteId]);
            if (firstPartyDomain) {
                window._elqQ.push(['elqUseFirstPartyCookie', firstPartyDomain]);
            }
            window._elqQ.push(['elqTrackPageView']);
            window._elqQ.push(['elqGetCustomerGUID']);
            var eloquaScript = document.createElement('script');
            eloquaScript.id = 'vidyard-eloqua-include';
            eloquaScript.type = 'text/javascript';
            eloquaScript.async = true;
            eloquaScript.src = 'https://img.en25.com/i/elqCfg.min.js';
            var firstScript = document.getElementsByTagName('script')[0];
            firstScript.parentNode.insertBefore(eloquaScript, firstScript);
        };
        if (document.readyState === 'complete') {
            createEloquaScriptNode();
        }
        else {
            addListener('DOMContentLoaded', 'onload', createEloquaScriptNode);
        }
    };
    cookieCheckInterval = setInterval(function () {
        // We check for new cookies every second in case the player is on a page with
        // tracking scripts that will be dynamically adding new cookies at some point
        checkForIntegrations();
    }, 1000);
}

// CONCATENATED MODULE: ./src/api/dispatch-ready.ts

// Allows the client to listen for the Vidyard API to become available
// Example:
// window.VidyardV4
//   ? initApp(window.VidyardV4)
//   : (window.onVidyardAPI = (vyApi) => initApp(vyApi));
//
// Or with promises:
// new Promise(res => window.VidyardV4
//   ? res(window.VidyardV4)
//   : (window['onVidyardAPI'] = (vyApi) => res(vyApi))
// ).then((vyApi) => {
//   console.log('api is ready ', vyApi);
// });
var readyCallback = function () {
    if (window.onVidyardAPI && typeof window.onVidyardAPI === 'function') {
        window.onVidyardAPI(window.VidyardV4);
    }
};
// We also dispatch a custom event on document indicating that the API is ready
// Example:
// window.VidyardV4
//   ? initApp(window.VidyardV4)
//   : document.addEventListener('onVidyardAPI', ({ detail: vyApi }) => initApp(vyApi));
var readyEvent = function () {
    document.dispatchEvent(createEvent('onVidyardAPI', window.VidyardV4));
};
var dispatchReady = once(function () {
    readyCallback();
    readyEvent();
});
/* harmony default export */ var dispatch_ready = (dispatchReady);

// EXTERNAL MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/shylog/build/index.js
var build = __webpack_require__(3);
var build_default = /*#__PURE__*/__webpack_require__.n(build);

// CONCATENATED MODULE: ./src/api/debug.ts



var logger = new build_default.a({
    emit: !!window.location.search.match('vydebug=1'),
    logger: function (message) { return embed_helpers_log(message, 'info'); },
});
var debug_currentScript = getCurrentScript();
if (debug_currentScript) {
    logger.info("vidyardEmbed V" + VERSION + " loaded from " + debug_currentScript.src);
    logger.info("data-playbackurl=" + debug_currentScript.getAttribute('data-playbackurl'));
}
logger.info("userAgent " + window.navigator.userAgent);
logger.info("cookies " + navigator.cookieEnabled);
if (window.performance && window.performance.timing && window.performance.timing.navigationStart) {
    logger.info("Script load time " + (Date.now() - window.performance.timing.navigationStart));
}
var debug = { logger: logger, getPlaybackURL: getPlaybackURL, setPlaybackURL: setPlaybackURL, version: VERSION };
/* harmony default export */ var api_debug = (debug);

// CONCATENATED MODULE: ./src/api/add-ready-listener.ts

// cb: callback when a player is ready, uuid: optional filter to only listen for individual player uuids
function addReadyListener(cb, uuid) {
    var playerReadyListeners = window.VidyardV4.playerReadyListeners;
    // Store all callbacks for any yet to be created players
    playerReadyListeners[uuid] = playerReadyListeners[uuid] || [];
    playerReadyListeners[uuid].push(cb);
    // Add ready listeners to all currently available players
    for (var _i = 0, _a = window.VidyardV4.players; _i < _a.length; _i++) {
        var currentPlayer = _a[_i];
        // Is this the correct player OR are they setting up listeners for every player
        if (uuid !== undefined && currentPlayer.uuid !== uuid) {
            continue;
        }
        currentPlayer.on('ready', cb);
    }
}
function processReadyListeners(player) {
    var playerReadyListeners = window.VidyardV4.playerReadyListeners;
    var uuid = player.uuid;
    var log = logger.setLevel(player.uuid);
    // Ensure the cb set for this uuid is defined
    playerReadyListeners[uuid] = playerReadyListeners[uuid] || [];
    // Get the total set of callbacks for this uuid && all uuids
    var callbacks = playerReadyListeners[uuid].concat(playerReadyListeners[undefined]);
    // Loop through all cbs and add them to the players listeners
    Object.keys(callbacks).forEach(function (k) {
        var callback = callbacks[k];
        player.on('ready', callback);
        log("attaching ready callbacks");
    });
}

// CONCATENATED MODULE: ./src/models/markup-injector.ts
/*
* Injection of the base html / CSS for the player iframe
* Does not handle showing/hiding lightboxes, see LightboxHelper for that madness
*/

var allowFeaturePolicy = function () {
    var features = [
        'autoplay',
        'fullscreen',
        'picture-in-picture',
        'camera',
        'microphone',
        'display-capture',
    ];
    return features.join('; ');
};
var createIframe = function (dataParams, sizing) {
    // We only want to limit the max-height and max-width for inline embeds
    // Can't apply this directly to the iframe element because it affects fullscreen in IE11
    var maxSizeDiv = function (children) { return (dataParams.type === 'inline' ? ('<div ' +
        'class="vidyard-inner-container-' + dataParams.uuid + '" ' +
        'style="' +
        'position: absolute;' +
        'height: 100%; ' +
        'width: 100%; ' +
        (sizing.maxWidth ? 'max-width: ' + sizing.maxWidth + 'px; ' : '') +
        (sizing.maxHeight ? 'max-height: ' + sizing.maxHeight + 'px; ' : '') +
        '"' +
        '> ' +
        children +
        '</div> ') : children); };
    return ('<div ' +
        'class="vidyard-div-' + dataParams.uuid + '" ' +
        'role="none" ' +
        'aria-label="Vidyard media player" ' +
        'style="' +
        // This would change to relative once the iframe is loaded
        'position: absolute; ' +
        'padding-bottom: ' + sizing.ratio + '%; ' +
        'height: 0; ' +
        'overflow: hidden; ' +
        'max-width: 100%; ' +
        '"' +
        '>' +
        maxSizeDiv('<iframe ' +
            'allow="' + allowFeaturePolicy() + '"' +
            'allowfullscreen ' +
            'allowtransparency="true" ' +
            'referrerpolicy="no-referrer-when-downgrade" ' +
            'aria-label="Vidyard video player" ' +
            'class="vidyard-iframe-' + dataParams.uuid + '" ' +
            'frameborder=0 ' +
            'height="100%" ' +
            'width="100%" ' +
            'scrolling=no ' +
            'src="https://' + getPlaybackURL() + '/' + dataParams.uuid + dataParams.toQueryString() + '" ' +
            'title="Vidyard video player" ' +
            'style="' +
            'opacity: 0; ' +
            'background-color: transparent; ' +
            'position: absolute; ' +
            'top: 0; ' +
            'left: 0;' +
            '"' +
            '>' +
            '</iframe>') +
        '</div>');
};
// @TODO: better data type
var createJsonLD = function (data) {
    var playerDetailsScriptTag = document.createElement('script');
    playerDetailsScriptTag.type = 'application/ld+json';
    playerDetailsScriptTag.text = JSON.stringify(data);
    return playerDetailsScriptTag;
};

// CONCATENATED MODULE: ./src/utils/jsonp.ts
/*
* Provides functions which perform JSONP requests to the server.
* All URLs etc are stored within this file.
*/



var getStyle = function (uuid) {
    return new promise(function (res, rej) {
        return request({
            error: rej,
            success: res,
            url: "" + getBaseURL() + uuid + STYLE_PATH,
            uuid: "style_" + uuid,
        });
    });
};
var getIntegrations = function (uuid) {
    return new promise(function (res, rej) {
        return request({
            error: rej,
            success: res,
            url: "" + getBaseURL() + uuid + INTEGRATIONS_URL,
            uuid: "integrations_" + uuid,
        });
    });
};
var getSEO = function (uuid) {
    return new promise(function (res, rej) {
        return request({
            error: rej,
            success: res,
            url: "" + getBaseURL() + uuid + SEO_DETAILS_URL,
            uuid: "details_" + uuid,
        });
    });
};
var getMarketoLead = function (uuid, marketoCookie) {
    return new promise(function (res, rej) {
        var cookie = encodeURIComponent(marketoCookie);
        var contactUrl = "" + getBaseURL() + uuid + "/contact/" + cookie + "/marketoContact.js";
        request({
            error: rej,
            success: res,
            url: contactUrl,
            uuid: "marketoContact_" + uuid,
        });
    });
};
var createJSONPTag = function (_a) {
    var error = _a.error, url = _a.url, requestUuid = _a.requestUuid;
    var script = document.createElement('script');
    script.type = 'application/javascript';
    script.onerror = error;
    script.src = url + "?callback=window.VidyardV4.jsonp." + requestUuid + ".done";
    // Anticipating a potential error when getPlaybackURL() is called when the JSONP script is current:
    // Setting data-playbackurl here makes it safe to use getPlaybackURL during all stages of load.
    script.setAttribute('data-playbackurl', getPlaybackURL());
    document.body.appendChild(script);
    return script;
};
// track all jsonp requests
var jsonpRequests = {};
var request = function (_a) {
    var url = _a.url, uuid = _a.uuid, success = _a.success, error = _a.error;
    // Function names can't include "-" because it's interpreted as a subtract operator
    // Strip them out here and in the player backend to prevent errors
    var requestUuid = uuid.replace(/-/g, '');
    var script = createJSONPTag({ error: error, url: url, requestUuid: requestUuid });
    // each response callback will only be called once
    var onRes = once(function (data) {
        success(data);
        script.parentNode.removeChild(script);
    });
    // store all jsonp requests in a closure
    jsonpRequests[requestUuid] = jsonpRequests[requestUuid] || [];
    jsonpRequests[requestUuid].push(onRes);
    window.VidyardV4.jsonp[requestUuid] = {
        done: function (data) {
            // call data on all response callbacks that share the same request_uuid
            jsonpRequests[requestUuid].forEach(function (cb) { return cb(data); });
        },
    };
};

// CONCATENATED MODULE: ./src/utils/messages.ts
/* harmony default export */ var messages = ({
    errors: {
        placeholder: 'Cannot render the player, check the placeholder Image',
    }
});

// CONCATENATED MODULE: ./src/models/placeholder.ts
var __rest =  function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};





var loadPlaceholder = function (img) {
    if (!img) {
        return promise.reject(new Error(messages.errors.placeholder));
    }
    var _a = getNaturalDimensions(img), width = _a.width, height = _a.height;
    var uuid = img.getAttribute('data-uuid');
    // reject images without source or uuid
    if (img.src === '' || !uuid) {
        return promise.reject(new Error(messages.errors.placeholder));
    }
    // reject images that are loaded and have no size
    if (img.complete && (width === 0 || height === 0)) {
        return promise.reject(new Error(messages.errors.placeholder));
    }
    if (img.complete) {
        // image is already loaded
        return promise.resolve(img);
    }
    else {
        // load the image
        return new promise(function (res, rej) {
            img.onload = function () { return res(img); };
            img.onerror = function () { return rej(img); };
        });
    }
};
var createPlaceholder = function (_a) {
    if (_a === void 0) { _a = {}; }
    var uuid = _a.uuid, container = _a.container, _b = _a.type, type = _b === void 0 ? 'inline' : _b, _c = _a.aspect, other = __rest(_a, ["uuid", "container", "type", "aspect"]);
    if (!uuid || !container) {
        return;
    }
    logger.setLevel('placeholder')('creating placeholder image');
    var image = document.createElement('img');
    var width = other.width ? other.width + "px" : '100%';
    var height = other.height ? other.height + "px" : '100%';
    var style = "\n    display: block;\n    margin: 0 auto;\n    max-height: " + height + ";\n    max-width: " + width + ";\n    opacity: 0;\n  ";
    image.src = "//" + getPlaybackURL() + "/" + uuid + ".jpg";
    image.className = 'vidyard-player-embed';
    image.setAttribute('style', style);
    image.setAttribute('data-uuid', uuid);
    image.setAttribute('data-type', type);
    // assign all of the other keys as data params on the image
    Object.keys(other).forEach(function (k) { return image.setAttribute("data-" + k, other[k]); });
    return container.appendChild(image);
};
var loadServerThumbnail = function (uuid) {
    var image = document.createElement('img');
    image.setAttribute('data-uuid', uuid);
    image.src = "//" + getPlaybackURL() + "/" + uuid + ".jpg";
    return loadPlaceholder(image);
};

// CONCATENATED MODULE: ./src/controllers/inline-player.ts







var injectInlineElements = function (_a) {
    var dataParams = _a.dataParams, player = _a.player;
    var log = logger.setLevel(dataParams.uuid);
    log("injecting inline embed");
    var updateAspectRatio = function () {
        // Get thumbnail from server and calculate aspect ratio if the placeholder is different (edge case)
        if (player.placeholder.src !== "//" + getPlaybackURL() + "/" + player.uuid + ".jpg") {
            return loadServerThumbnail(player.uuid)
                .then(calcAspectRatio)
                .catch(function () { return false; });
        }
        return promise.resolve(false);
    };
    var sizing = {
        maxHeight: dataParams.height ? parseInt(dataParams.height, 10).toString() : null,
        maxWidth: dataParams.width ? parseInt(dataParams.width, 10).toString() : null,
        ratio: calcAspectRatio(player.placeholder),
    };
    // Create and attach the players iframe & containing <div>
    player.container.innerHTML = createIframe(dataParams, sizing);
    var iframe = player.container.getElementsByTagName('iframe')[0];
    player.iframe = iframe;
    var iframeLoadedPromise = new promise(function (res) {
        addListener('load', 'onload', res, iframe);
    });
    var playerReadyPromise = new promise(function (res) {
        player.on('ready', res);
    });
    player.on('sidePlaylistOpen', function () {
        handleResize();
    });
    // The iframe will finish first, usually.
    promise.race([iframeLoadedPromise, playerReadyPromise]).then(function () {
        log("player or iFrame is ready");
        // If the placeholder image is different than the server thumbnail, update the aspect ratio
        // to be consistent with the server thumbnail (edge case)
        updateAspectRatio().then(function (newAspectRatio) {
            if (newAspectRatio) {
                iframe.parentElement.parentElement.style.paddingBottom = newAspectRatio + "%";
            }
        });
        var innerContainer = player.container.getElementsByClassName("vidyard-inner-container-" + player.uuid)[0];
        // Copy the place holder image to the iframe's parent element
        player.placeholder.parentElement.removeChild(player.placeholder);
        toggleClass(player.placeholder, 'inserted', true);
        innerContainer.appendChild(player.placeholder);
        // This inserts the iframe into the document flow
        iframe.parentElement.parentElement.style.position = 'relative';
        // Be sure that the iframe is fully visible
        iframe.style.opacity = '1';
    });
    iframeLoadedPromise.then(function () {
        // Hide the placeholder image only after the iframe has loaded
        player.placeholder.style.display = 'none';
        iframe.parentElement.parentElement.style.backgroundColor = 'transparent';
    });
    function handleResize() {
        // The breakpoint is the side playlist width, doubled. If the available space is less, we need to hide the side playlist.
        var aboveBreakpoint = player.container.clientWidth >= PLAYLIST_WIDTH * 2;
        toggleClass(player.container, 'playlist-open', aboveBreakpoint);
    }
    log("getStyle sent");
    getStyle(player.uuid).then(
    // pl is the "playlist always open" setting from the Dashboard.
    function (data) {
        log("getStyle received: " + JSON.stringify(data));
        var playlistAlwaysOpen = (data.pl === 1 && dataParams.playlist_always_open !== '0') ||
            dataParams.playlist_always_open === '1';
        if (playlistAlwaysOpen) {
            player.iframe.parentElement.setAttribute('data-pl', 'true');
            addListener('resize', 'onresize', handleResize);
            handleResize();
        }
        else {
            player.iframe.parentElement.setAttribute('data-pl', 'false');
        }
    }).catch(function (e) {
        log('getStyle failed, likely a network error');
    });
};
/* harmony default export */ var inline_player = (injectInlineElements);

// CONCATENATED MODULE: ./src/utils/accessibility-helpers.ts
/*
* The following helpers are needed for an iOS modal accessibility workaround
* https://www.tpgi.com/the-current-state-of-modal-dialog-accessibility/
*/
/*
* Apply aria-hidden="true" for all children of element, and if necessary
* storing the current aria-hidden value as data-vy-keep-hidden
*/
var ariaHideChildElements = function (element) {
    if (element === void 0) { element = document.body; }
    for (var _i = 0, _a = Array.from(element.children); _i < _a.length; _i++) {
        var el = _a[_i];
        if (el.hasAttribute('aria-hidden')) {
            el.setAttribute('data-vy-keep-hidden', el.getAttribute('aria-hidden'));
        }
        el.setAttribute('aria-hidden', 'true');
    }
};
/*
* Restore the previous aria-hidden value for all children of element
* data-vy-keep-hidden indicates the previous value was "true"
*/
var undoAriaHideChildElements = function (element) {
    if (element === void 0) { element = document.body; }
    for (var _i = 0, _a = Array.from(element.children); _i < _a.length; _i++) {
        var el = _a[_i];
        if (el.getAttribute('data-vy-keep-hidden')) {
            el.setAttribute('aria-hidden', el.getAttribute('data-vy-keep-hidden'));
        }
        else {
            el.removeAttribute('aria-hidden');
        }
        el.removeAttribute('data-vy-keep-hidden');
    }
};

// CONCATENATED MODULE: ./src/utils/user-agent-checker.ts
/* harmony default export */ var user_agent_checker = ({
    ios: function () {
        return /ipad|iphone|ipod/i.test(navigator.userAgent);
    },
});

// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/utils/array.js
var array_toArray = function toArray(a) {
  var ret = Array(a.length);
  for (var i = 0; i < a.length; ++i) {
    ret[i] = a[i];
  }
  return ret;
};

var arrayFind = function arrayFind(array, search) {
  return array.filter(function (a) {
    return a === search;
  })[0];
};

var asArray = function asArray(a) {
  return Array.isArray(a) ? a : [a];
};
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/constants.js
var FOCUS_GROUP = 'data-focus-lock';
var FOCUS_DISABLED = 'data-focus-lock-disabled';
var FOCUS_ALLOW = 'data-no-focus-lock';
var FOCUS_AUTO = 'data-autofocus-inside';
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/focusIsHidden.js



var focusIsHidden_focusIsHidden = function focusIsHidden() {
  return document && array_toArray(document.querySelectorAll('[' + FOCUS_ALLOW + ']')).some(function (node) {
    return node.contains(document.activeElement);
  });
};

/* harmony default export */ var es2015_focusIsHidden = (focusIsHidden_focusIsHidden);
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/utils/all-affected.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




var filterNested = function filterNested(nodes) {
  var l = nodes.length;
  for (var i = 0; i < l; i += 1) {
    var _loop = function _loop(j) {
      if (i !== j) {
        if (nodes[i].contains(nodes[j])) {
          return {
            v: filterNested(nodes.filter(function (x) {
              return x !== nodes[j];
            }))
          };
        }
      }
    };

    for (var j = 0; j < l; j += 1) {
      var _ret = _loop(j);

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
  }
  return nodes;
};

var getTopParent = function getTopParent(node) {
  return node.parentNode ? getTopParent(node.parentNode) : node;
};

var all_affected_getAllAffectedNodes = function getAllAffectedNodes(node) {
  var nodes = asArray(node);
  return nodes.filter(Boolean).reduce(function (acc, currentNode) {
    var group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested(array_toArray(getTopParent(currentNode).querySelectorAll('[' + FOCUS_GROUP + '="' + group + '"]:not([' + FOCUS_DISABLED + '="disabled"])'))) : [currentNode]);
    return acc;
  }, []);
};

/* harmony default export */ var all_affected = (all_affected_getAllAffectedNodes);
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/focusInside.js



var focusInFrame = function focusInFrame(frame) {
  return frame === document.activeElement;
};

var focusInside_focusInsideIframe = function focusInsideIframe(topNode) {
  return !!arrayFind(array_toArray(topNode.querySelectorAll('iframe')), focusInFrame);
};

var focusInside_focusInside = function focusInside(topNode) {
  var activeElement = document && document.activeElement;

  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return all_affected(topNode).reduce(function (result, node) {
    return result || node.contains(activeElement) || focusInside_focusInsideIframe(node);
  }, false);
};

/* harmony default export */ var es2015_focusInside = (focusInside_focusInside);
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/utils/tabOrder.js


var tabSort = function tabSort(a, b) {
  var tabDiff = a.tabIndex - b.tabIndex;
  var indexDiff = a.index - b.index;

  if (tabDiff) {
    if (!a.tabIndex) return 1;
    if (!b.tabIndex) return -1;
  }

  return tabDiff || indexDiff;
};

var tabOrder_orderByTabIndex = function orderByTabIndex(nodes, filterNegative, keepGuards) {
  return array_toArray(nodes).map(function (node, index) {
    return {
      node: node,
      index: index,
      tabIndex: keepGuards && node.tabIndex === -1 ? (node.dataset || {}).focusGuard ? 0 : -1 : node.tabIndex
    };
  }).filter(function (data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/utils/tabbables.js
/* harmony default export */ var tabbables = (['button:enabled:not([readonly])', 'select:enabled:not([readonly])', 'textarea:enabled:not([readonly])', 'input:enabled:not([readonly])', 'a[href]', 'area[href]', 'iframe', 'object', 'embed', '[tabindex]', '[contenteditable]', '[autofocus]']);
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/utils/tabUtils.js




var queryTabbables = tabbables.join(',');
var queryGuardTabbables = queryTabbables + ', [data-focus-guard]';

var tabUtils_getFocusables = function getFocusables(parents, withGuards) {
  return parents.reduce(function (acc, parent) {
    return acc.concat(
    // add all tabbables inside
    array_toArray(parent.querySelectorAll(withGuards ? queryGuardTabbables : queryTabbables)),
    // add if node is tabble itself
    parent.parentNode ? array_toArray(parent.parentNode.querySelectorAll(tabbables.join(','))).filter(function (node) {
      return node === parent;
    }) : []);
  }, []);
};

var tabUtils_getParentAutofocusables = function getParentAutofocusables(parent) {
  var parentFocus = parent.querySelectorAll('[' + FOCUS_AUTO + ']');
  return array_toArray(parentFocus).map(function (node) {
    return tabUtils_getFocusables([node]);
  }).reduce(function (acc, nodes) {
    return acc.concat(nodes);
  }, []);
};
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/utils/DOMutils.js




var isElementHidden = function isElementHidden(computedStyle) {
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden';
};

var isVisible = function isVisible(node) {
  return !node || node === document || node.nodeType === Node.DOCUMENT_NODE || !isElementHidden(window.getComputedStyle(node, null)) && isVisible(node.parentNode);
};

var notHiddenInput = function notHiddenInput(node) {
  return !((node.tagName === 'INPUT' || node.tagName === 'BUTTON') && (node.type === 'hidden' || node.disabled));
};

var getParents = function getParents(node) {
  var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  parents.push(node);
  if (node.parentNode) {
    getParents(node.parentNode, parents);
  }
  return parents;
};

var getCommonParent = function getCommonParent(nodea, nodeb) {
  var parentsA = getParents(nodea);
  var parentsB = getParents(nodeb);

  for (var i = 0; i < parentsA.length; i += 1) {
    var currentParent = parentsA[i];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};

var DOMutils_filterFocusable = function filterFocusable(nodes) {
  return array_toArray(nodes).filter(function (node) {
    return isVisible(node);
  }).filter(function (node) {
    return notHiddenInput(node);
  });
};

var DOMutils_getTabbableNodes = function getTabbableNodes(topNodes, withGuards) {
  return tabOrder_orderByTabIndex(DOMutils_filterFocusable(tabUtils_getFocusables(topNodes, withGuards)), true, withGuards);
};

var DOMutils_getAllTabbableNodes = function getAllTabbableNodes(topNodes) {
  return tabOrder_orderByTabIndex(DOMutils_filterFocusable(tabUtils_getFocusables(topNodes)), false);
};

var DOMutils_parentAutofocusables = function parentAutofocusables(topNode) {
  return DOMutils_filterFocusable(tabUtils_getParentAutofocusables(topNode));
};
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/utils/firstFocus.js
var isRadio = function isRadio(node) {
  return node.tagName === 'INPUT' && node.type === 'radio';
};

var findSelectedRadio = function findSelectedRadio(node, nodes) {
  return nodes.filter(isRadio).filter(function (el) {
    return el.name === node.name;
  }).filter(function (el) {
    return el.checked;
  })[0] || node;
};

var pickFirstFocus = function pickFirstFocus(nodes) {
  if (nodes[0] && nodes.length > 1) {
    if (isRadio(nodes[0]) && nodes[0].name) {
      return findSelectedRadio(nodes[0], nodes);
    }
  }
  return nodes[0];
};

var pickFocusable = function pickFocusable(nodes, index) {
  if (nodes.length > 1) {
    if (isRadio(nodes[index]) && nodes[index].name) {
      return nodes.indexOf(findSelectedRadio(nodes[index], nodes));
    }
  }
  return index;
};

/* harmony default export */ var utils_firstFocus = (pickFirstFocus);
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/focusMerge.js





var findAutoFocused = function findAutoFocused(autoFocusables) {
  return function (node) {
    return !!node.autofocus || node.dataset && !!node.dataset.autofocus || autoFocusables.indexOf(node) >= 0;
  };
};

var isGuard = function isGuard(node) {
  return node && node.dataset && node.dataset.focusGuard;
};
var notAGuard = function notAGuard(node) {
  return !isGuard(node);
};

var focusMerge_newFocus = function newFocus(innerNodes, outerNodes, activeElement, lastNode, autoFocused) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = isGuard(activeElement);

  // focus is inside
  if (innerNodes.indexOf(activeElement) >= 0) {
    return undefined;
  }

  var activeIndex = outerNodes.indexOf(activeElement);
  var lastIndex = outerNodes.indexOf(lastNode || activeIndex);
  var lastNodeInside = innerNodes.indexOf(lastNode);
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);

  var returnFirstNode = pickFocusable(innerNodes, 0);
  var returnLastNode = pickFocusable(innerNodes, cnt - 1);

  // new focus
  if (activeIndex === -1 || lastNodeInside === -1) {
    return innerNodes.indexOf(autoFocused && autoFocused.length ? utils_firstFocus(autoFocused) : utils_firstFocus(innerNodes));
  }
  // old focus
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  // first element
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  // last element
  if (activeIndex >= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  // jump out, but not on the guard
  if (indexDiff && Math.abs(indexDiff) > 1) {
    return lastNodeInside;
  }
  // focus above lock
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  // focus below lock
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  // index is inside tab order, but outside Lock
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  // do nothing
  return undefined;
};

var focusMerge_getTopCommonParent = function getTopCommonParent(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = asArray(baseActiveElement);
  var leftEntries = asArray(leftEntry);
  var activeElement = activeElements[0];
  var topCommon = null;
  leftEntries.filter(Boolean).forEach(function (entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function (subEntry) {
      var common = getCommonParent(activeElement, subEntry);
      if (common) {
        if (!topCommon || common.contains(topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  return topCommon;
};

var focusMerge_allParentAutofocusables = function allParentAutofocusables(entries) {
  return entries.reduce(function (acc, node) {
    return acc.concat(DOMutils_parentAutofocusables(node));
  }, []);
};

var reorderNodes = function reorderNodes(srcNodes, dstNodes) {
  var remap = new Map();
  // no Set(dstNodes) for IE11 :(
  dstNodes.forEach(function (entity) {
    return remap.set(entity.node, entity);
  });
  // remap to dstNodes
  return srcNodes.map(function (node) {
    return remap.get(node);
  }).filter(Boolean);
};

var focusMerge_getFocusMerge = function getFocusMerge(topNode, lastNode) {
  var activeElement = document && document.activeElement;
  var entries = all_affected(topNode).filter(notAGuard);

  var commonParent = focusMerge_getTopCommonParent(activeElement || topNode, topNode, entries);

  var innerElements = DOMutils_getTabbableNodes(entries).filter(function (_ref4) {
    var node = _ref4.node;
    return notAGuard(node);
  });

  if (!innerElements[0]) {
    innerElements = DOMutils_getAllTabbableNodes(entries).filter(function (_ref5) {
      var node = _ref5.node;
      return notAGuard(node);
    });
    if (!innerElements[0]) {
      return undefined;
    }
  }

  var outerNodes = DOMutils_getTabbableNodes([commonParent]).map(function (_ref6) {
    var node = _ref6.node;
    return node;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerNodes = orderedInnerElements.map(function (_ref7) {
    var node = _ref7.node;
    return node;
  });

  var newId = focusMerge_newFocus(innerNodes, outerNodes, activeElement, lastNode, innerNodes.filter(findAutoFocused(focusMerge_allParentAutofocusables(entries))));

  if (newId === undefined) {
    return newId;
  }
  return orderedInnerElements[newId];
};

/* harmony default export */ var focusMerge = (focusMerge_getFocusMerge);
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/setFocus.js


var focusOn = function focusOn(target) {
  target.focus();
  if (target.contentWindow) {
    target.contentWindow.focus();
  }
};

var guardCount = 0;
var lockDisabled = false;

/* harmony default export */ var setFocus = (function (topNode, lastNode) {
  var focusable = focusMerge(topNode, lastNode);

  if (lockDisabled) {
    return;
  }

  if (focusable) {
    if (guardCount > 2) {
      // eslint-disable-next-line no-console
      console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' + 'See https://github.com/theKashey/focus-lock/#focus-fighting');
      lockDisabled = true;
      setTimeout(function () {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node);
    guardCount--;
  }
});
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/focus-lock/dist/es2015/index.js










/* harmony default export */ var es2015 = (setFocus);
// CONCATENATED MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/dom-focus-lock/dist/index.esm.js


var lastActiveTrap = 0;
var lastActiveFocus = null;

var focusOnBody = function focusOnBody() {
  return document && document.activeElement === document.body;
};

var index_esm_isFreeFocus = function isFreeFocus() {
  return focusOnBody() || es2015_focusIsHidden();
};

var index_esm_activateTrap = function activateTrap() {
  var result = false;

  if (lastActiveTrap) {
    var observed = lastActiveTrap;

    if (!index_esm_isFreeFocus()) {
      if (observed && !es2015_focusInside(observed)) {
        result = es2015(observed, lastActiveFocus);
      }

      lastActiveFocus = document.activeElement;
    }
  }

  return result;
};

var reducePropsToState = function reducePropsToState(propsList) {
  return propsList.filter(function (node) {
    return node;
  }).slice(-1)[0];
};

var handleStateChangeOnClient = function handleStateChangeOnClient(trap) {
  lastActiveTrap = trap;

  if (trap) {
    index_esm_activateTrap();
  }
};

var instances = [];

var emitChange = function emitChange(event) {
  if (handleStateChangeOnClient(reducePropsToState(instances))) {
    event && event.preventDefault();
    return true;
  }

  return false;
};

var attachHandler = function attachHandler() {
  document.addEventListener('focusin', emitChange);
};

var detachHandler = function detachHandler() {
  document.removeEventListener('focusin', emitChange);
};

var focusLock = {
  on: function on(domNode) {
    if (instances.length === 0) {
      attachHandler();
    }

    if (instances.indexOf(domNode) < 0) {
      instances.push(domNode);
      emitChange();
    }
  },
  off: function off(domNode) {
    instances = instances.filter(function (node) {
      return node !== domNode;
    });
    emitChange();

    if (instances.length === 0) {
      detachHandler();
    }
  }
};

/* harmony default export */ var index_esm = (focusLock);

// EXTERNAL MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/makeup-screenreader-trap/index.js
var makeup_screenreader_trap = __webpack_require__(1);
var makeup_screenreader_trap_default = /*#__PURE__*/__webpack_require__.n(makeup_screenreader_trap);

// CONCATENATED MODULE: ./src/views/lightbox.ts
/*
* Applies and controls styles relating to centering the lightbox within the parent window
*/






// @TODO: need better return type here
function show(iframeString, thumbnailContainer, overlayZindex) {
    if (!iframeString || document.getElementById('vidyard-overlay')) {
        return;
    }
    var container = generateLightboxContainer(iframeString);
    var lightbox = generateLightboxHTML(overlayZindex);
    var lightboxConstraint = generateConstraintImage(thumbnailContainer);
    // Needed so that the lightbox isn't the last element in the <body> to
    // allow focusLock to listen for a focus event when focus leaves the
    // last element in the lightbox
    var focusableElement = document.createElement('div');
    focusableElement.id = 'vidyard-focusable-element';
    focusableElement.tabIndex = 0;
    lightbox.popbox.appendChild(container.backerElement);
    lightbox.popbox.appendChild(container.containingDiv);
    lightbox.popbox.appendChild(lightboxConstraint);
    if (user_agent_checker.ios()) {
        ariaHideChildElements();
    }
    // Add them to the DOM
    document.body.appendChild(lightbox.overlayWrapper);
    document.body.appendChild(focusableElement);
    lightbox.closeContainer.focus();
    index_esm.on(lightbox.overlayWrapper);
    makeup_screenreader_trap_default.a.trap(lightbox.overlayWrapper);
    // Have to use a timeout so css will actually transition the opacity
    setTimeout(function animateOpacity() {
        lightbox.overlayWrapper.style.opacity = '1';
        lightbox.overlayWrapper.style.filter = 'alpha(opacity=100)';
    }, 0);
    return {
        container: container,
        lightbox: lightbox,
    };
}
function remove(callbacks) {
    var fixedElement = document.getElementById('vidyard-content-fixed');
    var focusableElement = document.getElementById('vidyard-focusable-element');
    var overlay = document.getElementById('vidyard-overlay');
    var overlayWrapper = document.getElementById('vidyard-overlay-wrapper');
    var popbox = document.getElementById('vidyard-popbox');
    if (!fixedElement || !overlay || !overlayWrapper || !popbox) {
        return;
    }
    if (callbacks) {
        Object.keys(callbacks).forEach(function (k) {
            var cb = callbacks[k];
            cb();
        });
    }
    if (focusableElement) {
        focusableElement.parentNode.removeChild(focusableElement);
    }
    index_esm.off(overlayWrapper);
    makeup_screenreader_trap_default.a.untrap(overlayWrapper);
    overlayWrapper.style.opacity = '0';
    overlayWrapper.style.filter = 'alpha(opacity=0)';
    var cleanup = function () {
        overlayWrapper.parentNode.removeChild(overlayWrapper);
    };
    if (user_agent_checker.ios()) {
        undoAriaHideChildElements();
    }
    // Clean up the added DOM elements once fade out is complete
    setTimeout(cleanup, OVERLAY_FADE_TIME * 1000);
}
function makeIframeVisible(iframe) {
    iframe.style.opacity = '1';
}
// --- Private Functions ---
// @TODO: Better return type here
function generateLightboxHTML(overlayZindex) {
    // Create all the elements for the overlay
    var dom = {};
    dom.overlay = document.createElement('div');
    dom.contentFixed = document.createElement('div');
    dom.popbox = document.createElement('div');
    dom.overlayWrapper = document.createElement('div');
    dom.closeContainer = generateCloseButton().closeContainer;
    dom.overlay.id = 'vidyard-overlay';
    dom.overlay.setAttribute('aria-hidden', 'true');
    dom.overlay.style.display = 'block';
    dom.contentFixed.id = 'vidyard-content-fixed';
    dom.contentFixed.setAttribute('aria-label', 'media player lightbox');
    dom.contentFixed.setAttribute('role', 'dialog');
    dom.contentFixed.style.display = 'block';
    dom.popbox.id = 'vidyard-popbox';
    dom.overlayWrapper.id = 'vidyard-overlay-wrapper';
    dom.overlayWrapper.style.display = 'block';
    dom.contentFixed.appendChild(dom.popbox);
    dom.overlayWrapper.appendChild(dom.overlay);
    dom.overlayWrapper.appendChild(dom.closeContainer);
    dom.overlayWrapper.appendChild(dom.contentFixed);
    if (overlayZindex) {
        dom.overlay.style.zIndex = overlayZindex;
        dom.contentFixed.style.zIndex = overlayZindex + 2;
        dom.closeContainer.style.zIndex = overlayZindex + 1;
    }
    return dom;
}
// @TODO: Better return type here
function generateCloseButton() {
    var dom = {};
    dom.closeContainer = document.createElement('div');
    dom.closeButton = document.createElement('div');
    dom.closeContainer.className = 'vidyard-close-container';
    dom.closeContainer.setAttribute('aria-label', 'Close Player');
    dom.closeContainer.setAttribute('role', 'button');
    dom.closeContainer.setAttribute('tabindex', '0');
    dom.closeButton.className = 'vidyard-close-x';
    // Fix for ie7 not supporting :before pseudo elements
    // Fix for ie8 not supporting transform rotate
    if (document.documentMode < 9) {
        dom.closeButton.className += ' simple-close';
        dom.closeButton.innerHTML = '&times;';
    }
    dom.closeContainer.appendChild(dom.closeButton);
    return dom;
}
// @TODO: Better return type here
function generateLightboxContainer(playerIframeDOMString) {
    var dom = {};
    dom.backerElement = document.createElement('div');
    dom.backerElement.className = 'vidyard-lightbox-content-backer';
    dom.containerElement = document.createElement('div');
    // hydrate the markup string into actual DOM
    dom.containerElement.innerHTML = playerIframeDOMString;
    dom.containingDiv = dom.containerElement.getElementsByTagName('div')[0];
    dom.containingDiv.style.position = 'absolute';
    dom.containingDiv.style.height = '100%';
    dom.containingDiv.style.width = '100%';
    dom.containingDiv.style.zIndex = '2';
    dom.iframe = dom.containerElement.getElementsByTagName('iframe')[0];
    // Lightbox specific styling for the iframe
    dom.iframe.parentNode.style.position = 'static';
    // This overwrites the padding bottom set by createIframe
    dom.iframe.parentNode.style.paddingBottom = 0;
    dom.iframe.style.opacity = '1';
    // This is to ensure the background actually animates
    setTimeout(function () {
        dom.backerElement.style.opacity = '1';
        dom.backerElement.style.filter = 'alpha(opacity=100)';
    }, 0);
    return dom;
}
function generateConstraintImage(container) {
    var image = getElementByClass('vidyard-lightbox-image', 'img', container)[0].cloneNode();
    image.className = '';
    image.id = 'vidyard-popbox-constraint';
    image.alt = '';
    image.setAttribute('aria-hidden', 'true');
    return image;
}

// CONCATENATED MODULE: ./src/models/lightbox-animator.ts
/*
* Controls showing & hiding of the lightbox
*/





// --- Private Vars ---
var ACTIVE_ELEMENT;
// need to cleanup these after the lightbox is removed
var LIGHTBOX_EVENTS = {};
function setupAnimations(options) {
    var thumbnailContainer = getElementByClass('vidyard-lightbox-centering', 'div', options.container)[0];
    // expose the show and hide functions to the player API
    options.player.showLightbox = function showLightboxHandler() {
        logger.setLevel(options.player.uuid)('show lightbox');
        showLightbox({
            container: options.container,
            iframe: options.iframe,
            overlayZindex: options.overlayZindex,
            player: options.player,
        });
    };
    options.player.hideLightbox = removeLightbox;
    // event listeners on the thumbnail
    addListener('click', 'onclick', options.player.showLightbox, thumbnailContainer);
    addListener('keydown', 'onkeydown', spaceOrEnterKeyPressEvent(function (e) {
        e.preventDefault();
        options.player.showLightbox(e);
    }), thumbnailContainer);
}
// --- Private Functions ---
function showLightbox(options) {
    ACTIVE_ELEMENT = document.activeElement;
    var lightboxDOM = show(options.iframe, options.container, options.overlayZindex);
    // Set the vidyardPlayers iframe to the newly injected one
    options.player.iframe = lightboxDOM.container.iframe;
    // callback to run when the iframe has loaded, only once
    var uuid = options.player.uuid;
    var iframe = lightboxDOM.container.iframe;
    var iframeLoaded = onIframeLoad(iframe);
    var listenForKeyPress = iframeListenForKeyPress(iframe, uuid);
    // iframe load listener
    LIGHTBOX_EVENTS.iframeLoaded = addListener('load', 'onload', iframeLoaded, lightboxDOM.container.iframe);
    // postMessage receipt from the player listener
    LIGHTBOX_EVENTS.messageHandler = addListener('message', 'onmessage', 
    // @TODO add better types for data
    receive(function (data) {
        iframeLoaded();
        listenForKeyPress();
        onEscInIframe(data);
    }), window);
    // click on lightbox overlay listener
    LIGHTBOX_EVENTS.overlayClick = addListener('click', 'onclick', removeLightbox, lightboxDOM.lightbox.overlayWrapper);
    // click on lightbox fixed content wrapper listener
    LIGHTBOX_EVENTS.fixedClick = addListener('click', 'onclick', removeLightbox, lightboxDOM.lightbox.contentFixed);
    // space or enter on the X button listener
    LIGHTBOX_EVENTS.closeKeyPress = addListener('keydown', 'onkeydown', spaceOrEnterKeyPressEvent(removeLightbox), lightboxDOM.lightbox.closeContainer);
    LIGHTBOX_EVENTS.responsivePlayerSize = addListener('resize', 'onresize', lightbox_animator_handleResize, window);
}
function lightbox_animator_handleResize() {
    var constraintImage = document.getElementById('vidyard-popbox-constraint');
    var windowRatio = parseFloat(((window.innerHeight / window.innerWidth) * 100).toFixed(2));
    var imageRatio = parseFloat(calcAspectRatio(constraintImage));
    var orientation = windowRatio < imageRatio ? 'landscape' : 'portrait';
    if (constraintImage.className !== orientation) {
        constraintImage.className = orientation;
    }
}
function removeLightbox() {
    remove();
    if (ACTIVE_ELEMENT) {
        ACTIVE_ELEMENT.focus();
    }
    Object.keys(LIGHTBOX_EVENTS).forEach(function (key) {
        var _a = LIGHTBOX_EVENTS[key], eventName = _a.eventName, handler = _a.handler, element = _a.element;
        removeListener(eventName, handler, element);
    });
}
// @TODO: add better type for postMessageData
function onEscInIframe(postMessageData) {
    // if esc was pressed in the iframe
    if (postMessageData.event === 'keyPressed' && postMessageData.params === 27) {
        removeLightbox();
    }
}
function onIframeLoad(iframe, uuid) {
    return once(function () {
        makeIframeVisible(iframe);
        lightbox_animator_handleResize();
        // start listening for esc key presses in parent
        LIGHTBOX_EVENTS.parentEsc = addListener('keydown', 'onkeydown', escKeyPressEvent(removeLightbox), document);
    });
}
// Send message to start listening for esc key presses in iframe
function iframeListenForKeyPress(iframe, uuid) {
    return once(function () {
        var message = { uuid: uuid, event: 'listenForKeyPress', keyCode: '27' };
        send(message, "https://" + getPlaybackURL(), iframe);
    });
}

// CONCATENATED MODULE: ./src/api/get-player-metadata.ts
var __assign =  Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



function getPlayerMetadata(uuid) {
    if (!uuid || typeof uuid !== 'string' || uuid.length < 20) {
        throw new Error('Invalid UUID given');
    }
    var log = logger.setLevel(uuid);
    // @TODO: add proper API to fetch metadata as this endpoint is private and not stable
    var metadataEndpoint = "https://" + getPlaybackURL() + "/player/" + uuid + ".json?pomo=0";
    log('fetching metadata');
    return xhrRequest({ endpoint: metadataEndpoint })
        .then(JSON.parse)
        .then(function (data) {
        log('metadata successfully fetched');
        return __assign({ uuid: uuid }, data.payload.vyContext.metadata);
    })
        .catch(function (e) {
        log("failed to fetch metadata, " + e);
        throw new Error('Error parsing player metadata, make sure the UUID is correct');
    });
}

// CONCATENATED MODULE: ./src/models/lightbox-page-thumbnail.ts
/*
* Handles injecting html & css related specfically to lightbox embeds
*/



// This code sets up the css and listeners for the on page splash screen & play button
function init(embedScriptElement, queryParams, sizing) {
    var lightboxThumbnailUrl = "https://" + getPlaybackURL() + "/" + queryParams.uuid + ".jpg";
    var lightboxString = composeLightboxString(lightboxThumbnailUrl, queryParams, sizing);
    embedScriptElement.insertAdjacentHTML('afterbegin', lightboxString);
    getPlayerMetadata(queryParams.uuid)
        .then(function (metadata) {
        var playButton = getElementByClass('play-button', 'button', embedScriptElement);
        if (playButton.length !== 1) {
            return;
        }
        playButton[0].setAttribute('aria-label', 'Play video ' + metadata.name + '. Opens in a modal');
    }, function () {
        // Ignore errors fetching metadata
    });
}
function applyLightboxPlayButton(pbData, embedScriptElement) {
    if (pbData.pb !== 1) {
        return;
    }
    var playButton = getElementByClass('play-button', 'button', embedScriptElement);
    if (playButton.length !== 1) {
        return;
    }
    playButton[0].style.display = 'block';
    playButton[0].style.backgroundColor = '#' + pbData.pbc;
}
// --- Private Functions ---
function composeLightboxString(lightboxThumbnailUrl, queryParams, sizing) {
    return ('<div class="vidyard-lightbox-thumbnail vidyard-lightbox-' + queryParams.uuid + '"' +
        (sizing.maxWidth ? ' style="max-width: ' + sizing.maxWidth + 'px;"' : '') +
        '>' +
        '<div class="vidyard-lightbox-centering" ' +
        'style="padding-bottom: ' + sizing.ratio + '%;">' +
        '<img class="vidyard-lightbox-image" src="' + lightboxThumbnailUrl + '" alt="video thumbnail" />' +
        '<div type="button" role="button" class="play-button" title="Play video" data-version="1" tabindex="0">' +
        '<div class="play-button-size"></div>' +
        '<div class="arrow-size">' +
        '<div class="arrow-size-ratio"></div>' +
        '<div class="arrow"></div>' +
        '</div>' +
        '</div>' +
        '</div>' +
        '</div>');
}

// CONCATENATED MODULE: ./src/controllers/lightbox-player.ts






var injectLightboxElements = function (_a) {
    var dataParams = _a.dataParams, player = _a.player;
    var log = logger.setLevel(dataParams.uuid);
    log("injecting lighbox embed");
    // hide the placeholder image right away if lightbox
    player.placeholder.style.display = 'none';
    dataParams.autoplay = 1;
    var iframeSizing = { ratio: calcAspectRatio(player.placeholder) };
    var playerIframe = createIframe(dataParams, iframeSizing);
    var thumbnailSizing = {
        maxHeight: dataParams.height ? parseInt(dataParams.height, 10) : null,
        maxWidth: dataParams.width ? parseInt(dataParams.width, 10) : null,
        ratio: calcAspectRatio(player.placeholder),
    };
    // Inject lightbox thumbnail
    init(player.container, dataParams, thumbnailSizing);
    setupAnimations({
        container: player.container,
        iframe: playerIframe,
        overlayZindex: dataParams.overlayZindex,
        player: player,
    });
    log("getStyle sent");
    getStyle(player.uuid).then(function (data) {
        log("getStyle received: " + JSON.stringify(data));
        // Update the play button of the lightbox thumbnail to match the colours on the model
        applyLightboxPlayButton(data, player.container);
    }).catch(function (e) {
        log('getStyle failed, likely a network error');
    });
};
/* harmony default export */ var lightbox_player = (injectLightboxElements);

// CONCATENATED MODULE: ./src/controllers/integrations.ts



function integrationsControler(player) {
    var integrations = window.VidyardV4.integrations;
    var log = logger.setLevel(player.uuid);
    var marketoCookie = integrations.getCookie('marketo');
    if (marketoCookie) {
        log("getMarketoLead sent");
        getMarketoLead(player.uuid, marketoCookie)
            .then(checkJSONParse)
            // @TODO: add better types here
            .then(function (leadData) {
            log("getMarketoLead received: " + leadData);
            player.on('ready', function () {
                integrations.addKnownVisitor('marketo', leadData, player.org);
            });
        })
            .catch(function () {
            logger.warn('Invalid Marketo cookie');
        });
    }
    // Get info on what our integrations are by hitting /v4/:uuid/integrations.js
    log("getIntegrations");
    // @TODO: add better types here
    getIntegrations(player.uuid).then(function (data) {
        log("getIntegrations received: " + JSON.stringify(data));
        player.on('ready', function () {
            player._tmpOrg = data;
            integrations.updatePlayer(player);
        });
    }).catch(function (e) {
        log('getIntegrations failed, likely a network error');
    });
}

// CONCATENATED MODULE: ./src/controllers/seo.ts




function seoController(uuid) {
    var log = logger.setLevel(uuid);
    log("getSEO sent");
    // @TODO: add better type
    getSEO(uuid).then(function (data) {
        log("getSEO: " + JSON.stringify(data));
        if (!isObjectEmpty(data)) {
            var jsonLD = createJsonLD(data);
            document.getElementsByTagName('head')[0].appendChild(jsonLD);
        }
    }).catch(function (e) {
        log('getSEO failed, likely a network error');
    });
}

// CONCATENATED MODULE: ./src/views/container.ts
var createContainer = function (uuid, dataParams) {
    var container = document.createElement('div');
    container.className = 'vidyard-player-container';
    container.setAttribute('uuid', uuid);
    var styles = container.style;
    styles.margin = 'auto';
    styles.width = '100%';
    styles.height = 'auto';
    styles.overflow = 'hidden';
    styles.display = 'block';
    if (dataParams.type === 'inline') {
        styles.maxWidth = dataParams.width ? dataParams.width + 'px' : '';
        styles.maxHeight = dataParams.height ? dataParams.height + 'px' : '';
    }
    return container;
};
/* harmony default export */ var views_container = (createContainer);

// CONCATENATED MODULE: ./src/models/data-params.ts
/* tslint:disable variable-name */


var data_params_DataParams = /** @class */ (function () {
    function DataParams(placeHolderImage) {
        var _this = this;
        this.disable_popouts = 1;
        var data = parseVyData(dataSet(placeHolderImage));
        Object.keys(data).forEach(function (key) {
            _this[key] = data[key];
        });
        // Default to inline embed
        if (this.type !== 'inline' && this.type !== 'lightbox') {
            embed_helpers_log('Invalid Vidyard player embed type, defaulting to inline.', 'warn');
            this.type = 'inline';
        }
        // Report the embed script version
        this.v = VERSION;
        // This embed code no longer supports popout CTAs
        this.disable_popouts = 1;
        // Gets the vycustomid query string param, used to identify personalized videos
        this.custom_id = this.custom_id || getQueryParam('vycustom_id');
        // Gets the vyemail query string param, which connects views to an email entered
        this.vyemail = this.vyemail || getQueryParam('vyemail');
        // Sets a fixed Vidyard Salesforce ID for every view
        this.vysfid = this.vysfid || getQueryParam('vysfid');
        // Sets a fixed Vidyard Salesforce ID for every view
        this.vyetoken = this.vyetoken || getQueryParam('vyetoken');
        // Gets & sets the access code parameter which will bypass having the user enter it manually
        var vyac = getQueryParam('vyac');
        var vyplayer = getQueryParam('vyplayer');
        if (vyac && vyplayer && vyplayer === this.uuid) {
            this.access_code = vyac;
        }
        else if (vyac && vyplayer) {
            embed_helpers_log('Invalid Vidyard player access code.', 'warn');
        }
    }
    DataParams.prototype.toQueryString = function () {
        var queryParamsString = '?';
        var key;
        for (key in this) {
            if (!this.hasOwnProperty(key)) {
                continue;
            }
            // don't include these in the query string
            if (key === 'height' || key === 'uuid' || key === 'width') {
                continue;
            }
            // don't include undefined keys
            if (this[key] === undefined) {
                continue;
            }
            // Add '&' here so we don't end up with one trailing
            queryParamsString += queryParamsString !== '?' ? '&' : '';
            queryParamsString += encodeURIComponent(key) + '=' + encodeURIComponent(this[key]);
        }
        // Just return an empty string if no params were found
        return queryParamsString === '?' ? '' : queryParamsString;
    };
    return DataParams;
}());
/* harmony default export */ var data_params = (data_params_DataParams);

// CONCATENATED MODULE: ./src/models/preload-frames.ts
/*
* Adds link rel prefetch for the iframes
*/



function preloadFrames(embeds) {
    if (embeds === void 0) { embeds = getElementByClass('vidyard-player-embed', 'img'); }
    for (var _i = 0, embeds_1 = embeds; _i < embeds_1.length; _i++) {
        var ele = embeds_1[_i];
        var dataParams = new data_params(ele);
        var uuid = dataParams.uuid;
        var preloadHref = "https://" + getPlaybackURL() + "/" + uuid + dataParams.toQueryString();
        if (!uuid) {
            continue;
        }
        if (indexOfArray(preloadHref, window.VidyardV4.preloadLinks) === -1) {
            addPrefetchLink(uuid, preloadHref);
            window.VidyardV4.preloadLinks.push(preloadHref);
        }
    }
}
// --- Private Functions ---
function addPrefetchLink(uuid, href) {
    var preloadLink = document.createElement('link');
    preloadLink.rel = 'prefetch';
    preloadLink.crossOrigin = 'anonymous';
    preloadLink.href = href;
    document.body.appendChild(preloadLink);
    return href;
}

// CONCATENATED MODULE: ./src/models/vidyard-player.ts
var vidyard_player_assign =  Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};



var vidyard_player_Player = /** @class */ (function () {
    function Player(element, uuid, callbackStore) {
        var _this = this;
        this._ready = false;
        this._previousTime = null;
        this._onMessageEventHandler = function (event) {
            if (event.origin !== "https://" + getPlaybackURL()) {
                return;
            }
            var data;
            try {
                data = JSON.parse(event.data);
            }
            catch (e) {
                return;
            }
            // For a different player
            if (_this.uuid && data.uuid !== _this.uuid) {
                return;
            }
            // All vy events will have a string event name
            if (typeof data.event !== 'string') {
                return;
            }
            _this._updateStatus(data);
            if (data.event === 'ready') {
                _this._ready = true;
                window.VidyardV4.integrations.updatePlayer(_this);
            }
            var eventCallbacks = _this._callbackStore[data.event];
            if (eventCallbacks) {
                for (var _i = 0, eventCallbacks_1 = eventCallbacks; _i < eventCallbacks_1.length; _i++) {
                    var callback = eventCallbacks_1[_i];
                    callback.call(_this, data.params, _this);
                }
            }
        };
        this._callbackStore = callbackStore || {
            beforeSeek: [],
            chapterComplete: [],
            createCta: [],
            fullScreenChange: [],
            pause: [],
            play: [],
            playerComplete: [],
            ready: [],
            seek: [],
            sidePlaylistOpen: [],
            status: [],
            timeupdate: [],
            volumeChange: [],
        };
        this.element = element;
        this.uuid = uuid;
        this.status = null;
        this.metadata = null;
        this.progressEventsUnsubscribe = [];
        addListener('message', 'onmessage', this._onMessageEventHandler);
    }
    Player.prototype.on = function (eventName, callback) {
        var _this = this;
        if (eventName === 'ready' && this.ready()) {
            setTimeout(function () { return callback.call(_this, undefined, _this); }, 0);
            return;
        }
        if (this._callbackStore[eventName] === undefined) {
            this._callbackStore[eventName] = [callback];
            embed_helpers_log("The event name: " + eventName + " is not supported, your handler was setup regardless", 'warn');
            return;
        }
        this._callbackStore[eventName].push(callback);
    };
    Player.prototype.off = function (eventName, callback) {
        if (eventName === undefined) {
            // No event name given, clear out all event handlers
            for (var evt in this._callbackStore) {
                if (this._callbackStore.hasOwnProperty(evt)) {
                    this._callbackStore[evt] = [];
                }
            }
            return;
        }
        // If no handlers have been created with this eventName, do nothing
        if (!this._callbackStore[eventName]) {
            return;
        }
        if (callback) {
            // Only remove the callback associated with the correct function
            var index = indexOfArray(callback, this._callbackStore[eventName]);
            if (index > -1) {
                this._callbackStore[eventName].splice(index, 1);
            }
        }
        else {
            // Remove all callbacks associated with this eventName
            this._callbackStore[eventName] = [];
        }
    };
    Player.prototype.ready = function () {
        return this._ready;
    };
    // API METHODS
    Player.prototype.play = function () {
        this._message({ event: 'play' });
    };
    Player.prototype.pause = function () {
        this._message({ event: 'pause' });
    };
    Player.prototype.resume = function () {
        this._message({ event: 'resume' });
    };
    Player.prototype.seek = function (position) {
        this._message({ event: 'seek', position: position });
    };
    Player.prototype.setVolume = function (newVolume) {
        this._message({ event: 'setVolume', newVolume: newVolume });
    };
    Player.prototype.setPlaybackSpeed = function (speed) {
        this._message({ event: 'setPlaybackSpeed', speed: speed });
    };
    Player.prototype.playChapter = function (chapterIndex) {
        this._message({ chapter_index: chapterIndex, event: 'playChapter' });
    };
    Player.prototype.setAudioTrack = function (audioTrackId) {
        this._message({ audioTrackId: audioTrackId, event: 'setAudioTrack' });
    };
    Player.prototype.enableCaption = function (label, language) {
        this._message({ event: 'enableCaption', label: label, language: language });
    };
    Player.prototype.disableCaption = function (label, language) {
        this._message({ event: 'disableCaption', label: label, language: language });
    };
    Player.prototype.consentToGDPR = function (consent) {
        this._message({ consent: consent, event: 'consentToGDPR' });
    };
    Player.prototype.createCta = function (attributes) {
        this._message({
            attributes: shallowMerge({
                display_once: false,
                duration: 10,
                fullscreen: false,
                html: '',
                opacity: 1.0,
                start: 0,
                width: 300,
            }, attributes),
            event: 'createCta',
        });
    };
    Player.prototype.updateCta = function (ctaId, attributes) {
        this._message({
            attributes: attributes,
            event: 'updateCta',
            id: ctaId,
        });
    };
    Player.prototype.addEvent = function (_a) {
        var _b = _a.start, start = _b === void 0 ? 0 : _b, _c = _a.duration, duration = _c === void 0 ? 1 : _c, _d = _a.chapterIndex, chapterIndex = _d === void 0 ? 0 : _d, eventId = _a.eventId;
        if (!eventId) {
            embed_helpers_log('Missing arguments. Need eventId');
            return;
        }
        this._message({
            chapterIndex: chapterIndex,
            duration: duration,
            event: 'addEvent',
            id: eventId,
            start: start,
        });
    };
    Player.prototype.getCurrentChapter = function () {
        return this.status === null ? null : this.status.chapterIndex;
    };
    Player.prototype.currentTime = function () {
        return this.status === null ? null : this.status.currentTime;
    };
    Player.prototype.scrubbing = function () {
        return this.status === null ? null : this.status.scrubbing;
    };
    Player.prototype.toggleFullscreen = function () {
        var _this = this;
        // Request iframe to go fullscreen if possible, to get around user gesture requirements
        var fullscreenAPI = getFullscreenAPI();
        if (fullscreenAPI) {
            var fullscreenPromise = this.iframe[fullscreenAPI.requestFullscreen]();
            if (fullscreenPromise) {
                fullscreenPromise.then(function () {
                    _this._message({ event: 'toggleFullscreen' });
                });
            }
            else {
                this._message({ event: 'toggleFullscreen' });
            }
            // Listens to when the window exits fullscreen via the 'Esc' key
            addListener(fullscreenAPI.fullscreenchange, 'MSFullscreenChange', function () {
                if (!document[fullscreenAPI.fullscreenElement]) {
                    _this._message({ event: 'exitFullscreen' });
                }
            });
            addListener('message', 'onmessage', receive(function (data) {
                if (data.event === 'fullScreenChange' && data.params === false) {
                    if (document[fullscreenAPI.fullscreenElement]) {
                        document[fullscreenAPI.exitFullscreen]();
                    }
                }
            }));
        }
        else {
            // Simply send message for iOS
            this._message({ event: 'toggleFullscreen' });
        }
    };
    Player.prototype.resetPlayer = function () {
        this._message({ event: 'resetPlayer' });
    };
    Player.prototype._message = function (options) {
        if (this.ready() !== true) {
            embed_helpers_log('Player is not ready yet! No messages can be recieved.', 'error');
            return;
        }
        send(vidyard_player_assign({}, options, { uuid: this.uuid }), "https://" + getPlaybackURL(), this.iframe);
    };
    Player.prototype._updateStatus = function (data) {
        if (typeof data.status === 'object') {
            this.status = data.status;
        }
        if (typeof data.metadata === 'object') {
            this.metadata = data.metadata;
        }
        if (this.status) {
            if (this.status.currentTime !== this._previousTime && this._callbackStore.timeupdate) {
                for (var _i = 0, _a = this._callbackStore.timeupdate; _i < _a.length; _i++) {
                    var callback = _a[_i];
                    callback.call(this, this.status.currentTime, this);
                }
            }
            this._previousTime = this.status.currentTime;
        }
    };
    return Player;
}());
/* harmony default export */ var vidyard_player = (vidyard_player_Player);

// CONCATENATED MODULE: ./src/models/renderer.ts
/*
* Handles sweeping over the DOM and injecting all types of players
* Effectively is the puppet master for all the embed code stuff
*/












var sweepDocument = function (container) {
    if (container === void 0) { container = document; }
    // Find all divs that belong to vy
    var embedLocations = getElementByClass('vidyard-player-embed', 'img', container);
    preloadFrames(embedLocations);
    toArray(embedLocations).forEach(renderPlayer);
    dispatch_ready();
};
var renderPlayer = function (placeholderImg) {
    var _a = window.VidyardV4, integrations = _a.integrations, api = _a.api, players = _a.players, playerReadyListeners = _a.playerReadyListeners;
    var dataParams = new data_params(placeholderImg);
    var uuid = dataParams.uuid;
    var log = logger.setLevel(uuid);
    log("rendering");
    // Cant do anything without a uuid, just skip it
    if (uuid === undefined) {
        embed_helpers_log('Embed without a UUID detected, it is impossible to insert a player without a UUID. Add "data-uuid=some_uuid" to the offending element.' +
            placeholderImg);
        return;
    }
    if (dataParams.rendered === 'true') {
        log("Already rendered");
        return find(players, function (player) { return player.placeholder === placeholderImg; });
    }
    var container = views_container(uuid, dataParams);
    var newPlayer = new vidyard_player(container, uuid);
    placeholderImg.setAttribute('data-rendered', 'true');
    placeholderImg.parentNode.insertBefore(container, placeholderImg);
    newPlayer.placeholder = placeholderImg;
    newPlayer.container = container;
    players.push(newPlayer);
    processReadyListeners(newPlayer);
    // Inject player HTML into the dom
    if (dataParams.type === 'inline') {
        inline_player({ dataParams: dataParams, player: newPlayer });
    }
    else if (dataParams.type === 'lightbox') {
        lightbox_player({ dataParams: dataParams, player: newPlayer });
    }
    integrationsControler(newPlayer);
    seoController(uuid);
    // add the player to the window.Vidyard global
    // used for progress events and some integrations
    window.Vidyard._players[newPlayer.uuid] = newPlayer;
    return newPlayer;
};

// CONCATENATED MODULE: ./src/api/destroy-player.ts

function unsubscribeProgressEvents(player) {
    player.progressEventsUnsubscribe.forEach(function (cb) { return cb(); });
    player.progressEventsUnsubscribe = [];
}
function destroyPlayer(player) {
    var players = window.VidyardV4.players;
    if (includes(players, player)) {
        unsubscribeProgressEvents(player);
        player.off();
        player.container.parentNode.removeChild(player.container);
        player.placeholder.parentNode.removeChild(player.placeholder);
        players.splice(indexOfArray(player, players));
    }
    else {
        embed_helpers_log("Cannot destroy an unknown player", 'warn');
    }
}

// CONCATENATED MODULE: ./src/api/gdpr.ts
function consent(userConsent) {
    if (userConsent === undefined) {
        return;
    }
    var players = window.VidyardV4.players;
    var _loop_1 = function (player) {
        player.on('ready', function () {
            player.consentToGDPR(userConsent);
        });
    };
    for (var _i = 0, players_1 = players; _i < players_1.length; _i++) {
        var player = players_1[_i];
        _loop_1(player);
    }
}
// Used to determine whether or not to ask for GDPR consent on page load
// _readyConsent does not change based on calls to the consent function to limit usage
// to the expected use case at page load
function hasConsentOnReady(callback) {
    var playersReady = 0;
    var gdpr = window.VidyardV4.api.GDPR;
    var players = window.VidyardV4.players;
    if (players.length === 0) {
        return callback(false);
    }
    if (gdpr._readyConsent !== undefined) {
        return callback(gdpr._readyConsent);
    }
    // Make sure all the players are ready before returning the consent
    for (var _i = 0, players_2 = players; _i < players_2.length; _i++) {
        var player = players_2[_i];
        player.on('ready', function () {
            if (playersReady !== players.length) {
                playersReady += 1;
            }
            if (playersReady === players.length) {
                // TODO: can't use reduce in old IE, add helper
                gdpr._readyConsent = players.reduce(function (c, p) { return p.status.consent && c; }, true);
                return callback(gdpr._readyConsent);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/api/get-players-by-uuid.ts
function getPlayersByUUID(uuid) {
    return window.VidyardV4.players.filter(function (player) { return player.uuid === uuid; });
}
/* harmony default export */ var get_players_by_uuid = (getPlayersByUUID);

// CONCATENATED MODULE: ./src/api/progress-events/remove-duplicates.ts
var removeDuplicates = function (targetArray) {
    targetArray.sort(function (a, b) {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    });
    var i = 0;
    while (i < targetArray.length) {
        if (targetArray[i] === targetArray[i + 1]) {
            targetArray.splice(i + 1, 1);
        }
        else {
            i += 1;
        }
    }
    return targetArray;
};

// CONCATENATED MODULE: ./src/api/progress-events/sorted-list.ts
// Stripped down version of: https://github.com/shinout/SortedList
// TODO: refactor with a class
// TODO: use map?
function SortedList() {
    this._compare = function (a, b) {
        if (a[0] < b[0]) {
            return -1;
        }
        if (a[0] > b[0]) {
            return 1;
        }
        if (a[1] < b[1]) {
            return -1;
        }
        if (a[1] > b[1]) {
            return 1;
        }
        return 0;
    };
}
SortedList.create = function () {
    return new SortedList();
};
SortedList.prototype = new Array();
SortedList.prototype.constructor = Array.prototype.constructor;
SortedList.prototype.insertOne = function (val) {
    var pos = this.bsearch(val);
    this.splice(pos + 1, 0, val);
    return pos + 1;
};
SortedList.prototype.remove = function (pos) {
    this.splice(pos, 1);
    return this;
};
SortedList.prototype.bsearch = function (val) {
    if (!this.length) {
        return -1;
    }
    var mpos;
    var mval;
    var comp;
    var spos = 0;
    var epos = this.length;
    while (epos - spos > 1) {
        mpos = Math.floor((spos + epos) / 2);
        mval = this[mpos];
        comp = this._compare(val, mval);
        if (comp === 0) {
            return mpos;
        }
        if (comp > 0) {
            spos = mpos;
        }
        else {
            epos = mpos;
        }
    }
    return spos === 0 && this._compare(this[0], val) > 0 ? -1 : spos;
};

// CONCATENATED MODULE: ./src/api/progress-events/union-intervals.ts
function unionIntervals(sortedIntervals) {
    var prevInterval = null;
    var results = [];
    var index;
    for (index = 0; index < sortedIntervals.length; ++index) {
        if (!prevInterval || prevInterval[1] < sortedIntervals[index][0]) {
            if (prevInterval) {
                results.push(prevInterval);
            }
            prevInterval = [sortedIntervals[index][0], sortedIntervals[index][1]];
        }
        else if (sortedIntervals[index][1] > prevInterval[1]) {
            prevInterval[1] = sortedIntervals[index][1];
        }
    }
    if (prevInterval) {
        results.push(prevInterval);
    }
    return results;
}

// CONCATENATED MODULE: ./src/api/progress-events/set-event-listeners.ts


function setEventListeners(player, callback, thresholdList) {
    var intervalList = [];
    var lock = false;
    var currentChpater = player.getCurrentChapter();
    function setupChapter() {
        var chapter = player.getCurrentChapter();
        intervalList[chapter] = {
            interval: [0, 0],
            intervals: SortedList.create(),
            thresholds: thresholdList.slice(),
        };
        return intervalList[chapter];
    }
    function computeProgress(time, cb) {
        var unions;
        var totalViewed = 0;
        var chapter = player.getCurrentChapter();
        var checkIntervalPosition;
        var index;
        if (typeof intervalList[chapter] === 'undefined') {
            setupChapter();
        }
        if (lock ||
            typeof player.metadata !== 'object' ||
            time <= intervalList[chapter].interval[1]) {
            return;
        }
        // Close the current interval with the current time, insert into interval list, then calculate union
        intervalList[chapter].interval[1] = time;
        checkIntervalPosition = intervalList[chapter].intervals.insertOne(intervalList[chapter].interval);
        unions = unionIntervals(intervalList[chapter].intervals);
        // Replace Interval List with the union if possible during summation
        if (unions.length + 1 < intervalList[chapter].intervals.length) {
            intervalList[chapter].intervals = SortedList.create();
            for (index = 0; index < unions.length; ++index) {
                totalViewed += unions[index][1] - unions[index][0];
                intervalList[chapter].intervals.insertOne(unions[index]);
            }
        }
        else {
            for (index = 0; index < unions.length; ++index) {
                totalViewed += unions[index][1] - unions[index][0];
            }
            intervalList[chapter].intervals.remove(checkIntervalPosition);
        }
        if (typeof player.metadata.chapters_attributes[chapter].video_attributes
            .length_in_milliseconds === 'number') {
            totalViewed =
                (totalViewed /
                    player.metadata.chapters_attributes[chapter].video_attributes
                        .length_in_milliseconds) *
                    100000;
        }
        else {
            totalViewed =
                (totalViewed /
                    player.metadata.chapters_attributes[chapter].video_attributes
                        .length_in_seconds) *
                    100;
        }
        if (Math.round(totalViewed) >= intervalList[chapter].thresholds[0]) {
            return cb({
                chapter: chapter,
                event: intervalList[chapter].thresholds.shift(),
                player: player,
            });
        }
    }
    var onTimeUpdate = function (time) {
        // On chapter switches, timeupdate might be called with the time from the previous chapter, so we require
        // two time updates from the same chapter before we start computing progress
        var tempChapter = player.getCurrentChapter();
        if (currentChpater !== tempChapter) {
            currentChpater = tempChapter;
            return;
        }
        computeProgress(time, callback);
    };
    var onBeforeSeek = function (time) {
        var chapter = player.getCurrentChapter();
        // on Safari beforeSeek can fire before play ¯\_(ツ)_/¯
        if (typeof intervalList[chapter] === 'undefined') {
            return;
        }
        if (lock === false) {
            intervalList[chapter].interval[1] = time.start;
        }
        lock = true;
    };
    var onPlay = function (time) {
        var currTime = time;
        var chapter = player.getCurrentChapter();
        if (typeof intervalList[chapter] === 'undefined') {
            setupChapter();
        }
        intervalList[chapter].intervals.insertOne(intervalList[chapter].interval.slice(0));
        intervalList[chapter].interval[0] = currTime;
        intervalList[chapter].interval[1] = currTime;
        lock = false;
    };
    var onChapterComplete = function (chapter) {
        intervalList[chapter].interval = [0, 0];
        lock = false;
    };
    player.on('timeupdate', onTimeUpdate);
    player.on('beforeSeek', onBeforeSeek);
    player.on('play', onPlay);
    player.on('chapterComplete', onChapterComplete);
    return {
        player: player,
        removeEventListeners: function () {
            player.off('beforeSeek', onBeforeSeek);
            player.off('chapterComplete', onChapterComplete);
            player.off('play', onPlay);
            player.off('timeupdate', onTimeUpdate);
            player = null;
            intervalList = [];
        },
    };
}

// CONCATENATED MODULE: ./src/api/progress-events-wrapper.ts



// Initialize analytics for each player when called
function progressEvents(callback, thresholds, singlePlayerScope) {
    var _a;
    if (thresholds === void 0) { thresholds = [1, 25, 50, 75, 90]; }
    var removeEventListeners = [];
    var players = singlePlayerScope
        ? (_a = {}, _a[singlePlayerScope.uuid] = singlePlayerScope, _a) : getPlayers();
    // Sort and unique the array in case we are passed an unusual array of thresholds
    var dedupedThresholds = removeDuplicates(thresholds);
    var _loop_1 = function (uuid) {
        if (players.hasOwnProperty(uuid) && uuid.length > 0 && players[uuid] !== '') {
            // set the listener
            var removeCb = setEventListeners(players[uuid], callback, dedupedThresholds);
            removeEventListeners.push(removeCb);
        }
        else {
            embed_helpers_log(function () {
                return console.error("Could not attach Progress Events to player " + uuid + ", make sure to load the Vidyard Player API");
            });
        }
    };
    for (var uuid in players) {
        _loop_1(uuid);
    }
    if (removeEventListeners.length === 0) {
        embed_helpers_log(function () {
            return console.warn('No Vidyard Players found. (include this script below player embed codes)');
        });
    }
    return removeEventListeners;
}
function getPlayers() {
    try {
        return window.Vidyard.players();
    }
    catch (e) {
        embed_helpers_log(function () {
            return console.error('The Vidyard Player API must be loaded before this script can execute');
        });
        return {};
    }
}
function progressEventsWrapper() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var subscriptions = progressEvents.apply(void 0, args);
    Object.keys(subscriptions).forEach(function (k) {
        var _a = subscriptions[k], player = _a.player, removeEventListeners = _a.removeEventListeners;
        if (player.progressEventsUnsubscribe) {
            player.progressEventsUnsubscribe.push(removeEventListeners);
        }
    });
}

// CONCATENATED MODULE: ./src/api/render-player.ts






// TODO: change Promise<any> to Promise<Player> once we have a proper type for it
var renderPlayerFromPlaceholder = function (image) {
    logger.setLevel('placeholder')('rendering player from placeholder image');
    var player = renderPlayer(image);
    // resolve when the player is ready, unless the player is a lightbox
    return new promise(function (res) {
        if (player.showLightbox) {
            res(player);
        }
        else {
            player.on('ready', function () { return res(player); });
        }
    });
};
function render_player_renderPlayer(options) {
    // TODO: instead of creating an image make render.renderPlayer work with an options objects
    var placeholder = options instanceof HTMLImageElement ? options : createPlaceholder(options);
    return loadPlaceholder(placeholder)
        .then(renderPlayerFromPlaceholder)
        .catch(function (e) { return embed_helpers_log(messages.errors.placeholder, 'warn'); });
}

// CONCATENATED MODULE: ./src/api/vidyard-v4-global.ts










var vidyardV4Global = {
    _debug: api_debug,
    api: {
        GDPR: { consent: consent, hasConsentOnReady: hasConsentOnReady },
        addReadyListener: addReadyListener,
        destroyPlayer: destroyPlayer,
        getPlayerMetadata: getPlayerMetadata,
        getPlayersByUUID: get_players_by_uuid,
        progressEvents: progressEventsWrapper,
        renderDOMPlayers: sweepDocument,
        renderPlayer: render_player_renderPlayer,
    },
    integrations: new IntegrationsWatcher(),
    jsonp: {},
    // Just ensure that the undefined uuid option is always present
    playerReadyListeners: { undefined: [] },
    players: [],
    preloadLinks: [],
};
/* harmony default export */ var vidyard_v4_global = (vidyardV4Global);

// CONCATENATED MODULE: ./src/api/vidyard-global.ts
var vidyardGlobal = {
    _players: {},
    players: function () {
        return window.VidyardV4.players.reduce(function (acc, player) {
            acc[player.uuid] = player;
            return acc;
        }, {});
    },
};
/* harmony default export */ var vidyard_global = (vidyardGlobal);

// EXTERNAL MODULE: ./src/css/style.css
var css_style = __webpack_require__(12);

// EXTERNAL MODULE: /Users/bmubarak/vidyard/vidyard-player-sdk/node_modules/error-stack-parser/error-stack-parser.js
var error_stack_parser = __webpack_require__(2);

// CONCATENATED MODULE: ./src/utils/error-report.ts


// based on the Rollbar API
// https://docs.rollbar.com/v1.0.0/reference#section-data-format<Paste>
function createErrorReport(_a) {
    var error = _a.error, location = _a.location, message = _a.message, navigator = _a.navigator, timeStamp = _a.timeStamp, type = _a.type, vyGlobal = _a.vyGlobal;
    return {
        data: {
            // Required: body
            // The main data being sent. It can either be a message, an exception, or a crash report.
            body: {
                // If this payload is a single exception, use "trace"
                // A list of stack frames, ordered such that the most recent call is last in the list.
                trace: {
                    // Required: exception
                    // An object describing the exception instance.
                    exception: {
                        // Required: class
                        // The exception class name.
                        class: error.name,
                        // Optional: message
                        // The exception message, as a string
                        message: message,
                    },
                    // Each frame is an object.
                    frames: error_stack_parser["parse"](error).map(function (frame) { return ({
                        // Optional: code
                        // The line of code
                        code: frame.source,
                        // Optional: colno
                        // The column number as an integer
                        colno: frame.columnNumber,
                        // Required: filename
                        // The filename including its full path.
                        filename: frame.fileName,
                        // Optional: colno
                        // The column number as an integer
                        lineno: frame.lineNumber,
                        // Optional: method
                        // The method or function name
                        method: frame.functionName,
                    }); }),
                },
            },
            // Optional: client
            // Data about the client device this event occurred on.
            // As there can be multiple client environments for a given event (i.e. Flash running inside
            // an HTML page), data should be namespaced by platform.
            client: {
                // Can contain any arbitrary keys. Rollbar understands the following:
                // Optional: cpu
                // A string up to 255 characters
                cpu: navigator.platform,
                javascript: {
                    // Optional: browser
                    // The user agent string
                    browser: navigator.userAgent,
                    // Optional: guess_uncaught_frames
                    // Set to true to enable frame guessing
                    // See the "Source Maps" guide for more details.
                    guess_uncaught_frames: true,
                    // Optional: source_map_enabled
                    // Set to true to enable source map deobfuscation
                    // See the "Source Maps" guide for more details.
                    source_map_enabled: true,
                },
            },
            // Optional: code_version
            // A string, up to 40 characters, describing the version of the application code
            // Rollbar understands these formats:
            // - semantic version (i.e. "2.1.12")
            // - integer (i.e. "45")
            // - git SHA (i.e. "3da541559918a808c2402bba5012f6c60b27661c")
            code_version: VERSION,
            // Optional: custom
            // Any arbitrary metadata you want to send. "custom" itself should be an object.
            custom: {
                jsonpRequests: Object.keys(vyGlobal.jsonp),
                playbackUrlOverride: window.VIDYARD_PLAYBACK_URL,
                players: vyGlobal.players.map(function (player) { return ({
                    iframe: player.iframe ? { src: player.iframe.src } : {},
                    metadata: player.metadata,
                    org: player.org
                        ? { id: player.org.id, foundIntegrations: player.org.foundIntegrations }
                        : {},
                    uuid: player.uuid,
                }); }),
                preloadLinks: vyGlobal.preloadLinks,
            },
            // Required: environment
            // The name of the environment in which this occurrence was seen.
            // A string up to 255 characters. For best results, use "production" or "prod" for your
            // production environment.
            // You don't need to configure anything in the Rollbar UI for new environment names;
            // we'll detect them automatically.
            environment: getPlaybackURL(),
            // Optional: fingerprint
            // A string controlling how this occurrence should be grouped. Occurrences with the same
            // fingerprint are grouped together. See the "Grouping" guide for more information.
            // Should be a string up to 40 characters long; if longer than 40 characters, we'll use its SHA1 hash.
            // If omitted, we'll determine this on the backend.
            fingerprint: error.name,
            // Optional: language
            // The name of the language your code is written in.
            // This can affect the order of the frames in the stack trace. The following languages set the most
            // recent call first - 'ruby', 'javascript', 'php', 'java', 'objective-c', 'lua'
            // It will also change the way the individual frames are displayed, with what is most consistent with
            // users of the language.
            language: 'javascript',
            // Optional: level
            // The severity level. One of: "critical", "error", "warning", "info", "debug"
            // Defaults to "error" for exceptions and "info" for messages.
            // The level of the *first* occurrence of an item is used as the item's level.
            level: type,
            // Optional: platform
            // The platform on which this occurred. Meaningful platform names:
            // "browser", "android", "ios", "flash", "client", "heroku", "google-app-engine"
            // If this is a client-side event, be sure to specify the platform and use a post_client_item access token.
            platform: 'browser',
            // Optional: request
            // Data about the request this event occurred in.
            // Can contain any arbitrary keys. Rollbar understands the following:
            // query_string: the raw query string
            // url: full URL where this event occurred
            request: { query_string: location.search, url: location.href },
            // Optional: timestamp
            // When this occurred, as a unix timestamp.
            timestamp: timeStamp,
        },
    };
}

// CONCATENATED MODULE: ./src/utils/error-logger.ts



var vyError = function (source) {
    if (source === void 0) { source = ''; }
    return source.match(ERROR_ORIGIN_RE);
};
var errorHandler = function (_a) {
    var error = _a.error, filename = _a.filename, message = _a.message, timeStamp = _a.timeStamp, type = _a.type;
    if (vyError(filename)) {
        var location_1 = window.location, navigator_1 = window.navigator, vyGlobal = window.VidyardV4;
        var payload = createErrorReport({
            error: error,
            location: location_1,
            message: message,
            navigator: navigator_1,
            timeStamp: timeStamp,
            type: type,
            vyGlobal: vyGlobal,
        });
        xhrRequest({ endpoint: getErrorURL(), method: 'POST', payload: payload }).then(function (res) { return embed_helpers_log("Error logged " + res); }, function (e) { return embed_helpers_log("Error log failed " + e); });
    }
};
function logErrors() {
    addListener('error', 'onerror', errorHandler, window);
    addListener('unhandledrejection', '', function (e) {
        var error = e.reason, timeStamp = e.timeStamp, type = e.type;
        if (e.reason instanceof Error && vyError(error.stack)) {
            // prevent errors in the console
            e.preventDefault();
            errorHandler({
                error: error,
                // PromiseRejectionEvents do not have a filename field
                // the workaround is to look for the v4.js script in the stack trace
                filename: error.stack,
                message: error.message,
                timeStamp: timeStamp,
                type: type,
            });
        }
    });
}

// CONCATENATED MODULE: ./src/index.module.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_debug", function() { return _debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "api", function() { return index_module_api; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "players", function() { return index_module_players; });





// --- Runs on script execution ---
logErrors();
// Bind legacy globals
window.VidyardV4 = window.VidyardV4 || vidyard_v4_global;
window.Vidyard = window.Vidyard || vidyard_global;
dispatch_ready();
var _debug = vidyard_v4_global._debug, index_module_api = vidyard_v4_global.api, index_module_players = vidyard_v4_global.players;
// Export the public API

/* harmony default export */ var index_module = __webpack_exports__["default"] = (vidyard_v4_global);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
}(this, function() {
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps);

    function StackFrame(obj) {
        if (obj instanceof Object) {
            for (var i = 0; i < props.length; i++) {
                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                    this['set' + _capitalize(props[i])](obj[props[i]]);
                }
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),
/* 8 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(8);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto);

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media);
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 10 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(10)(false);
// imports


// module
exports.push([module.i, ".vidyard-player-container .play-button{position:absolute;width:16%;height:auto;border-radius:50%;border:none;cursor:pointer;opacity:.65;filter:alpha(opacity = 65);transition:opacity .2s linear;overflow:hidden;font-size:0;padding:0;min-width:20px;top:50%;left:50%;transform:translate(-50%,-50%);-webkit-appearance:initial!important;-moz-appearance:initial!important;appearance:initial!important}.vidyard-player-container .play-button .play-button-size{padding-top:100%;width:100%}.vidyard-player-container .play-button .arrow-size{position:absolute;top:50%;left:50%;width:35%;height:auto;margin:-25% 0 0 -12%;overflow:hidden}.vidyard-player-container .play-button .arrow-size-ratio{padding-top:150%;width:100%}.vidyard-player-container .play-button .arrow{position:absolute;top:50%;left:auto;right:0;bottom:auto;width:0;height:0;margin:-200px 0 -200px -300px;border:200px solid transparent;border-left:300px solid #fff;border-right:none}.vidyard-lightbox-thumbnail:hover .play-button{opacity:1;filter:alpha(opacity = 100);zoom:1}.vidyard-player-container{position:relative;height:100%;text-align:center}.vidyard-player-container img{height:100%}.vidyard-player-container .play-button{display:none}.vidyard-close-container{position:fixed;right:20px;top:20px;height:34px;width:34px;cursor:pointer;z-index:1000}.vidyard-close-container:focus{outline:1px dotted grey}.vidyard-close-x{position:absolute;height:100%;width:100%;color:#fff;font-size:2em;text-align:center;line-height:34px}.vidyard-close-x:hover{color:#ddd}.vidyard-close-x:hover:after,.vidyard-close-x:hover:before{background:#ddd}.vidyard-close-x:after,.vidyard-close-x:before{content:\"\";position:absolute;background:#fff;display:block;left:50%;top:50%;height:65%;width:2px;transition:all .2s;-ms-high-contrast-adjust:none}.vidyard-close-x:before{transform:translate(-50%,-50%) rotate(45deg);-ms-transform:translate(-50%,-50%) rotate(45deg)}.vidyard-close-x:after{transform:translate(-50%,-50%) rotate(-45deg);-ms-transform:translate(-50%,-50%) rotate(-45deg)}.vidyard-close-x.simple-close:after,.vidyard-close-x.simple-close:before{display:none}.vidyard-lightbox-thumbnail{width:100%;height:100%;margin:auto}.vidyard-lightbox-image{height:100%;left:0;position:absolute;top:0;width:100%}.vidyard-lightbox-centering{cursor:pointer;height:0;max-width:100%;overflow:hidden;padding-bottom:56.25%;position:relative}.vidyard-lightbox-content-backer{-webkit-transform:opacity 1s,filter 1s;-ms-transform:opacity 1s,filter 1s;transition:opacity 1s,filter 1s;background-color:#000;height:100%;width:100%;position:absolute}#vidyard-overlay-wrapper,.vidyard-lightbox-content-backer{filter:alpha(opacity = 0);opacity:0;top:0;right:0;bottom:0;left:0}#vidyard-overlay-wrapper{position:relative;box-sizing:border-box;display:none;transition:opacity .5s,filter .5s}#vidyard-overlay{top:0;right:0;bottom:0;left:0;opacity:.9;filter:alpha(opacity = 90);width:100%;height:100%;background-color:#000;z-index:800}#vidyard-content-fixed,#vidyard-overlay{position:fixed;box-sizing:border-box;display:none}#vidyard-content-fixed{opacity:1;z-index:900;text-align:center;top:5%;right:5%;bottom:5%;left:5%;width:90%}#vidyard-popbox{display:inline-block;position:absolute;left:50%;top:50%;-webit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}#vidyard-popbox-constraint{opacity:0;filter:alpha(opacity = 0);display:block;visibility:hidden}#vidyard-popbox-constraint.landscape{height:90vh}#vidyard-popbox-constraint.portrait{width:90vw}.vidyard-player-container div[class^=vidyard-iframe-]{z-index:1}.vidyard-player-container div[class^=vidyard-div-]{background-repeat:no-repeat;background-position:0 50%;background-size:100%}img.vidyard-player-embed{width:100%}img.vidyard-player-embed.inserted{position:absolute;top:0;left:0;z-index:0;max-width:100%!important}.vidyard-player-container.playlist-open{padding-right:319px;width:auto!important}.vidyard-player-container.playlist-open div[class^=vidyard-div-]{width:calc(100% + 319px);max-width:calc(100% + 319px)!important;background-size:calc(100% - 319px);background-color:#f5f9ff}.vidyard-player-container.playlist-open div[class^=vidyard-div-] img.vidyard-player-embed{width:calc(100% - 319px)!important}", ""]);

// exports


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(11);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;



var options = {"hmr":true};

options.transform = transform;
options.insertInto = undefined;

var update = __webpack_require__(9)(content, options);

if(content.locals) module.exports = content.locals;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {
 // filter function for ancestor elements

var filterAncestor = function filterAncestor(item) {
  return item.nodeType === 1 && item.tagName.toLowerCase() !== 'body' && item.tagName.toLowerCase() !== 'html';
}; // filter function for sibling elements


var filterSibling = function filterSibling(item) {
  return item.nodeType === 1 && item.tagName.toLowerCase() !== 'script';
}; // reducer to flatten arrays


var flattenArrays = function flattenArrays(a, b) {
  return a.concat(b);
}; // recursive function to get previous sibling nodes of given element


function getPreviousSiblings(el) {
  var siblings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var previousSibling = el.previousSibling;

  if (!previousSibling) {
    return siblings;
  }

  siblings.push(previousSibling);
  return getPreviousSiblings(previousSibling, siblings);
} // recursive function to get next sibling nodes of given element


function getNextSiblings(el) {
  var siblings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var nextSibling = el.nextSibling;

  if (!nextSibling) {
    return siblings;
  }

  siblings.push(nextSibling);
  return getNextSiblings(nextSibling, siblings);
} // returns all sibling element nodes of given element


function getSiblings(el) {
  var allSiblings = getPreviousSiblings(el).concat(getNextSiblings(el));
  return allSiblings.filter(filterSibling);
} // recursive function to get all ancestor nodes of given element


function getAllAncestors(el) {
  var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var nextAncestor = el.parentNode;

  if (!nextAncestor) {
    return ancestors;
  }

  ancestors.push(nextAncestor);
  return getAllAncestors(nextAncestor, ancestors);
} // get ancestor nodes of given element


function getAncestors(el) {
  return getAllAncestors(el).filter(filterAncestor);
} // get siblings of ancestors (i.e. aunts and uncles) of given el


function getSiblingsOfAncestors(el) {
  return getAncestors(el).map(function (item) {
    return getSiblings(item);
  }).reduce(flattenArrays, []);
}

module.exports = {
  getSiblings: getSiblings,
  getAncestors: getAncestors,
  getSiblingsOfAncestors: getSiblingsOfAncestors
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
var NativeCustomEvent = global.CustomEvent;

function useNative () {
  try {
    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
    return  'cat' === p.type && 'bar' === p.detail.foo;
  } catch (e) {
  }
  return false;
}

/**
 * Cross-browser `CustomEvent` constructor.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
 *
 * @public
 */

module.exports = useNative() ? NativeCustomEvent :

// IE >= 9
'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {
  var e = document.createEvent('CustomEvent');
  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, void 0);
  }
  return e;
} :

// IE <= 8
function CustomEvent (type, params) {
  var e = document.createEventObject();
  e.type = type;
  if (params) {
    e.bubbles = Boolean(params.bubbles);
    e.cancelable = Boolean(params.cancelable);
    e.detail = params.detail;
  } else {
    e.bubbles = false;
    e.cancelable = false;
    e.detail = void 0;
  }
  return e;
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0)));

/***/ }),
/* 15 */,
/* 16 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ());
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] };

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined$1) {

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined$1, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0), __webpack_require__(16)));

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(17);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0)));

/***/ })
/******/ ]);
});
});

var Vidyard = unwrapExports(v4_umd);

/**
 * @summary Adds on ready actions and renders the player
 * with the given options.
 * @param {string} videoId - Video id.
 * @param {object} options - Player options.
 */

function initializeVidyard(videoId, options) {
  var container = document.querySelector(".".concat(videoClassName));
  var _Vidyard$api = Vidyard.api,
      addReadyListener = _Vidyard$api.addReadyListener,
      renderPlayer = _Vidyard$api.renderPlayer;
  addReadyListener(function (data, player) {
    player.play();
  });
  renderPlayer(_objectSpread2({
    uuid: videoId,
    container: container
  }, options));
}

/**
 * @summary Removes the player from the DOM and
 * window.Vidyard.players(), unsubscribes from all progress events.
 * @param {string} videoId - Video id.
 */

function destroyVidyard(videoId) {
  var _Vidyard$api = Vidyard.api,
      getPlayersByUUID = _Vidyard$api.getPlayersByUUID,
      destroyPlayer = _Vidyard$api.destroyPlayer;
  var player = getPlayersByUUID(videoId)[0];
  destroyPlayer(player);
}

/**
 * @summary Injects video script into the document body.
 */
function injectVideoScript(src) {
  var existingScript = document.querySelector("script[src=\"".concat(src, "\"]"));

  if (!existingScript) {
    var script = document.createElement('script');
    script.src = src;
    script.async = 'true';
    document.body.appendChild(script);
  }
}

var VideoOverlay = /*#__PURE__*/function (_Component) {
  _inherits(VideoOverlay, _Component);

  var _super = _createSuper(VideoOverlay);

  function VideoOverlay(props) {
    var _this;

    _classCallCheck(this, VideoOverlay);

    _this = _super.call(this);
    _this.state = {
      videoId: getVideoId(props.videoUrl)
    };
    _this.onKeyUp = _this.onKeyUp.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(VideoOverlay, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var _this$props = this.props,
          videoUrl = _this$props.videoUrl,
          playerOptions = _this$props.playerOptions;
      var videoId = getVideoId(videoUrl);
      this.setState({
        videoId: videoId
      }, function () {
        if (videoUrl.includes(wistiaIdentifier)) {
          injectVideoScript(wistiaScriptSrc);
        }

        if (videoUrl.includes(vidyardIdentifier)) {
          initializeVidyard(_this2.state.videoId, playerOptions);
        }
      });
      window.addEventListener('keyup', this.onKeyUp);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props2 = this.props,
          videoUrl = _this$props2.videoUrl,
          playerOptions = _this$props2.playerOptions,
          visible = _this$props2.visible;

      if (videoUrl.includes(vidyardIdentifier)) {
        if (!prevProps.visible && visible) {
          initializeVidyard(this.state.videoId, playerOptions);
        } else if (!visible) {
          destroyVidyard(this.state.videoId);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var videoUrl = this.props.videoUrl;
      var videoId = this.state.videoId;

      if (videoUrl.includes(vidyardIdentifier)) {
        destroyVidyard(videoId);
      }

      window.removeEventListener('keyup', this.onKeyUp);
    }
  }, {
    key: "onKeyUp",
    value: function onKeyUp(event) {
      event.key === 'Escape' && this.props.onClose();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          videoUrl = _this$props3.videoUrl,
          visible = _this$props3.visible,
          onClose = _this$props3.onClose,
          title = _this$props3.title,
          description = _this$props3.description,
          forwardRef = _this$props3.forwardRef,
          wistiaOptions = _this$props3.wistiaOptions;
      var videoId = this.state.videoId;
      var rootClassName = classnames(baseClassName$5, _defineProperty({}, "".concat(baseClassName$5, "--with-info"), title));

      if (visible) {
        return /*#__PURE__*/createPortal( /*#__PURE__*/React__default.createElement("div", _extends({
          className: rootClassName,
          onClick: onClose,
          ref: forwardRef || null
        }, this.passthrough()), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(baseClassName$5, "__content"),
          onClick: function onClick(e) {
            return e.stopPropagation();
          }
        }, /*#__PURE__*/React__default.createElement("div", {
          className: videoClassName
        }, videoUrl.includes(wistiaIdentifier) && /*#__PURE__*/React__default.createElement(WistiaTemplate, {
          id: videoId,
          options: wistiaOptions
        })), title && /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(baseClassName$5, "-info")
        }, /*#__PURE__*/React__default.createElement("h2", {
          className: "".concat(baseClassName$5, "-info__title")
        }, title), description && getDescription(description)), /*#__PURE__*/React__default.createElement("div", {
          className: "".concat(baseClassName$5, "__close-button")
        }, /*#__PURE__*/React__default.createElement(Panel, {
          spacing: "none",
          noBorder: true,
          elevation: "08"
        }, /*#__PURE__*/React__default.createElement(Button, {
          color: "ghost-alternative",
          size: "s",
          onClick: onClose
        }, /*#__PURE__*/React__default.createElement(Icon, {
          icon: "cross",
          size: "s"
        })))))), document.body);
      }

      return null;
    }
  }]);

  return VideoOverlay;
}(Component);
VideoOverlay.propTypes = {
  videoUrl: PropTypes.string.isRequired,
  visible: PropTypes.bool.isRequired,
  onClose: PropTypes.func.isRequired,
  title: PropTypes.string,
  description: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  wistiaOptions: PropTypes.object,
  playerOptions: PropTypes.object
};
VideoOverlay.defaultProps = {
  visible: false
};
passthrough()(VideoOverlay);

var VideoThumbnail = /*#__PURE__*/function (_Component) {
  _inherits(VideoThumbnail, _Component);

  var _super = _createSuper(VideoThumbnail);

  function VideoThumbnail() {
    _classCallCheck(this, VideoThumbnail);

    return _super.apply(this, arguments);
  }

  _createClass(VideoThumbnail, [{
    key: "render",
    value:
    /* eslint-disable complexity */
    function render() {
      var _this$props = this.props,
          image = _this$props.image,
          imageAlt = _this$props.imageAlt,
          title = _this$props.title,
          description = _this$props.description,
          givenBadgeText = _this$props.badgeText,
          lengthInSeconds = _this$props.lengthInSeconds,
          noPlayButton = _this$props.noPlayButton,
          noGrayscale = _this$props.noGrayscale,
          givenClassName = _this$props.className,
          forwardRef = _this$props.forwardRef,
          href = _this$props.href,
          embedded = _this$props.embedded;
      var baseClassName = cuiClassName('video-thumbnail');

      var props = _objectSpread2(_objectSpread2(_objectSpread2({
        className: classnames(baseClassName, givenClassName, _defineProperty({}, "".concat(baseClassName, "--fixed-size"), !embedded))
      }, href && {
        href: href
      }), forwardRef && {
        ref: forwardRef
      }), this.passthrough());

      var imageClassName = classnames("".concat(baseClassName, "__image"), _defineProperty({}, "".concat(baseClassName, "__image--no-grayscale"), noGrayscale));
      var badgeText = lengthInSeconds ? VideoThumbnail.formatLength(lengthInSeconds) : givenBadgeText;
      var thumbnail = /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(baseClassName, "__media")
      }, image && /*#__PURE__*/React__default.createElement("img", {
        alt: imageAlt ? imageAlt : title,
        className: imageClassName,
        src: image
      }), !noPlayButton && /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(baseClassName, "__play")
      }), badgeText && /*#__PURE__*/React__default.createElement(Badge, {
        className: "".concat(baseClassName, "__badge")
      }, badgeText));
      var thumbnailContent = title && /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(baseClassName, "__content")
      }, /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(baseClassName, "__title"),
        title: title
      }, title), description && /*#__PURE__*/React__default.createElement("div", {
        className: "".concat(baseClassName, "__description")
      }, description));
      var content = embedded ? thumbnail : /*#__PURE__*/React__default.createElement(Panel, {
        className: "".concat(baseClassName, "__panel"),
        radius: "s",
        elevation: "01",
        noBorder: true,
        spacing: "none",
        noMargin: true
      }, thumbnail, thumbnailContent);

      if (href) {
        return /*#__PURE__*/React__default.createElement("a", props, content);
      }

      return /*#__PURE__*/React__default.createElement("div", props, content);
    }
  }], [{
    key: "formatLength",
    value: function formatLength(lengthInSeconds) {
      var hours = Math.floor(lengthInSeconds / 3600);
      var minutes = Math.floor(lengthInSeconds / 60) % 60;
      var seconds = Math.round(lengthInSeconds % 60);
      var pieces = [minutes, seconds].map(function (t) {
        return t.toString().padStart(2, '0');
      });

      if (hours > 0) {
        pieces.unshift(hours.toString());
      }

      return pieces.join(':');
    }
  }]);

  return VideoThumbnail;
}(Component);
VideoThumbnail.propTypes = {
  className: PropTypes.string,
  forwardRef: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  image: PropTypes.string,
  imageAlt: PropTypes.string,
  title: PropTypes.string,
  description: PropTypes.node,
  badgeText: PropTypes.string,
  lengthInSeconds: PropTypes.number,
  noPlayButton: PropTypes.bool,
  noGrayscale: PropTypes.bool,
  href: PropTypes.string,

  /** For embedding into custom UI */
  embedded: PropTypes.bool
};
passthrough()(VideoThumbnail);

export { AudioPlayer, Avatar, Badge, Button, ButtonGroup, config as CUI, Checkbox, Dialog, Dropmenu, EditableText, feedbackCheckbox as FeedbackCheckbox, FeedbackModal, feedbackSelect as FeedbackSelect, feedbackTextarea as FeedbackTextarea, Form, Icon, ImageOverlay, InlineInfo, Input, Message, Modal, Option, Panel, Pill, Popover, Progressbar, Radio, Select, Separator, Sidebar, Snackbar, Spacing, Spinner, StageSelector, Table, Tabs, Tag, Text, Textarea, Toggle, Tooltip, Trend, UserChip, VideoOverlay, VideoThumbnail };
//# sourceMappingURL=convention-ui-react.esm.js.map
