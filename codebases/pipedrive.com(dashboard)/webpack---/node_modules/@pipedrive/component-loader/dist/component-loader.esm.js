var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();



























var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var myDefine = function myDefine() {
	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	var fixedArguments = [null, null, null].concat(args);
	var name = fixedArguments[fixedArguments.length - 3];
	var deps = fixedArguments[fixedArguments.length - 2];
	var callback = fixedArguments[fixedArguments.length - 1];

	window.define.lastScript = [name, deps, callback];
};

myDefine.amd = true;
myDefine.componentLoader = true;

function makeDefine() {
	if (!window.define) {
		window.define = myDefine;
	}
}

var AMDLoader = function () {
	function AMDLoader() {
		classCallCheck(this, AMDLoader);

		makeDefine();

		this.externals = {};
		this.dependencyLoader = null;
	}

	createClass(AMDLoader, [{
		key: 'setDependencyLoader',
		value: function setDependencyLoader(loader) {
			this.dependencyLoader = loader;
		}
	}, {
		key: 'registerExternal',
		value: function registerExternal(key, value) {
			this.externals[key] = value;
		}
	}, {
		key: 'resolveModule',
		value: function resolveModule(definition, callbackArguments) {
			return Promise.resolve(definition.apply(undefined, toConsumableArray(callbackArguments))).then(function (result) {
				if (result && result.__esModule && 'default' in result) {
					// eslint-disable-next-line dot-notation
					var defaultResult = result['default'];

					if (Object.keys(defaultResult).find(function (key) {
						return key in result;
					})) {
						throw new Error('esModule has same key(s) as named export(s)');
					}

					Object.assign(defaultResult, result);

					return defaultResult;
				}

				return result;
			});
		}
	}, {
		key: 'load',
		value: function load(url, anonymousCrossorigin) {
			var _this = this;

			return new Promise(function (resolve, reject) {
				var script = document.createElement('script');

				script.src = url;
				script.onload = function () {
					if (!window.define.lastScript) {
						// Loaded module does not follow AMD format
						return resolve();
					}

					var deps = window.define.lastScript[1];
					var definition = window.define.lastScript[2];

					// eslint-disable-next-line no-undefined
					window.define.lastScript = undefined;

					if (deps && deps.length) {
						Promise.all(deps.map(function (dependency) {
							var cachedDependency = _this.externals[dependency];

							if (cachedDependency) {
								return Promise.resolve(cachedDependency);
							}

							return new Promise(function (resolve, reject) {
								if (_this.dependencyLoader) {
									_this.dependencyLoader(dependency).then(function (loadedExternal) {
										_this.registerExternal(dependency, loadedExternal);
										resolve(loadedExternal);
									}).catch(function (error) {
										reject(error);
									});
								} else {
									reject('Could not lazy load ' + dependency + ' because depedencyLoader was not registered.');
								}
							});
						})).then(function (callbackArguments) {
							resolve(function () {
								return _this.resolveModule(definition, callbackArguments);
							});
						}).catch(function (error) {
							reject(error);
						});
					} else {
						resolve(function () {
							return _this.resolveModule(definition, []);
						});
					}
				};
				script.onerror = function () {
					return reject('error');
				};
				script.onabort = function () {
					return reject('abort');
				};

				if (anonymousCrossorigin) {
					script.setAttribute('crossorigin', 'anonymous');
				}

				document.getElementsByTagName('head')[0].appendChild(script);
			});
		}
	}]);
	return AMDLoader;
}();

var ComponentLoader = function () {
	function ComponentLoader(componentsToRegister) {
		classCallCheck(this, ComponentLoader);

		this.components = {};
		this.cachedComponents = {};
		this.cachedVendors = {};
		this.loader = new AMDLoader();
		this.register(componentsToRegister);
	}

	createClass(ComponentLoader, [{
		key: 'register',
		value: function register(componentsToRegister) {
			if (componentsToRegister) {
				Object.assign(this.components, componentsToRegister);
			}
		}
	}, {
		key: 'registerExternals',
		value: function registerExternals(externals) {
			var _this = this;

			Object.keys(externals).forEach(function (key) {
				_this.registerExternal(key, externals[key]);
			});
		}
	}, {
		key: 'registerExternal',
		value: function registerExternal(key, value) {
			this.loader.registerExternal(key, value);
		}
	}, {
		key: 'registerDependencyLoader',
		value: function registerDependencyLoader(loader) {
			this.loader.setDependencyLoader(loader);
		}
	}, {
		key: 'reload',
		value: function reload(componentName) {
			var _this2 = this;

			return new Promise(function (resolve, reject) {
				var component = _this2.components[componentName];

				if (!component) {
					return reject({
						componentName: componentName,
						message: 'component with name \'' + componentName + '\' was not registered'
					});
				}

				if (typeof component.healthy === 'function' && !component.healthy()) {
					return reject({
						componentName: componentName,
						message: 'component with name \'' + componentName + '\' is currently not available'
					});
				}

				Promise.all([_this2.importComponentVendors(component.vendors, component.anonymousCrossorigin), _this2.importComponentJS(component.js, component.anonymousCrossorigin), _this2.importComponentCSS(component.css)]).then(function (_ref) {
					var _ref2 = slicedToArray(_ref, 2),
					    loadedComponentFactory = _ref2[1];

					if (typeof loadedComponentFactory === 'function') {
						return loadedComponentFactory();
					}

					return loadedComponentFactory;
				}).then(function (loadedComponent) {
					if (component.loadWithComponentLoader) {
						resolve(loadedComponent(_this2));
					}

					resolve(loadedComponent);
				}).catch(function (error) {
					reject({
						componentName: componentName,
						message: 'component with name \'' + componentName + '\' failed to load',
						error: error
					});
				});
			});
		}
	}, {
		key: 'load',
		value: function load(componentName) {
			var _this3 = this;

			if (!(componentName in this.cachedComponents)) {
				this.cachedComponents[componentName] = this.reload(componentName).catch(function (error) {
					delete _this3.cachedComponents[componentName];

					throw error;
				});
			}

			return this.cachedComponents[componentName];
		}
	}, {
		key: 'loadWithParams',
		value: function loadWithParams(componentName) {
			for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				params[_key - 1] = arguments[_key];
			}

			return this.load(componentName).then(this.resolveModule).then(function (component) {
				return component.apply(undefined, params);
			});
		}
	}, {
		key: 'resolveModule',
		value: function resolveModule(module) {
			if (typeof module !== 'function' && module.default) {
				return module.default;
			}

			return module;
		}
	}, {
		key: 'importComponentJS',
		value: function importComponentJS(url, anonymousCrossorigin) {
			var _this4 = this;

			return new Promise(function (resolve, reject) {
				_this4.loader.load(url, anonymousCrossorigin).then(function (component) {
					return resolve(component);
				}).catch(function (error) {
					return reject(error);
				});
			});
		}
	}, {
		key: 'importComponentCSS',
		value: function importComponentCSS(url) {
			return new Promise(function (resolve, reject) {
				// CSS is optional so we don't have to load it if not defined.
				if (!url) {
					return resolve();
				}

				// Check if CSS with the same URL has already been loaded.
				var styleSheets = document.styleSheets;

				for (var i = 0; i < styleSheets.length; i++) {
					var styleSheet = styleSheets[i];

					if (styleSheet.href === url) {
						return resolve();
					}
				}

				// Load the CSS
				var link = document.createElement('link');

				link.type = 'text/css';
				link.rel = 'stylesheet';
				link.href = url;

				link.onload = function () {
					resolve();
				};
				link.onabort = function () {
					reject('loading css url "' + url + '" aborted');
				};
				link.onerror = function () {
					reject('loading css url "' + url + '" error');
				};

				document.getElementsByTagName('head')[0].appendChild(link);
			});
		}
	}, {
		key: 'importComponentVendors',
		value: function importComponentVendors(urls, anonymousCrossorigin) {
			if (!urls) {
				return Promise.resolve();
			}

			var vendorsLoaded = [];

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = urls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var url = _step.value;

					if (url in this.cachedVendors) {
						vendorsLoaded.push(this.cachedVendors[url]);
						continue;
					}

					var _url$split = url.split('?', 2),
					    _url$split2 = slicedToArray(_url$split, 1),
					    path = _url$split2[0];

					var component = void 0;

					if (path.endsWith('.js')) {
						component = this.importComponentJS(url, anonymousCrossorigin);
					} else if (path.endsWith('.css')) {
						component = this.importComponentCSS(url, anonymousCrossorigin);
					}

					if (component) {
						vendorsLoaded.push(component);
						this.cachedVendors[url] = component;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return Promise.all(vendorsLoaded);
		}
	}]);
	return ComponentLoader;
}();

export default ComponentLoader;
//# sourceMappingURL=component-loader.esm.js.map
