"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const queryBuilder_1 = __importDefault(require("./queryBuilder"));
const queryBuilderUtils_1 = require("./queryBuilderUtils");
const getOverallConversionQuery_1 = __importDefault(require("./overallConversion/getOverallConversionQuery"));
const getDurationQuery_1 = __importDefault(require("./duration/getDurationQuery"));
const constants_1 = require("./constants");
const getQueryVariables = ({ shouldQueryList, shouldQueryChartData, }) => {
    let variables = {};
    if (shouldQueryList) {
        variables = Object.assign(Object.assign({}, variables), { $from: 'Int!', $size: 'Int!' });
    }
    if (shouldQueryChartData) {
        variables = Object.assign(Object.assign({}, variables), { $lastPage: 'Int', $chartDataSize: 'Int', $segmentSize: 'Int', $sortOrder: 'SortOrder', $sortBy: 'SortBy' });
    }
    return lodash_1.isEmpty(variables) ? null : variables;
};
const getGroupByWithTimeInterval = ({ interval, filter, timeInterval }) => {
    if (interval && filter) {
        return {
            filter,
            operands: timeInterval,
        };
    }
    return filter;
};
const getArguments = ({ defaultCurrency, isWeightedValue, isMeasureByCustomField, measureByFilter, reportType, }) => {
    let args = {
        timeZone: `"${Intl.DateTimeFormat().resolvedOptions().timeZone}"`,
        sort: '{ by: $sortBy, order: $sortOrder }',
        page: '{ lastPage: $lastPage, size: $chartDataSize, segmentSize: $segmentSize }',
    };
    if (constants_1.REPORTS_REQUIRING_CONVERTTO.includes(reportType)) {
        args = Object.assign(Object.assign({}, args), { convertTo: `"${defaultCurrency}"` });
    }
    if (isWeightedValue) {
        args = Object.assign(Object.assign({}, args), { weighted: true });
    }
    if (isMeasureByCustomField) {
        args = Object.assign(Object.assign({}, args), { field: measureByFilter });
    }
    return args;
};
const addDealStatsFiltersToQuery = ({ queryBuilder, interval, groupByFilter, timeInterval, segmentByFilter, stats, chartType, setGroupByFilter, args, }) => {
    let groupBy = getGroupByWithTimeInterval({
        interval,
        filter: groupByFilter,
        timeInterval,
    });
    const shouldAddSegmentByFilterToQuery = segmentByFilter
        && (segmentByFilter !== groupByFilter || chartType === constants_1.ChartType.PIE)
        && !constants_1.CHART_TYPES_WITHOUT_SEGMENT_BY.includes(chartType);
    const shouldAddGroupByFilterToQuery = !constants_1.CHART_TYPES_WITHOUT_GROUP_BY.includes(chartType);
    if (shouldAddGroupByFilterToQuery) {
        if (!groupBy) {
            if (setGroupByFilter) {
                setGroupByFilter('userId');
            }
            groupBy = 'userId';
        }
        queryBuilder.add(constants_1.QueryFilterField.GROUP_BY).add(groupBy);
    }
    if (shouldAddSegmentByFilterToQuery) {
        queryBuilder.add(constants_1.QueryFilterField.GROUP_BY).add(segmentByFilter);
    }
    queryBuilder.add({
        field: constants_1.ReportType.STATS,
        args,
        fields: {
            data: stats,
            meta: queryBuilderUtils_1.prepareForQueryBuilder(constants_1.METADATA_FIELDS),
        },
    });
};
const addDealProgressToQuery = ({ queryBuilder, groupBy, timeInterval, segmentByFilter, args, }) => {
    // dealStageLogAddTime is handled with input not groupBy and therefore acts differently from rest of the grouping
    // in FE it is shown as regular groupby but not in the API
    const DEAL_STAGE_LOG_DATE = 'dealStageLogAddTime';
    const DATE_STAGE_LOG_DATE_STATS = 'timePeriod';
    const groupByIsDealStageLogDate = groupBy.filter === DEAL_STAGE_LOG_DATE;
    const progressFields = ['stageIdLabel', 'stageId', ...constants_1.STATS_FIELDS];
    let progressArgs = args;
    if (groupBy.filter) {
        if (groupByIsDealStageLogDate) {
            progressFields.push(DATE_STAGE_LOG_DATE_STATS);
            progressArgs = Object.assign({ overTime: timeInterval[0].defaultValue }, args);
        }
        else {
            progressFields.push(groupBy.filter);
        }
    }
    if (segmentByFilter) {
        progressFields.push(segmentByFilter);
    }
    const progressStats = queryBuilderUtils_1.prepareForQueryBuilder(progressFields);
    const groupingsHandledByBE = [DEAL_STAGE_LOG_DATE, constants_1.DEFAULT_PROGRESS_GROUPING_HANDLED_BY_API];
    const progress = {
        field: constants_1.ReportType.PROGRESS,
        args: progressArgs,
        fields: {
            data: progressStats,
            meta: queryBuilderUtils_1.prepareForQueryBuilder(constants_1.METADATA_FIELDS),
        },
    };
    const shouldAddSegment = segmentByFilter && groupBy.filter === constants_1.DEFAULT_PROGRESS_GROUPING_HANDLED_BY_API;
    const shouldAddGroupBy = groupBy.filter && !groupingsHandledByBE.includes(groupBy.filter);
    if (shouldAddSegment) {
        queryBuilder.add(constants_1.QueryFilterField.GROUP_BY).add(segmentByFilter);
    }
    if (shouldAddGroupBy) {
        queryBuilder.add(constants_1.QueryFilterField.GROUP_BY).add(getGroupByWithTimeInterval(groupBy));
    }
    queryBuilder.add(progress);
};
const getFunnelConversionFields = () => {
    const statsFieldsForFunnel = constants_1.STATS_FIELDS.filter(item => item !== 'isOtherSegment');
    const fieldElements = [
        'conversionFrom',
        'sumConversionFrom',
        'stageId',
        'conversionToWon',
        'conversionToLost',
        ...statsFieldsForFunnel,
    ];
    fieldElements.sort();
    return queryBuilderUtils_1.prepareForQueryBuilder(fieldElements);
};
const addFunnelConversionToQuery = (queryBuilder, args, multiSelectFilter) => {
    const funnelConversion = {
        field: constants_1.QueryReportTypeField.FUNNEL_CONVERSION,
        args: Object.assign(Object.assign({}, args), { stages: `[${multiSelectFilter}]` }),
        fields: {
            data: getFunnelConversionFields(),
            meta: queryBuilderUtils_1.prepareForQueryBuilder(constants_1.METADATA_FIELDS),
            summary: queryBuilderUtils_1.prepareForQueryBuilder([constants_1.SUMMARY_TOTAL_FIELD, constants_1.SUMMARY_WIN_RATE_FIELD]),
        },
    };
    queryBuilder.add(funnelConversion);
};
const addOverallConversionToQuery = ({ queryBuilder, groupByFilter, args, chartType, }) => {
    const groupByWithInterval = getGroupByWithTimeInterval(groupByFilter);
    const query = getOverallConversionQuery_1.default(groupByFilter.filter, args, chartType);
    const shouldAddGroupByFilterToQuery = chartType !== constants_1.ChartType.SCORECARD;
    if (shouldAddGroupByFilterToQuery) {
        queryBuilder.add(constants_1.QueryFilterField.GROUP_BY).add(groupByWithInterval);
    }
    queryBuilder.add(query);
};
const addRecurringRevenueToQuery = (queryBuilder, interval, args) => {
    queryBuilder.add({
        field: constants_1.QueryReportTypeField.REVENUE_MOVEMENT,
        args: Object.assign(Object.assign({}, args), { field: constants_1.MeasureByType.PAYMENTS_AMOUNT, groupBy: `"${constants_1.PAYMENTS_DUE_AT_FIELD}"`, segmentBy: '""', interval: interval && typeof interval === 'string' && interval.toUpperCase(), paymentType: 'recurring' }),
        fields: {
            data: queryBuilderUtils_1.prepareForQueryBuilder(['paymentsDueAt', 'sum']),
            meta: queryBuilderUtils_1.prepareForQueryBuilder(constants_1.METADATA_FIELDS),
        },
    });
};
const addRevenueMovementToQuery = (queryBuilder, interval, args) => {
    queryBuilder.add({
        field: constants_1.QueryReportTypeField.REVENUE_MOVEMENT,
        args: Object.assign(Object.assign({}, args), { field: constants_1.MeasureByType.PAYMENTS_CHANGE_AMOUNT, groupBy: `"${constants_1.PAYMENTS_DUE_AT_FIELD}"`, segmentBy: '"paymentsType"', interval: interval && typeof interval === 'string' && interval.toUpperCase(), paymentType: 'recurring' }),
        fields: {
            data: queryBuilderUtils_1.prepareForQueryBuilder(['paymentsDueAt', 'paymentsType', 'sum']),
            meta: queryBuilderUtils_1.prepareForQueryBuilder(constants_1.METADATA_FIELDS),
        },
    });
};
const addCashFlowToQuery = (queryBuilder, interval, args) => {
    queryBuilder.add({
        field: constants_1.QueryReportTypeField.REVENUE_MOVEMENT,
        args: Object.assign(Object.assign({}, args), { field: constants_1.MeasureByType.PAYMENTS_AMOUNT, groupBy: `"${constants_1.PAYMENTS_DUE_AT_FIELD}"`, segmentBy: '""', interval: interval && typeof interval === 'string' && interval.toUpperCase() }),
        fields: {
            data: queryBuilderUtils_1.prepareForQueryBuilder(['paymentsDueAt', 'sum']),
            meta: queryBuilderUtils_1.prepareForQueryBuilder(constants_1.METADATA_FIELDS),
        },
    });
};
const addDurationToQuery = (queryBuilder, groupByFilter, segmentByFilter, args) => {
    const groupByWithInterval = getGroupByWithTimeInterval(groupByFilter);
    const query = getDurationQuery_1.default(args, groupByFilter.filter, segmentByFilter);
    const shouldQuerySegmentBy = segmentByFilter && groupByFilter.filter !== segmentByFilter;
    if (groupByWithInterval) {
        queryBuilder.add(constants_1.QueryFilterField.GROUP_BY).add(groupByWithInterval);
    }
    if (shouldQuerySegmentBy) {
        queryBuilder.add(constants_1.QueryFilterField.GROUP_BY).add(segmentByFilter);
    }
    queryBuilder.add(query);
};
// eslint-disable-next-line complexity
const getInsightsApiQuery = ({ dataType, fields, shouldQueryList, shouldQueryChartData, reportType, chartType, interval, groupByFilter, timeInterval, segmentByFilter, measureByFilter, defaultCurrency, isWeightedValue, isMeasureByCustomField, stats, filterByFilter, setGroupByFilter, multiSelectFilter, }) => {
    const queryBuilder = new queryBuilder_1.default(dataType, getQueryVariables({
        shouldQueryList,
        shouldQueryChartData,
    }));
    filterByFilter.forEach((filter) => {
        queryBuilder.add(constants_1.QueryFilterField.FILTER);
        queryBuilder.add(filter);
    });
    if (shouldQueryList) {
        queryBuilder.add({
            field: constants_1.QueryReportTypeField.LIST,
            args: { from: '$from', size: '$size', timeZone: `"${Intl.DateTimeFormat().resolvedOptions().timeZone}"` },
            fields,
        });
    }
    if (shouldQueryChartData) {
        const args = getArguments({
            defaultCurrency,
            isWeightedValue,
            isMeasureByCustomField,
            measureByFilter,
            reportType,
        });
        const groupBy = {
            interval,
            filter: groupByFilter,
            timeInterval,
        };
        switch (reportType) {
            case constants_1.ReportType.CONVERSION_OVERALL:
                addOverallConversionToQuery({ queryBuilder, groupByFilter: groupBy, args, chartType });
                break;
            case constants_1.ReportType.FUNNEL_CONVERSION:
                addFunnelConversionToQuery(queryBuilder, args, multiSelectFilter);
                break;
            case constants_1.ReportType.PROGRESS:
                addDealProgressToQuery({
                    queryBuilder,
                    groupBy,
                    timeInterval,
                    segmentByFilter,
                    args,
                });
                break;
            case constants_1.ReportType.STATS:
                addDealStatsFiltersToQuery({
                    queryBuilder,
                    interval,
                    groupByFilter,
                    timeInterval,
                    segmentByFilter,
                    stats,
                    chartType,
                    setGroupByFilter,
                    args,
                });
                break;
            case constants_1.ReportType.RECURRING_REVENUE:
                addRecurringRevenueToQuery(queryBuilder, interval, args);
                break;
            case constants_1.ReportType.RECURRING_REVENUE_MOVEMENT:
                addRevenueMovementToQuery(queryBuilder, interval, args);
                break;
            case constants_1.ReportType.CASH_FLOW:
                addCashFlowToQuery(queryBuilder, interval, args);
                break;
            case constants_1.ReportType.DURATION:
                addDurationToQuery(queryBuilder, groupBy, segmentByFilter, args);
                break;
            default:
                break;
        }
    }
    return queryBuilder.build();
};
exports.default = getInsightsApiQuery;
