import React, { useMemo, cloneElement } from 'react';

const STRONG_TEXT_REGEXP = /([*_])\1\1?((?:\[.*?\][([].*?[)\]]|.)*?)\1?\1\1/g;
const EMPHASIZED_TEXT_REGEXP = /([*_])((?:\[.*?\][([].*?[)\]]|.)*?)\1/g;
const REFERENCE_LINK_TEXT_REGEXP = /\[([^\]]*)\] ?\[([^\]]*)\]/g;

function matchAll(regexp, text, onMatch) {
  let match;

  while ((match = regexp.exec(text)) !== null) {
    onMatch(match);
  }
}

function parseSegments(text) {
  const matches = [];
  matchAll(REFERENCE_LINK_TEXT_REGEXP, text, referenceLinkRegExpMatch => {
    const innerText = referenceLinkRegExpMatch[1];
    const reference = referenceLinkRegExpMatch[2];
    const startIndex = referenceLinkRegExpMatch.index;

    if (!innerText || !reference || startIndex == null) {
      return;
    }

    const endIndex = startIndex + referenceLinkRegExpMatch[0].length;
    matches.push({
      type: 'reference-link',
      innerText,
      reference,
      startIndex,
      endIndex,
      offset: 1
    });
  });
  matchAll(STRONG_TEXT_REGEXP, text, strongRegExpMatch => {
    const inlineMatch = getInlineMatchFromRegexpMatch(strongRegExpMatch, 'strong');

    if (inlineMatch) {
      matches.push(inlineMatch);
    }
  });
  matchAll(EMPHASIZED_TEXT_REGEXP, text, emphasisRegExpMatch => {
    const inlineMatch = getInlineMatchFromRegexpMatch(emphasisRegExpMatch, 'emphasis');

    if (inlineMatch) {
      matches.push(inlineMatch);
    }
  });
  matches.sort((a, b) => a.startIndex - b.startIndex);
  return getSegmentsFromMatches(text, matches);
}

function getInlineMatchFromRegexpMatch(regexpMatch, inlineType) {
  const startIndex = regexpMatch.index;
  const innerText = regexpMatch[2];

  if (startIndex == null || !innerText) {
    return;
  }

  const decoratedText = regexpMatch[0];
  const offset = decoratedText.indexOf(innerText);
  const endIndex = startIndex + decoratedText.length;
  return {
    type: inlineType,
    startIndex,
    endIndex,
    innerText,
    offset
  };
}

function getSegmentsFromMatches(text, matches) {
  if (!matches.length) {
    return [text];
  }

  const firstMatchStartIndex = matches[0].startIndex;
  const segments = firstMatchStartIndex > 0 ? [text.slice(0, firstMatchStartIndex)] : [];

  while (matches.length) {
    const currentMatch = matches.shift();
    const currentMatchTextStart = currentMatch.startIndex + currentMatch.offset;
    const innerMatches = [];

    for (let i = 0; i < matches.length;) {
      const otherMatch = matches[i]; // if not an inner match, continue to the next

      if (otherMatch.endIndex > currentMatch.endIndex) {
        i++;
        continue;
      } // remove it from matches


      matches.splice(i, 1);
      otherMatch.startIndex -= currentMatchTextStart;
      otherMatch.endIndex -= currentMatchTextStart;
      innerMatches.push(otherMatch);
    }

    const content = getSegmentsFromMatches(currentMatch.innerText, innerMatches);

    if (currentMatch.type === 'reference-link') {
      segments.push({
        type: currentMatch.type,
        content,
        reference: currentMatch.reference
      });
    } else {
      segments.push({
        type: currentMatch.type,
        content
      });
    }

    const textAfterLastMatch = matches.length ? text.slice(currentMatch.endIndex, matches[0].startIndex) : text.slice(currentMatch.endIndex);

    if (textAfterLastMatch) {
      segments.push(textAfterLastMatch);
    }
  }

  return segments;
}

function Marksome({
  text,
  references,
  ...spanProps
}) {
  const segments = useMemo(() => {
    return parseSegments(text);
  }, [text]);
  return React.createElement("span", Object.assign({}, spanProps), renderSegments(segments, references));
}

function renderSegments(segments, references) {
  return segments.map((segment, segmentIndex) => {
    if (typeof segment === 'string') {
      return segment;
    }

    switch (segment.type) {
      case 'strong':
        return React.createElement("strong", {
          key: segmentIndex
        }, renderSegments(segment.content, references));

      case 'emphasis':
        return React.createElement("em", {
          key: segmentIndex
        }, renderSegments(segment.content, references));

      case 'reference-link':
        {
          const referenceValue = references == null ? void 0 : references[segment.reference];
          const children = renderSegments(segment.content, references);

          if (!referenceValue) {
            if (process.env.NODE_ENV === 'development') {
              // eslint-disable-next-line no-console
              console.warn("Marksome: " + segment.reference + " for reference-link is missing from references prop. Falling back to span.");
            }

            return React.createElement("span", {
              key: segmentIndex
            }, children);
          }

          if (typeof referenceValue === 'string') {
            return React.createElement("a", {
              key: segmentIndex,
              href: referenceValue
            }, children);
          }

          const element = referenceValue(children);
          return cloneElement(element, {
            key: segmentIndex
          });
        }

      default:
        return null;
    }
  });
}

export { Marksome, parseSegments };
//# sourceMappingURL=react-marksome.esm.js.map
