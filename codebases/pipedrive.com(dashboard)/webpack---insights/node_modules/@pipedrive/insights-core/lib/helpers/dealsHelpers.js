"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBackgroundFilterValue = exports.createFilterForSpecialReportTypes = exports.getListFields = exports.getStats = exports.prepareForQueryBuilder = exports.getFieldType = exports.getMeasureByFilterType = exports.isMeasureByNumerical = exports.isMeasureByMonetary = exports.isCustomField = void 0;
const types_1 = require("../types");
const constants_1 = require("../constants");
const commonHelpers_1 = require("./commonHelpers");
const private_1 = require("./private");
exports.isCustomField = (field) => {
    return field.includes('__');
};
exports.isMeasureByMonetary = (measureBy) => {
    if (exports.isCustomField(measureBy)) {
        return measureBy.startsWith('monetary');
    }
    return [
        types_1.Deals.MeasureByType.VALUE,
        types_1.Deals.MeasureByType.AVERAGE_VALUE,
        types_1.Deals.MeasureByType.WEIGHTED_VALUE,
        types_1.Deals.MeasureByType.PAYMENTS_AMOUNT,
        types_1.Deals.MeasureByType.PAYMENTS_CHANGE_AMOUNT,
        types_1.Deals.MeasureByType.PRODUCTS_SUM,
    ].includes(measureBy);
};
exports.isMeasureByNumerical = (measureBy) => {
    return exports.isCustomField(measureBy) && measureBy.startsWith('numerical');
};
exports.getMeasureByFilterType = (measureBy) => {
    if (exports.isMeasureByMonetary(measureBy) || exports.isMeasureByNumerical(measureBy)) {
        return types_1.Deals.MeasureByType.VALUE;
    }
    if (measureBy === types_1.Deals.MeasureByType.PRODUCTS_AMOUNT) {
        return types_1.Deals.MeasureByType.VALUE;
    }
    return types_1.Deals.MeasureByType.COUNT;
};
exports.getFieldType = (filter) => {
    const filterPrefix = filter && filter.split('__')[0];
    return {
        filter,
        type: filterPrefix,
    };
};
const getFieldsWithLabelFields = (queryFields) => {
    const labelFields = [];
    queryFields.forEach((field) => {
        const fieldType = exports.getFieldType(field).type;
        if (constants_1.deals.FIELDS_WITH_LABELS.includes(fieldType)) {
            const labelFieldKey = commonHelpers_1.getLabelFieldKey(field);
            labelFields.push(labelFieldKey);
        }
    });
    return [...queryFields, ...labelFields];
};
exports.prepareForQueryBuilder = (fields) => {
    const fieldsWithAddedLabelFields = getFieldsWithLabelFields(fields);
    return private_1.getFieldsObjectForQueryBuilder(fieldsWithAddedLabelFields);
};
exports.getStats = ({ groupByFilter, measureByFilterType, segmentByFilter, }) => {
    const statsElements = [groupByFilter, measureByFilterType, ...constants_1.deals.STATS_FIELDS];
    if (segmentByFilter) {
        statsElements.push(segmentByFilter);
    }
    return exports.prepareForQueryBuilder(statsElements);
};
exports.getListFields = (reportColumns) => {
    // "currency" has to be there for "value" type of fields
    // "id" has to be there for navigating user to deal detail view
    return exports.prepareForQueryBuilder([...reportColumns, 'currency', 'id']);
};
exports.createFilterForSpecialReportTypes = (reportType, value) => {
    const specialFilter = commonHelpers_1.getBackgroundFilterType(reportType);
    if (!specialFilter || !value) {
        return null;
    }
    const { filter, type, operand } = specialFilter;
    return {
        filter,
        type,
        operands: [
            {
                name: operand,
                defaultValue: value,
                __typename: 'SelectedDataFilterOperand',
            },
        ],
        __typename: 'SelectedDataFilter',
    };
};
exports.getBackgroundFilterValue = ({ reportType, filterByFilter, multiSelectFilter, getPipelineStages, }) => {
    if (reportType === types_1.ReportType.DEALS_FUNNEL_CONVERSION) {
        let addStageToQuery = false;
        const pipelineFilter = filterByFilter.find((filter) => filter.filter === 'pipelineId');
        const pipelineId = pipelineFilter.operands[0].defaultValue;
        const pipelineStages = getPipelineStages(pipelineId);
        // select all stages after the first multiSelect filter stage
        return pipelineStages.reduce((acc, stage) => {
            if (!addStageToQuery && multiSelectFilter.includes(stage.id)) {
                addStageToQuery = true;
            }
            if (addStageToQuery) {
                acc.push(stage.id);
            }
            return acc;
        }, []);
    }
    return null;
};
