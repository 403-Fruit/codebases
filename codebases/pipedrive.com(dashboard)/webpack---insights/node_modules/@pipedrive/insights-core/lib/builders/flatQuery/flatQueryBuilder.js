"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const helpers_1 = require("../../helpers");
const UNSIGNED_INT = 'UnsignedInt';
const POSITIVE_INT = 'PositiveInt';
/**
 * @param  {DataType} type
 * @param  {string[]=[]} enumFields list of enum fields.
    Used to format those values without double quotation marks while
    building the query (other string values are surrounded by double quotation marks).
 */
class FlatQueryBuilder {
    constructor(type, enumFields = []) {
        this.formatEnumTypeOperand = (operandName, value) => {
            if (typeof value === 'string') {
                return `${operandName}: ${value}`;
            }
            return `${operandName}: [${value}]`;
        };
        this.type = type;
        this.enumFields = enumFields;
        this.filters = {};
        this.groupBy = {
            field: null,
            settings: {},
        };
    }
    setShouldQueryList(shouldQueryList = false) {
        this.shouldQueryList = shouldQueryList;
        return this;
    }
    setShouldQueryExportList(shouldQueryExportList = false) {
        this.shouldQueryExportList = shouldQueryExportList;
        return this;
    }
    setShouldQueryChart(shouldQueryChart = false) {
        this.shouldQueryChart = shouldQueryChart;
        return this;
    }
    setFilters(filterInputs) {
        this.filters = this.filtersArrayToObject(filterInputs);
        return this;
    }
    setMeasureBy(measureBy) {
        this.measureBy = measureBy;
        return this;
    }
    setGroupBy(groupBy, interval, format) {
        if (!groupBy) {
            return this;
        }
        this.groupBy.field = groupBy;
        if (interval || format) {
            this.groupBy.settings[groupBy] = { interval, format };
        }
        return this;
    }
    setSegmentBy(segmentBy) {
        if (!segmentBy) {
            return this;
        }
        this.segmentBy = segmentBy;
        return this;
    }
    setTimeZone(timeZone) {
        this.timeZone = timeZone;
        return this;
    }
    getSubqueriesWithoutExtraSpaces(subQueries) {
        return subQueries.filter((query) => query.length).join(' ');
    }
    build(reportType, listFields, reportFields) {
        const filter = this.formatFilters();
        const timeZone = this.formatTimezone();
        const groupBy = this.formatGroupBy();
        const segmentBy = this.formatSegmentBy();
        const measureBy = this.formatMeasureBy();
        const queryArguments = this.formatQueryArguments();
        const reportQuery = this.shouldQueryChart
            ? this.formatReport(reportType, reportFields, [filter, groupBy, segmentBy, measureBy, timeZone])
            : '';
        const listQuery = this.shouldQueryList
            ? this.formatList(listFields, [filter, timeZone])
            : '';
        const exportListQuery = this.shouldQueryExportList
            ? this.formatExportList(listFields, [filter, timeZone])
            : '';
        const subQueries = this.getSubqueriesWithoutExtraSpaces([reportQuery, listQuery, exportListQuery]);
        return `query${queryArguments} { ${this.type} { ${subQueries} } }`;
    }
    filtersArrayToObject(filters) {
        return filters.reduce((result, filter) => {
            result[filter.filter] = this.operandsArrayToObject(filter.operands);
            return result;
        }, {});
    }
    isOperandValuePresent(value) {
        /*
              operand value can also be boolean, so it's
              important to only check null or undefined
        */
        return !lodash_1.isNil(value);
    }
    operandsArrayToObject(operands) {
        return operands.reduce((result, operand) => {
            const doesOperandHaveDefaultValue = this.isOperandValuePresent(operand.defaultValue);
            const operands = doesOperandHaveDefaultValue ? { [operand.name]: operand.defaultValue } : {};
            return Object.assign(Object.assign({}, result), operands);
        }, {});
    }
    formatExportList(listFields, inlineArguments) {
        const args = this.formatArguments([
            'format: $format',
            'fields: $fields',
            ...inlineArguments,
        ]);
        return `exportList${args} { ${this.formatFields(listFields)} }`;
    }
    formatList(listFields, inlineArguments) {
        const inputArguments = this.formatInputsWithOperands({
            pagination: {
                from: '$from',
                size: '$size',
            },
        });
        const args = this.formatArguments([inputArguments, ...inlineArguments]);
        return `list${args} { ${this.formatFields(listFields)} }`;
    }
    formatReport(reportType, reportFields, inlineArguments) {
        const args = this.formatArguments(inlineArguments);
        const fields = this.formatFields(reportFields);
        return `${reportType}${args} { data { ${fields} } meta { hasNextPage totalPages }}`;
    }
    formatTimezone() {
        const timeZone = this.timeZone || helpers_1.getTimezoneName();
        return timeZone ? `timeZone: "${timeZone}"` : '';
    }
    formatFilters() {
        const filter = this.formatInputsWithOperands(this.filters);
        return filter ? `filter: {${filter}}` : '';
    }
    formatGroupBy() {
        if (!this.groupBy.field) {
            return '';
        }
        const inputArguments = this.formatInputsWithOperands({
            pagination: {
                from: '$chartDataFrom',
                size: '$chartDataSize',
            },
            sort: {
                by: '$sortBy',
                order: '$sortOrder',
            },
        });
        const settings = this.formatInputsWithOperands(this.groupBy.settings);
        return `groupBy: { field: ${this.groupBy.field}, settings: {${settings}}, ${inputArguments} }`;
    }
    formatSegmentBy() {
        return this.segmentBy ? `segmentBy: { field: ${this.segmentBy}, size: $segmentSize }` : '';
    }
    formatInputsWithOperands(input) {
        return Object.keys(input)
            .filter(fieldName => !lodash_1.isEmpty(input[fieldName]))
            .map(fieldName => {
            const operands = this.formatOperands(fieldName, input[fieldName]);
            return `${fieldName}: {${operands}}`;
        }).join(', ');
    }
    formatOperands(fieldName, operands) {
        return Object.keys(operands)
            .filter(operandName => this.isOperandValuePresent(operands[operandName]))
            .map(operandName => {
            const value = operands[operandName];
            if (this.enumFields.includes(fieldName) || operandName === 'interval') {
                return this.formatEnumTypeOperand(operandName, value);
            }
            if (typeof value === 'string') {
                const formattedValue = value.startsWith('$') ? value : `"${value}"`;
                return `${operandName}: ${formattedValue}`;
            }
            return `${operandName}: ${JSON.stringify(value)}`;
        }).join(', ');
    }
    formatMeasureBy() {
        return this.measureBy ? `measureBy: ${this.measureBy}` : '';
    }
    formatQueryArguments() {
        const queryArguments = Object.assign(Object.assign(Object.assign(Object.assign({}, (this.shouldQueryList ? { $from: UNSIGNED_INT, $size: POSITIVE_INT } : {})), (this.shouldQueryExportList ? { $format: 'String', $fields: '[String]!' } : {})), (this.groupBy.field && this.shouldQueryChart ? {
            $chartDataFrom: UNSIGNED_INT,
            $chartDataSize: POSITIVE_INT,
            $sortOrder: 'SortOrderValue',
            $sortBy: 'SortByValue',
        } : {})), (this.segmentBy && this.shouldQueryChart ? {
            $segmentSize: POSITIVE_INT,
        } : {}));
        const args = Object.keys(queryArguments).map((name) => {
            return `${name}: ${queryArguments[name]}`;
        });
        return this.formatArguments(args);
    }
    formatArguments(inlineArguments) {
        const args = inlineArguments.filter((argument) => argument).join(', ');
        return args ? `(${args})` : '';
    }
    formatFields(fields) {
        return fields.join(' ');
    }
}
exports.default = FlatQueryBuilder;
