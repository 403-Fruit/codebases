import React, { useState, useEffect } from 'react';
import { getComponent, AddButton, getFormValueIsEmpty, WithEditButton, ActionFooter } from '@pipedrive/form-fields';
import { useTranslator } from '@pipedrive/react-utils';
import { noop } from 'lodash';

import { Currency, Monetary, FormFieldOption, FormValue, PopoverPlacement, Settings } from '../types/types';

import { useInputValue } from './useInputField';
import { FieldLabel } from './FieldLabel';
import * as S from './EditField.styles';

// Casting ID as number
// form-field accept only ID as number and we work with ID as string
// component works fine, but complains about type
type FormFieldOptionCasted = FormFieldOption & { id: number };

export type EditFieldProps = {
	readonly fieldType?:
		| 'varchar'
		| 'set'
		| 'address'
		| 'label'
		| 'time'
		| 'text'
		| 'monetary'
		| 'email'
		| 'date'
		| 'person'
		| 'organization'
		| 'phone'
		| 'default_phone'
		| 'owner'
		| 'int'
		| 'user'
		| 'double'
		| 'varchar_auto'
		| 'visible_to';
	readonly componentFieldType?:
		| 'deal'
		| 'person'
		| 'organization'
		| 'product'
		| 'activity'
		| 'user'
		| 'filter'
		| 'mail_list'
		| 'note';
	readonly options?: FormFieldOption[];
	readonly fieldKey: string;
	readonly placeholder: string;
	readonly initValue: FormValue;
	readonly onUpdate: (fieldValue: { [key: string]: FormValue }) => Promise<boolean>;
	readonly isActive: boolean;
	readonly single?: boolean;
	readonly isLinked?: boolean;
	readonly setActive: (isActive: boolean) => void;
	readonly currencies: Currency[];
	readonly onCancelClick?: () => void;
	readonly onSaveClick?: () => void;
	readonly ccEmail?: string;
	/** Where the Popover is placed relative to the trigger. Note: initial position will always use cursor position to calculate Popover placement. */
	readonly placement?: PopoverPlacement;
	readonly settings?: Settings;
};

const FieldKeysWithoutLink = {
	TITLE: 'title',
};

export const EditField: React.FC<EditFieldProps> = (props) => {
	const {
		placeholder,
		fieldType = 'varchar',
		componentFieldType = 'deal',
		fieldKey,
		onUpdate,
		initValue = undefined,
		setActive,
		isActive,
		single,
		onCancelClick,
		onSaveClick,
		options = [],
		placement,
		settings,
		ccEmail,
	} = props;

	const translator = useTranslator();
	const [isEditMode, setEditMode] = useState(false);
	const [isSaving, setSaving] = useState(false);
	const [hasValidationError, setHasValidationError] = useState(false);
	const [{ value, defaultValue, error }, dispatch] = useInputValue(initValue, fieldType);

	const onInputChange = (inputValue: FormValue) => {
		dispatch({ type: 'value', value: inputValue });
	};

	const formatUpdatedValue = (inputValue: FormValue): FormValue => {
		if (fieldType === 'monetary') {
			const casted = inputValue as Monetary;

			if (!casted || casted.value === '') {
				return null;
			} else {
				return inputValue;
			}
		}

		return inputValue;
	};

	const onSave = async () => {
		setSaving(true);

		// we should refactor this once we are full GraphQL (mutations don't and should not return promises)
		const updatedSuccessfully = await onUpdate({ [fieldKey]: formatUpdatedValue(value) });

		if (updatedSuccessfully) {
			setActive(false);
			toggleEdit();
		} else {
			dispatch({ type: 'error', error: translator.gettext('Saving changes failed.') });
		}

		setSaving(false);
		onSaveClick?.();
	};

	const onInputValidation = (isValid: boolean) => {
		setHasValidationError(!isValid);
	};

	const onCancel = () => {
		dispatch({ type: 'error', error: undefined });
		toggleEdit();
		onCancelClick?.();
	};

	const { Component, ComponentRead } = getComponent(fieldType, fieldKey);

	const toggleEdit = () => setEditMode(!isEditMode);
	const hasContent = !getFormValueIsEmpty(initValue);

	useEffect(() => setActive(isEditMode), [isEditMode, setActive]);
	useEffect(() => setEditMode(isActive), [isActive]);
	useEffect(() => {
		const pressEnterKeyEventHandler = async (e: KeyboardEvent) => {
			if (isEditMode && e.keyCode === 13) {
				await onSave();
			}
		};
		window.addEventListener('keydown', pressEnterKeyEventHandler);
		return () => window.removeEventListener('keydown', pressEnterKeyEventHandler);
	}, [isEditMode, value]);

	if (isEditMode) {
		return (
			<div className="editMode">
				<Component
					onComponentChange={onInputChange}
					fieldType={componentFieldType}
					fieldKey={fieldKey}
					value={value}
					error={error}
					placeholder={placeholder}
					single={single}
					options={options as FormFieldOptionCasted[]}
					autofocus
					placement={placement}
					portalTo={document.body}
					onValidation={onInputValidation}
					ccEmail={ccEmail}
				/>
				<ActionFooter
					onCancel={onCancel}
					onSave={onSave}
					isLoading={isSaving}
					saveDisabled={hasValidationError}
				/>
			</div>
		);
	} else {
		if (hasContent) {
			const isFieldLabelVisible =
				placeholder !== '' &&
				!(componentFieldType === 'deal' && fieldKey === 'title') && // don't display label next to the lead title
				!(componentFieldType === 'deal' && fieldKey === 'dealValue'); // don't display label next to the lead value

			return (
				<WithEditButton onClick={toggleEdit}>
					<S.ComponentReadWrapper isMultipleOptions={fieldType === 'set'}>
						<ComponentRead
							onComponentChange={noop}
							options={options as FormFieldOptionCasted[]}
							value={defaultValue}
							linkify={!Object.values(FieldKeysWithoutLink).includes(fieldKey)}
							settings={settings}
							ccEmail={ccEmail}
						/>
						{isFieldLabelVisible && <FieldLabel label={placeholder} />}
					</S.ComponentReadWrapper>
				</WithEditButton>
			);
		} else {
			return <AddButton onClick={toggleEdit} placeholder={placeholder} />;
		}
	}
};
