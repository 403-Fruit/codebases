"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dd = '[0-1]{1}[0-9]{1}';
const td = '[0-2]{1}[0-9]{1}';
const dateRegex = new RegExp(`^([1-2]{1}[0-9]{3})-(${dd})-(${dd})[ T]{1}(${td}):(${td}):(${td})$`);
function nanToZero(num) {
    return isNaN(num) ? 0 : num;
}
function dateToTime(date) {
    return {
        sec: nanToZero(date.getUTCSeconds()),
        min: nanToZero(date.getUTCMinutes()),
        hour: nanToZero(date.getUTCHours()),
        day: nanToZero(date.getUTCDate()),
        // make month and day consistent (no 0 value)
        month: nanToZero(date.getUTCMonth() + 1),
        year: nanToZero(date.getUTCFullYear()),
    };
}
function genericTimeToDate(time) {
    let date;
    if (time instanceof Date) {
        date = time;
    }
    else if (typeof time === 'number') {
        // attempt to handle both second and millisecond timestamps using year 3000 as a cutoff
        const year3000 = 32503680000;
        const multiplier = time > year3000 ? 1 : 1000;
        date = new Date(time * multiplier);
    }
    else if (typeof time === 'string') {
        const match = dateRegex.exec(time);
        if (match) {
            // if no timezone was supplied then we can assume it is UTC
            time = `${time}+00:00`;
        }
        date = new Date(time);
    }
    else {
        // if we can't figure out what to do with this, just default to now
        date = new Date();
    }
    return date;
}
function getTimeDiffFromDate(a, b) {
    const timeA = a.getTime();
    const timeB = b.getTime();
    const time = dateToTime(new Date(timeA > timeB ? timeA - timeB : timeB - timeA));
    // Remove 1970/1/1 from the difference
    return {
        ...time,
        year: time.year - 1970,
        month: time.month - 1,
        day: time.day - 1,
    };
}
function getTimeDiff(anchor, compare) {
    // in largest timeframe to smallest order
    const keys = ['year', 'month', 'day', 'hour', 'min', 'sec'];
    const timeDiff = getTimeDiffFromDate(anchor, compare);
    const unit = keys.find((key) => timeDiff[key] > 0) || 'sec';
    const amount = timeDiff[unit];
    const direction = anchor < compare ? 'future' : 'past';
    return {
        unit,
        amount,
        direction,
    };
}
async function default_1(language, getTranslator) {
    const t = await getTranslator({
        language,
        serviceName: 'time-strings',
    });
    // eslint-disable-next-line complexity
    const humanize = (anchor, compare) => {
        const diff = getTimeDiff(anchor, compare);
        if (diff.unit === 'sec') {
            return diff.direction === 'past'
                ? t.ngettext('%d second ago', '%d seconds ago', diff.amount, diff.amount)
                : t.ngettext('in %d second', 'in %d seconds', diff.amount, diff.amount);
        }
        else if (diff.unit === 'min') {
            return diff.direction === 'past'
                ? t.ngettext('%d minute ago', '%d minutes ago', diff.amount, diff.amount)
                : t.ngettext('in %d minute', 'in %d minutes', diff.amount, diff.amount);
        }
        else if (diff.unit === 'hour') {
            return diff.direction === 'past'
                ? t.ngettext('%d hour ago', '%d hours ago', diff.amount, diff.amount)
                : t.ngettext('in %d hour', 'in %d hours', diff.amount, diff.amount);
        }
        else if (diff.unit === 'day') {
            return diff.direction === 'past'
                ? t.ngettext('%d day ago', '%d days ago', diff.amount, diff.amount)
                : t.ngettext('in %d day', 'in %d days', diff.amount, diff.amount);
        }
        else if (diff.unit === 'month') {
            return diff.direction === 'past'
                ? t.ngettext('%d month ago', '%d months ago', diff.amount, diff.amount)
                : t.ngettext('in %d month', 'in %d months', diff.amount, diff.amount);
        }
        else if (diff.unit === 'year') {
            return diff.direction === 'past'
                ? t.ngettext('%d year ago', '%d years ago', diff.amount, diff.amount)
                : t.ngettext('in %d year', 'in %d years', diff.amount, diff.amount);
        }
        return t.gettext('unknown time ago');
    };
    return {
        relativeTime(anchor, compare) {
            return humanize(genericTimeToDate(anchor), genericTimeToDate(compare));
        },
        fromNow(compare) {
            return humanize(genericTimeToDate(new Date()), genericTimeToDate(compare));
        },
    };
}
exports.default = default_1;
