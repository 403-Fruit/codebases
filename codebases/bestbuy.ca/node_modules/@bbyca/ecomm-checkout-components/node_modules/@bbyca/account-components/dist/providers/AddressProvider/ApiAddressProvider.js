var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as url from "url";
import { HttpRequestError, StatusCode, } from "../../errors";
import { UnsupportedOperationError } from "../../errors/UnsupportedOperationError";
import { ApiBaseProvider } from "../BaseProvider/ApiBaseProvider";
import fetch from "../fetch";
export class ApiAddressProvider extends ApiBaseProvider {
    constructor(accountApiUrl, accountApiVersion = null) {
        super(accountApiUrl, accountApiVersion);
        this.accountApiVersion = accountApiVersion;
    }
    addAddress(props) {
        const _super = Object.create(null, {
            handleError: { get: () => super.handleError }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (props.address.addressType !== "SHIPPING") {
                throw new UnsupportedOperationError(`Unsupported AddressType: Addresses must be of AddressType.SHIPPING`);
            }
            const addAddressUrl = url.parse(`${this.apiUrl}/customers/${props.customerId}/addresses`);
            const formattedUrl = url.format(addAddressUrl);
            const response = yield fetch(formattedUrl, {
                body: JSON.stringify(props.address),
                credentials: "include",
                headers: {
                    "Accept": "application/json",
                    "Authorization": `bearer ${props.accessToken}`,
                    "Content-Type": "application/vnd.bestbuy+json",
                },
                method: "POST",
            });
            if (response.status !== StatusCode.OK) {
                return _super.handleError.call(this, response.status, formattedUrl);
            }
        });
    }
    editAddress(props) {
        const _super = Object.create(null, {
            handleError: { get: () => super.handleError }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (props.address.addressType !== "SHIPPING") {
                throw new UnsupportedOperationError(`Unsupported AddressType: Addresses must be of AddressType.SHIPPING`);
            }
            const addAddressUrl = url.parse(`${this.apiUrl}/customers/${props.customerId}/addresses/${props.id}`);
            const formattedUrl = url.format(addAddressUrl);
            const response = yield fetch(formattedUrl, {
                body: JSON.stringify(props.address),
                credentials: "include",
                headers: {
                    "Accept": "application/json",
                    "Authorization": `bearer ${props.accessToken}`,
                    "Content-Type": "application/vnd.bestbuy+json",
                },
                method: "put",
            });
            if (response.status !== StatusCode.OK) {
                return _super.handleError.call(this, response.status, formattedUrl);
            }
        });
    }
    getAddresses(props) {
        const _super = Object.create(null, {
            handleError: { get: () => super.handleError }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const getAddressesUrl = url.parse(`${this.apiUrl}/customers/${props.customerId}/addresses`);
            if (props.distinct) {
                getAddressesUrl.search = "?distinct=true";
            }
            const formattedUrl = url.format(getAddressesUrl);
            const response = yield fetch(formattedUrl, {
                credentials: "include",
                headers: {
                    Accept: "application/json",
                    Authorization: `bearer ${props.accessToken}`,
                },
                method: "get",
            });
            let json;
            try {
                json = yield response.json();
            }
            catch (error) {
                return Promise.reject(new HttpRequestError(formattedUrl, error.message, error));
            }
            if (response.status !== StatusCode.OK) {
                return _super.handleError.call(this, response.status, formattedUrl, json.error);
            }
            const addresses = json.addresses;
            const defaultAddressId = json.defaultAddressId;
            if (defaultAddressId && defaultAddressId !== "") {
                addresses.forEach((address) => address.isDefaultAddress = address.id === defaultAddressId);
            }
            return addresses;
        });
    }
    getAddressTemplates(props) {
        const _super = Object.create(null, {
            handleError: { get: () => super.handleError }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.apiVersion == null || this.apiVersion < 2) {
                throw new UnsupportedOperationError(`Unsupported action for API Version: ${this.apiVersion}`);
            }
            const getAddressTemplateUrl = url.parse(`${this.apiUrl}/customers/${props.customerId}/template-addresses`);
            const formattedUrl = url.format(getAddressTemplateUrl);
            const response = yield fetch(formattedUrl, {
                credentials: "include",
                headers: {
                    Accept: "application/json",
                    Authorization: `bearer ${props.accessToken}`,
                },
                method: "get",
            });
            let json;
            try {
                json = yield response.json();
            }
            catch (error) {
                return Promise.reject(new HttpRequestError(formattedUrl, error.message, error));
            }
            if (response.status !== StatusCode.OK) {
                return _super.handleError.call(this, response.status, formattedUrl, json.error);
            }
            const addresses = json.addresses;
            const defaultAddressId = json.defaultAddressId;
            if (defaultAddressId && defaultAddressId !== "") {
                addresses.forEach((address) => address.isDefaultAddress = address.id === defaultAddressId);
            }
            return json.addresses;
        });
    }
    removeAddress(props) {
        const _super = Object.create(null, {
            handleError: { get: () => super.handleError }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.apiVersion == null || this.apiVersion < 2) {
                throw new UnsupportedOperationError(`Unsupported action for API Version: ${this.apiVersion}`);
            }
            const deleteAddressUrl = url.parse(`${this.apiUrl}/customers/${props.customerId}/addresses/${props.id}`);
            const formattedUrl = url.format(deleteAddressUrl);
            const response = yield fetch(formattedUrl, {
                credentials: "include",
                headers: {
                    Accept: "application/json",
                    Authorization: `bearer ${props.accessToken}`,
                },
                method: "delete",
            });
            if (response.status !== StatusCode.OK) {
                // TODO: if status === validation failed return that error else following
                return _super.handleError.call(this, response.status, formattedUrl);
            }
        });
    }
}
export default ApiAddressProvider;
//# sourceMappingURL=ApiAddressProvider.js.map