"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getNaptimeResourceMetadata = _interopRequireDefault(require("./getNaptimeResourceMetadata"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// Iterate through query doc and finds all occurencies of @naptime directive.
// If it found, add it's path to the result.
// Returns the array of found nodes with their path, resource, version and action.
// Result is sorted with deepest elements first.
// It is needed to know which nodes will be needed to be transformed when we receive
// response.
var findPatchedNodes = function findPatchedNodes(node) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var patchedNodes = [];
  var currentPath = node.kind === 'Field' ? [].concat(_toConsumableArray(path), [node.name.value]) : path;

  if (node.selectionSet) {
    patchedNodes = node.selectionSet.selections.reduce(function (r, n) {
      return r.concat(findPatchedNodes(n, currentPath));
    }, []);
  }

  var _getNaptimeResourceMe = (0, _getNaptimeResourceMetadata.default)(node),
      resource = _getNaptimeResourceMe.resource,
      version = _getNaptimeResourceMe.version,
      action = _getNaptimeResourceMe.action;

  if (resource) {
    patchedNodes.unshift({
      path: currentPath,
      resource: resource,
      version: version,
      action: action
    });
  }

  return patchedNodes;
};

var _default = findPatchedNodes;
exports.default = _default;