"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _upperFirst = _interopRequireDefault(require("lodash/upperFirst"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// apollo-cache-inmemory gets mad if it does not see __typename for objects in result, so
// we just provide it empty __typename
// TODO(igor): obey @type(name: "ResourceName") directive
var injectEmptyTypename = function injectEmptyTypename(object) {
  if (Array.isArray(object)) {
    return object.map(function (element) {
      return injectEmptyTypename(element);
    });
  } else if (object !== null && _typeof(object) === 'object') {
    return Object.keys(object).reduce(function (result, key) {
      return _objectSpread({}, result, _defineProperty({}, key, injectEmptyTypename(object[key])));
    }, {
      __typename: null
    });
  }

  return object;
}; // Transform response:
// * Surround result with method name (get, multiGet, or other finder).
// * Inject __typename: NaptimeResourceNameV1Resource, NaptimeResourceNameV1Connection,
//   NaptimeResourceNameV1. Resource typenames have Naptime prefix to avoid conflicts with
//   Assembler types.
// * Inject __typename to linked resources.
// * Inject empty __typename's for nested objects.


var responseTransformer = function responseTransformer(response, resource, version, action) {
  if (response) {
    var _ref;

    var resourceName = "".concat(_constants.TYPENAME_PREFIX).concat((0, _upperFirst.default)(resource), "V").concat(version);
    var elements = (response.elements || []).map(function (element) {
      return _objectSpread({}, element, {
        __typename: resourceName
      });
    });
    var linked = Object.keys(response.linked || {}).reduce(function (acc, key) {
      return _objectSpread({}, acc, _defineProperty({}, key, response.linked[key].map(function (e) {
        return _objectSpread({}, e, {
          __typename: "".concat(_constants.TYPENAME_PREFIX).concat((0, _upperFirst.default)(key))
        });
      })));
    }, {});
    return _ref = {}, _defineProperty(_ref, action, injectEmptyTypename(_objectSpread({}, response, {
      elements: elements
    }, Object.keys(linked).length > 0 && {
      linked: linked
    }, {
      __typename: "".concat(resourceName, "Connection")
    }))), _defineProperty(_ref, "__typename", "".concat(resourceName, "Resource")), _ref;
  }

  return response;
}; // Find @naptime nodes on result and apply responseTransformer for them.


var patchNode = function patchNode(node, path, resource, version, action) {
  if (path.length === 1) {
    if (node[path[0]]) {
      // eslint-disable-next-line no-param-reassign
      node[path[0]] = responseTransformer(node[path[0]], resource, version, action);
    }
  } else {
    var _path = _toArray(path),
        pathItem = _path[0],
        restPath = _path.slice(1);

    if (node[pathItem]) {
      if (Array.isArray(node[pathItem])) {
        Object.keys(node[pathItem]).forEach(function (key) {
          return patchNode(node[pathItem][key], restPath, resource, version, action);
        });
      } else {
        patchNode(node[pathItem], restPath, resource, version, action);
      }
    }
  }
};

var transformRestToNaptimeResponse = function transformRestToNaptimeResponse(patchedNodes) {
  return function (originalData) {
    var data = (0, _cloneDeep.default)(originalData);
    patchedNodes.forEach(function (_ref2) {
      var path = _ref2.path,
          resource = _ref2.resource,
          version = _ref2.version,
          action = _ref2.action;
      patchNode(data.data, path, resource, version, action);
    });
    return data;
  };
};

var _default = transformRestToNaptimeResponse;
exports.default = _default;