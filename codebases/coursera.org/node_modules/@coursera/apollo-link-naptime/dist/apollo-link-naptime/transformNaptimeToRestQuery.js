"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.patchNaptimeDirective = void 0;

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _getNaptimeResourceMetadata = _interopRequireDefault(require("./getNaptimeResourceMetadata"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// Generate @rest directive
var restDirective = function restDirective(resourceTypename, path, action, isMutation) {
  var result = {
    kind: 'Directive',
    name: {
      kind: 'Name',
      value: 'rest'
    },
    arguments: [{
      kind: 'Argument',
      name: {
        kind: 'Name',
        value: 'type'
      },
      value: {
        kind: 'StringValue',
        value: "".concat(resourceTypename, "Resource"),
        block: false
      }
    }, {
      kind: 'Argument',
      name: {
        kind: 'Name',
        value: 'path'
      },
      value: {
        kind: 'StringValue',
        value: path,
        block: false
      }
    }]
  };

  if (action && _constants.MUTATIONS[action] || isMutation) {
    result.arguments.push({
      kind: 'Argument',
      name: {
        kind: 'Name',
        value: 'method'
      },
      value: {
        block: false,
        kind: 'StringValue',
        value: _constants.MUTATIONS[action] || 'POST'
      }
    });
  }

  return result;
};

var filterFields = function filterFields(node) {
  return node.name.value !== '__typename' && !(node.directives && node.directives.find(function (d) {
    return d.name.value === 'naptime';
  }));
}; // Collect fields from query to include them in `fields` param for Naptime API call.


var findFields = function findFields(actionNode) {
  var fields = [];

  if (actionNode.selectionSet) {
    var selections = actionNode.selectionSet.selections;
    var elementsNode = selections.find(function (s) {
      return s.name.value === 'elements';
    });

    if (elementsNode) {
      fields.push.apply(fields, _toConsumableArray(elementsNode.selectionSet.selections.filter(filterFields).map(function (s) {
        return s.name.value;
      })));
    }

    var linkedNode = selections.find(function (s) {
      return s.name.value === 'linked';
    });

    if (linkedNode) {
      var linkedResources = linkedNode.selectionSet.selections.filter(filterFields);

      if (linkedResources) {
        var linkedFields = linkedResources.map(function (resourceNode) {
          var resourceName = resourceNode.name.value.replace(/V(\d+)/, '.v$1');
          var resourceFields = resourceNode.selectionSet.selections.filter(filterFields).map(function (s) {
            return s.name.value;
          });
          return "".concat(resourceName, "(").concat(resourceFields.join(','), ")");
        });
        fields.push.apply(fields, _toConsumableArray(linkedFields));
      }
    }
  }

  return fields;
};
/**
 * This function first converts all the action node arguments to rest link args and filter the input arg
 * it is used for the custom action mutation case because we do not want to include input in the url parameter 
 * @param actionNode actionNode from getNaptimeResourceMetadata
 * @returns returns an array of arguments in the rest link args format, for exmaple "id={args.id}", without the "input" argument
 */


var convertActionNodeToRestArgsWithoutInput = function convertActionNodeToRestArgsWithoutInput(actionNode) {
  var argumentsStrings = actionNode.arguments.map(function (argument) {
    return argument.name.value;
  });
  var argumentsStringsWithoutInput = argumentsStrings.filter(function (arg) {
    return arg !== 'input';
  });
  return argumentsStringsWithoutInput.map(function (arg) {
    return "".concat(arg, "={args.").concat(arg, "}");
  });
}; // Recursively find nodes with @naptime directive and replace it with corresponding @rest
// directive.


var patchNaptimeDirective = function patchNaptimeDirective(originalNode, operationType) {
  var node = originalNode;

  var _getNaptimeResourceMe = (0, _getNaptimeResourceMetadata.default)(node),
      actionNode = _getNaptimeResourceMe.actionNode,
      resourceTypename = _getNaptimeResourceMe.resourceTypename,
      resource = _getNaptimeResourceMe.resource,
      version = _getNaptimeResourceMe.version,
      action = _getNaptimeResourceMe.action;

  if (resource) {
    node = (0, _cloneDeep.default)(originalNode);
    var isMutation = operationType === 'mutation'; // Generate path for @rest directive. It includes list of fields from query.

    var path = "".concat(resource, ".v").concat(version);
    var params = [];

    if (!_constants.MUTATIONS[action] && !isMutation) {
      params.push('{args}');
    }

    if (action !== 'create' && action !== 'multiGet') {
      if (_constants.SINGLE_ELEMENT_ACTIONS[action]) {
        path += '/{args.id}';
      } else if (isMutation) {
        params.push("action=".concat(action));
        convertActionNodeToRestArgsWithoutInput(actionNode).forEach(function (arg) {
          return params.push(arg);
        });
      } else {
        params.push("q=".concat(action));
      }
    }

    var fields = findFields(actionNode);

    if (fields.length > 0) {
      params.push("fields=".concat(fields.join(',')));
    }

    path += "?".concat(params.join('&')); // Update original query. Move arguments and add @rest directive to node

    node.arguments = actionNode.arguments;
    node.directives[node.directives.findIndex(function (d) {
      return d.name.value === 'naptime';
    })] = restDirective(resourceTypename, path, action, isMutation);
    node.selectionSet = actionNode.selectionSet;
  }

  if (node.selectionSet) {
    return _objectSpread({}, node, {
      selectionSet: _objectSpread({}, node.selectionSet, {
        selections: node.selectionSet.selections.map(function (selection) {
          return patchNaptimeDirective(selection, node.kind === 'OperationDefinition' ? node.operation : operationType);
        })
      })
    });
  }

  return node;
};

exports.patchNaptimeDirective = patchNaptimeDirective;

var transformNaptimeToRestQuery = function transformNaptimeToRestQuery(query) {
  return _objectSpread({}, query, {
    definitions: query.definitions.map(function (definition) {
      return patchNaptimeDirective(definition);
    })
  });
};

var _default = transformNaptimeToRestQuery;
exports.default = _default;