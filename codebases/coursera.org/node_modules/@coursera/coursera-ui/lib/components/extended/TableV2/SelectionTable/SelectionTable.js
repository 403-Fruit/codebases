function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// $FlowFixMe -- disabled flow since the version we use is unable to correctly parse SelectionTableTypes. Re-enable after upgrading to latest flow
import * as React from 'react';
import _ from 'underscore';
import Checkbox from "../../../basic/Checkbox";
import Table from "../Table/Table";
import TableUtil from "../Table/TableUtil";
import SortableTable from "../SortableTable/SortableTable";
import SelectionUtil from "./SelectionUtil";
var CHECKBOX_COLUMN_WIDTH = 48;

var SelectionTable =
/*#__PURE__*/
function (_React$Component) {
  _inherits(SelectionTable, _React$Component);

  function SelectionTable(props) {
    var _this;

    _classCallCheck(this, SelectionTable);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SelectionTable).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "_sortableTable", void 0);

    _defineProperty(_assertThisInitialized(_this), "state", void 0);

    _this.state = {
      expandedRows: props.expandedRows || {}
    };
    return _this;
  }

  _createClass(SelectionTable, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (!_.isEqual(nextProps.expandedRows, this.props.expandedRows)) {
        this.setState({
          expandedRows: nextProps.expandedRows
        });
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      return this._sortableTable && this._sortableTable.getTable();
    }
  }, {
    key: "generateGroupTitleRow",
    value: function generateGroupTitleRow(group, $groupIndex) {
      var _this$props = this.props,
          columns = _this$props.columns,
          groupTitleRenderer = _this$props.groupTitleRenderer;
      var title = group.title,
          key = group.key;
      return _defineProperty({
        key: "group-".concat(key !== undefined ? key : $groupIndex),
        $groupIndex: $groupIndex,
        $isGroupTitle: true
      }, columns[0].accessor, {
        colSpan: columns.length,
        cellContent: groupTitleRenderer ? groupTitleRenderer(title, $groupIndex) : title
      });
    }
  }, {
    key: "generateGroupBodyRows",
    value: function generateGroupBodyRows(rows, $groupIndex) {
      return rows.map(function (row, $rowIndex) {
        return _objectSpread({}, row, {
          $groupIndex: $groupIndex,
          $rowIndex: $rowIndex
        });
      });
    }
  }, {
    key: "generateRowsFromGroup",
    value: function generateRowsFromGroup(group, groupIndex) {
      var title = group.title,
          rows = group.rows;
      var titleRow = this.generateGroupTitleRow(group, groupIndex);
      var groupRows = this.generateGroupBodyRows(rows, groupIndex);
      return [titleRow].concat(groupRows);
    }
  }, {
    key: "generateRowsFromGroups",
    value: function generateRowsFromGroups(groups) {
      var _this2 = this;

      return groups.reduce(function (rows, group, groupIndex) {
        return rows.concat(_this2.generateRowsFromGroup(group, groupIndex));
      }, []);
    }
  }, {
    key: "generateRows",
    value: function generateRows() {
      var _this$props2 = this.props,
          rows = _this$props2.rows,
          groups = _this$props2.groups;

      if (rows) {
        var generatedRows = rows.map(function (row, $rowIndex) {
          return _objectSpread({}, row, {
            $rowIndex: $rowIndex
          });
        });
        return generatedRows;
      } else if (groups) {
        return this.generateRowsFromGroups(groups);
      } else {
        throw new Error('Neither groups nor rows specified');
      }
    }
  }, {
    key: "rowInfo",
    value: function rowInfo(row, callback) {
      var _this$props3 = this.props,
          rows = _this$props3.rows,
          groups = _this$props3.groups;

      var _ref2 = row || {},
          $groupIndex = _ref2.$groupIndex,
          $rowIndex = _ref2.$rowIndex,
          $isGroupTitle = _ref2.$isGroupTitle;

      if (rows && typeof $rowIndex === 'number') {
        return callback(rows[$rowIndex], $rowIndex);
      } else if (groups && typeof $groupIndex === 'number' && typeof $rowIndex === 'number') {
        return callback(groups[$groupIndex].rows[$rowIndex], $groupIndex, $rowIndex);
      } else if (groups && typeof $groupIndex === 'number' && $isGroupTitle) {
        // When a row is a group Title, the row is not defined
        // and we neither have a rowIndex for it.
        return callback(groups[$groupIndex], $groupIndex, undefined, $isGroupTitle);
      }
    }
  }, {
    key: "getRowAttributeCallback",
    value: function getRowAttributeCallback(rowAttribute) {
      var _this3 = this;

      return function (row) {
        return _this3.rowInfo(row, rowAttribute);
      };
    }
  }, {
    key: "getRowEventCallback",
    value: function getRowEventCallback(callback) {
      var _this4 = this;

      return function (event, row) {
        return _this4.rowInfo(row, function (row, index, secondary) {
          return callback(event, row, index, secondary);
        });
      };
    }
  }, {
    key: "generateCheckboxColumn",
    value: function generateCheckboxColumn() {
      var _this5 = this;

      return {
        accessor: 'selected',
        width: CHECKBOX_COLUMN_WIDTH,
        header: function header(visible) {
          return _this5.renderHeaderSelectAllCheckbox(visible);
        },
        cellRenderer: function cellRenderer(_, row, rowIndex) {
          return _this5.renderRowCheckbox(row, rowIndex);
        }
      };
    }
  }, {
    key: "processColumnCellRenderers",
    value: function processColumnCellRenderers(columns) {
      var _this6 = this;

      return columns.map(function (column) {
        var _cellRenderer = column.cellRenderer;
        var obj = _cellRenderer && {
          cellRenderer: function cellRenderer(data, row) {
            return _this6.rowInfo(row, function (row, index, secondaryIndex) {
              return _cellRenderer(data, row, index, secondaryIndex);
            });
          }
        };
        return _objectSpread({}, column, obj);
      });
    }
  }, {
    key: "generateColumns",
    value: function generateColumns() {
      var _this$props4 = this.props,
          columns = _this$props4.columns,
          enableSelection = _this$props4.enableSelection;
      var processedColumns = this.processColumnCellRenderers(columns);
      return enableSelection ? [this.generateCheckboxColumn()].concat(processedColumns) : processedColumns;
    }
  }, {
    key: "renderHeaderSelectAllCheckbox",
    value: function renderHeaderSelectAllCheckbox(visible) {
      var _this$props5 = this.props,
          rows = _this$props5.rows,
          groups = _this$props5.groups,
          onSelect = _this$props5.onSelect,
          onDeselect = _this$props5.onDeselect,
          enableHeaderSelectAll = _this$props5.enableHeaderSelectAll;

      if (enableHeaderSelectAll) {
        var props = {
          rows: rows,
          groups: groups,
          onSelect: onSelect,
          onDeselect: onDeselect
        };
        var otherProps = !visible ? {
          tabIndex: -1
        } : undefined;
        /* Hide from tabIndex for the invisible header */

        return SelectionUtil.renderHeaderSelectAllCheckbox(props, otherProps);
      }
    }
  }, {
    key: "renderGroupSelectAllCheckbox",
    value: function renderGroupSelectAllCheckbox(groupIndex) {
      var _this$props6 = this.props,
          groups = _this$props6.groups,
          onSelect = _this$props6.onSelect,
          onDeselect = _this$props6.onDeselect,
          enableGroupSelectAll = _this$props6.enableGroupSelectAll;

      if (enableGroupSelectAll) {
        var props = {
          groups: groups,
          onSelect: onSelect,
          onDeselect: onDeselect
        };
        return SelectionUtil.renderGroupSelectAllCheckbox(props, groupIndex);
      } else {
        return React.createElement("span", null); // Placeholder for the first column because we don't allow undefined for a cell
      }
    }
  }, {
    key: "renderRowCheckbox",
    value: function renderRowCheckbox(row, rowIndex) {
      var _this7 = this;

      if (row.$isGroupTitle && typeof row.$groupIndex === 'number') {
        return this.renderGroupSelectAllCheckbox(row.$groupIndex);
      } else {
        var _this$props7 = this.props,
            onSelect = _this$props7.onSelect,
            onDeselect = _this$props7.onDeselect;
        return SelectionUtil.renderCheckbox(!!row.selected, !!row.disabled, false, function (event) {
          var checked = event.target.checked;

          _this7.rowInfo(row, function (row, index, secondaryIndex) {
            SelectionUtil.triggerSelectionChangeCallback({
              onSelect: onSelect,
              onDeselect: onDeselect
            }, row, checked, index, secondaryIndex);
          });
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this8 = this;

      var _this$props8 = this.props,
          width = _this$props8.width,
          height = _this$props8.height,
          rowStyle = _this$props8.rowStyle,
          rowRootClassName = _this$props8.rowRootClassName,
          onClick = _this$props8.onClick,
          onDoubleClick = _this$props8.onDoubleClick,
          onMouseDown = _this$props8.onMouseDown,
          onMouseEnter = _this$props8.onMouseEnter,
          onMouseLeave = _this$props8.onMouseLeave,
          onMouseMove = _this$props8.onMouseMove,
          onMouseOut = _this$props8.onMouseOut,
          onMouseOver = _this$props8.onMouseOver,
          onMouseUp = _this$props8.onMouseUp,
          enableExpandableRows = _this$props8.enableExpandableRows;
      var expandedRows = this.state.expandedRows;
      return React.createElement(SortableTable, _extends({
        ref: function ref(_ref3) {
          return _this8._sortableTable = _ref3;
        },
        rows: this.generateRows(),
        columns: this.generateColumns(),
        width: width,
        height: height,
        enableExpandableRows: enableExpandableRows,
        expandedRows: expandedRows
      }, rowStyle && {
        rowStyle: this.getRowAttributeCallback(rowStyle)
      }, rowRootClassName && {
        rowRootClassName: this.getRowAttributeCallback(rowRootClassName)
      }, onClick && {
        onClick: this.getRowEventCallback(onClick)
      }, onDoubleClick && {
        onDoubleClick: this.getRowEventCallback(onDoubleClick)
      }, onMouseDown && {
        onMouseDown: this.getRowEventCallback(onMouseDown)
      }, onMouseEnter && {
        onMouseEnter: this.getRowEventCallback(onMouseEnter)
      }, onMouseLeave && {
        onMouseLeave: this.getRowEventCallback(onMouseLeave)
      }, onMouseMove && {
        onMouseMove: this.getRowEventCallback(onMouseMove)
      }, onMouseOut && {
        onMouseOut: this.getRowEventCallback(onMouseOut)
      }, onMouseOver && {
        onMouseOver: this.getRowEventCallback(onMouseOver)
      }, onMouseUp && {
        onMouseUp: this.getRowEventCallback(onMouseUp)
      }));
    }
  }]);

  return SelectionTable;
}(React.Component);

export default SelectionTable;