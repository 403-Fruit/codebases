function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
var TableUtil = {
  /**
   * `calculateRowsOnDisplay` Graphic Demonstration.
   *
   * Input:
   *  - `scrollTop`: number, The distance from top of body content to viewport top
   *  - `headerHeight`: number, The height of the header
   *  - `totalBodyHeight`: number, The total height of body
   *  - `viewportHeight`: number, The height of the viewport
   *  - `rows`: Array<Row>, The actual rows of the table to be rendered. For synchronization issue we are not always
   *    guarenteeing that `rowHeights` has exact 1-1 mapping with `rows`. To avoid that problem, we still need `rows`
   *    as the source of truth to get the amount of real rows to be rendered.
   *    More specifically, it might be the case that `rows` has already been filtered (been filtered so it goes from
   *    10 rows to 5 rows) but `rowHeights` still contains the value for 10 rows.
   *  - `rowHeights`: Array<number>, The height of all the rows
   *
   * Return (Want to calculate):
   *  - `top`: The height of top placeholder
   *  - `bottom`: The height of bottom placeholder
   *  - `startIndex`: The index of the first row to be rendered (including the upper overscan 1)
   *  - `endIndex`: The index of the last row to be rendered (including the bottom overscan 1)
   *
   * In the graph below, we have a long thin scroll of table body (the box wrapped with - and |), and a fatter viewport
   * (the box wrapped with #) that is visible to the user. Within the body different rows are separated by '---'. We
   * want to calculate the rows that are visible within the viewport, as well as adding 1 row of overscan to the top as
   * well as bottom to improve accessibility (so that the users can tab through even into the invisible area. Because
   * the default table behavior is that html will scroll the table body so that the invisible row that is in focus is
   * in the center of the viewport. So we can use tab infinitely). To the right hand side of the graph, we use vertical
   * lines to demonstrate the height spans related to the calculation, and we use '<-' to show the rows in the table
   * that are also relavant.
   *
   *        --------------                                                ---                       ---
   *        |   Header   |                                  Header (height = `headerHeight`)         ^
   *        |------------|        ---                                     ---                        |
   *        |            |         ^                                       ^                         |
   *        |            |         |                                       |                         |
   *        |    ....    |  Top placeholder (height = `top`)               |                    `scrollTop`
   *        |            |         |                                       |                         |
   *        |            |         v                                       |                         |
   *        |------------|        ---                                      |                         |
   *        |`startIndex`|              <- Top Overscan Row                |                         |
   *        |------------|                                                 |                         v
   *    # # |# # # # # # | # #    ---   <- Top Row                         |                        ---
   *    #   |------------|   #     ^                                       |
   *    #   |            |   #     |                                       |
   *    #   |    ....    |   #  Viewport (height = `viewportHeight`)  Table body (height = `totalBodyHeight`)
   *    #   |            |   #     |                                       |
   *    #   |------------|   #     v                                       |
   *    # # |# # # # # # | # #    ---   <- Bottom Row                      |
   *        |------------|                                                 |
   *        | `endIndex` |              <- Bottom Overscan Row             |
   *        |------------|        ---                                      |
   *        |            |         ^                                       |
   *        |            |         |                                       |
   *        |    ....    |  Bottom placeholder (height = `bottom`)         |
   *        |            |         |                                       |
   *        |            |         v                                       v
   *        --------------        ---                                     ---
   *
   */
  calculateRowsOnDisplay: function calculateRowsOnDisplay(_ref) {
    var rows = _ref.rows,
        scrollTop = _ref.scrollTop,
        headerHeight = _ref.headerHeight,
        totalBodyHeight = _ref.totalBodyHeight,
        viewportHeight = _ref.viewportHeight,
        rowHeights = _ref.rowHeights;
    // The distance from the bottom of the viewport to the top of the table body
    var scrollBottom = scrollTop + viewportHeight; // Setup variables

    var top = 0;
    var bottom = 0;
    var startIndex = -1;
    var endIndex = -1;
    var heightSoFar = headerHeight; // Loop all the rows

    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      var rowHeight = rowHeights[rowIndex];
      var rowStart = heightSoFar;
      var rowEnd = heightSoFar + rowHeight; // Check if the row is within the frame range

      if (rowEnd >= scrollTop && rowStart <= scrollBottom) {
        if (rowStart < scrollTop && rowEnd >= scrollTop) {
          // If the row is the FIRST row in the frame, set startIndex and top
          var hasTopOverscan = rowIndex > 0;
          startIndex = hasTopOverscan ? rowIndex - 1 : rowIndex;
          var overscanHeight = hasTopOverscan ? rowHeights[startIndex] : 0;
          top = heightSoFar - headerHeight - overscanHeight;
        } else if (rowStart <= scrollBottom && rowEnd > scrollBottom) {
          // If the row is the LAST row in the frame, set endIndex and bottom
          var hasBottomOverscan = rowIndex < rows.length - 1;
          endIndex = hasBottomOverscan ? rowIndex + 1 : rowIndex;

          var _overscanHeight = hasBottomOverscan ? rowHeights[endIndex] : 0;

          bottom = totalBodyHeight + headerHeight - rowEnd - _overscanHeight;
        }
      } // Optimization, if already went pass the frame, then don't loop anymore


      if (rowStart > scrollBottom) {
        break;
      } // Increase the heightSoFar with the current row height


      heightSoFar += rowHeight;
    } // Check if any of start or end is unset, then put startIndex to 0, put endIndex to last index


    startIndex = startIndex === -1 ? 0 : startIndex;
    endIndex = endIndex === -1 ? rows.length - 1 : endIndex;
    return {
      top: top,
      bottom: bottom,
      startIndex: startIndex,
      endIndex: endIndex
    };
  },

  /**
   * TRICK: a setTimeout here will make sure that state update is called after the table is actually rendered by the
   * dom render engine. NOTE: componentDidMount doesn't guarentee the sizes are correctly calculated at the time
   */
  afterBrowserRendering: function afterBrowserRendering(callback) {
    setTimeout(callback, 0);
  },
  // update expanded rows state by row key
  updateExpandedRows: function updateExpandedRows(expandedRows, row) {
    if (!row.key) {
      return {};
    }

    return _objectSpread({}, expandedRows, _defineProperty({}, row.key, typeof expandedRows[row.key] === 'undefined' ? true : !expandedRows[row.key]));
  }
};
export default TableUtil;