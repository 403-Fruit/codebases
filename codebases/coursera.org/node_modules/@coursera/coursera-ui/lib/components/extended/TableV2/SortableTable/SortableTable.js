function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
import * as React from 'react';
import _ from 'underscore';
import Table from "../Table/Table";
import TableUtil from "../Table/TableUtil";
import SortableHeader from "./SortableHeader";
import { NO_SORT, ASCENDING } from "./SortingDirection";

var SortableTable =
/*#__PURE__*/
function (_React$Component) {
  _inherits(SortableTable, _React$Component);

  function SortableTable(props, context) {
    var _this;

    _classCallCheck(this, SortableTable);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SortableTable).call(this, props, context));

    _defineProperty(_assertThisInitialized(_this), "_table", void 0);

    _defineProperty(_assertThisInitialized(_this), "toggleExpandRow", function (row) {
      _this.setState({
        expandedRows: TableUtil.updateExpandedRows(_this.state.expandedRows || {}, row)
      });
    });

    _this.state = _this.generateInitialState(props);
    return _this;
  }

  _createClass(SortableTable, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.props.columns.length !== nextProps.columns.length) {
        // If the columns are completely changed, then generate initial state completely
        this.setState(this.generateInitialState(nextProps));
      } else {
        // If not, then only update the sortedRowIndices
        this.setState(function (oldState) {
          var _this2$state = _this2.state,
              sortingColumn = _this2$state.sortingColumn,
              sortingDirection = _this2$state.sortingDirection;
          return {
            sortedRowIndices: _this2.getSortedRowIndices(nextProps.rows, sortingColumn, sortingDirection)
          };
        });
      }

      if (!_.isEqual(nextProps.expandedRows, this.props.expandedRows)) {
        this.setState({
          expandedRows: nextProps.expandedRows
        });
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      return this._table;
    }
  }, {
    key: "generateInitialState",
    value: function generateInitialState(props) {
      return {
        sortingColumn: 0,
        sortingDirection: NO_SORT,
        sortedRowIndices: this.getSortedRowIndices(props.rows, 0, NO_SORT),
        expandedRows: props.expandedRows || {}
      };
    }
  }, {
    key: "rowInfo",
    value: function rowInfo(rowIndex, callback) {
      var rows = this.props.rows;
      var sortedRowIndices = this.state.sortedRowIndices;
      var index = sortedRowIndices[rowIndex];
      return callback(rows[index], index);
    }
  }, {
    key: "getRowAttributeCallback",
    value: function getRowAttributeCallback(rowAttribute) {
      var _this3 = this;

      return function (_, rowIndex) {
        return _this3.rowInfo(rowIndex, rowAttribute);
      };
    }
  }, {
    key: "getRowEventCallback",
    value: function getRowEventCallback(callback) {
      var _this4 = this;

      return function (event, _, rowIndex) {
        return _this4.rowInfo(rowIndex, function (row, index) {
          return callback(event, row, index);
        });
      };
    }
  }, {
    key: "getSortedRowIndices",
    value: function getSortedRowIndices(rows, columnIndex, direction) {
      var columns = this.props.columns;
      var _columns$columnIndex = columns[columnIndex],
          accessor = _columns$columnIndex.accessor,
          comparator = _columns$columnIndex.comparator;
      var indices = rows.map(function (_, index) {
        return index;
      });

      if (direction === NO_SORT) {
        return indices;
      } else {
        // Generate basic compare function
        var compare = function compare(i1, i2) {
          var item1 = rows[i1][accessor];
          var item2 = rows[i2][accessor];
          return comparator ? comparator(item1, item2) : item1 > item2 ? 1 : -1;
        }; // Sort a copy of sortedRowIndices. Depending on the sorting direction, inverse the compareFunc


        return indices.sort(direction === ASCENDING ? compare : function (i1, i2) {
          return compare(i2, i1);
        });
      }
    }
  }, {
    key: "handleSortStateChange",
    value: function handleSortStateChange(columnIndex, direction) {
      var _this5 = this;

      var rows = this.props.rows;
      this.setState(function (oldState) {
        var sortedIndices = _this5.getSortedRowIndices(rows, columnIndex, direction);

        return {
          sortingColumn: columnIndex,
          sortingDirection: direction,
          sortedRowIndices: sortedIndices
        };
      }, function () {
        // Since we changed the sorting status, the row heights are now changed, so we need to force the virtualized
        // table to update the row heights.
        _this5._table && _this5._table.forceUpdateRowHeights();
      });
    }
  }, {
    key: "generateColumns",
    value: function generateColumns() {
      var _this6 = this;

      var columns = this.props.columns;
      var _this$state = this.state,
          sortingColumn = _this$state.sortingColumn,
          sortingDirection = _this$state.sortingDirection,
          sortedRowIndices = _this$state.sortedRowIndices,
          expandedRows = _this$state.expandedRows;
      return columns.map(function (column, columnIndex) {
        var accessor = column.accessor,
            width = column.width,
            header = column.header,
            cellRenderer = column.cellRenderer,
            sortable = column.sortable;
        var isSortingCurrentColumn = sortingColumn === columnIndex;
        return {
          accessor: accessor,
          width: width,
          header: sortable ? function (visible) {
            return _this6.renderSortableHeader(visible, header, columnIndex);
          } : header,
          cellRenderer: cellRenderer && function (cell, row, rowIndex) {
            return cellRenderer(cell, row, sortedRowIndices[rowIndex], _this6.toggleExpandRow, expandedRows[row.key]);
          },
          htmlProps: sortable ? {
            'aria-sort': isSortingCurrentColumn ? sortingDirection : NO_SORT
          } : {}
        };
      });
    }
  }, {
    key: "generateRows",
    value: function generateRows() {
      var rows = this.props.rows;
      var _this$state2 = this.state,
          sortedRowIndices = _this$state2.sortedRowIndices,
          sortingDirection = _this$state2.sortingDirection;
      var generatedRows = sortingDirection === NO_SORT ? rows : sortedRowIndices.map(function (index) {
        return rows[index];
      });
      return generatedRows;
    }
  }, {
    key: "renderSortableHeader",
    value: function renderSortableHeader(isVisibleHeader, header, columnIndex) {
      var _this7 = this;

      var _this$state3 = this.state,
          sortingColumn = _this$state3.sortingColumn,
          sortingDirection = _this$state3.sortingDirection;
      return React.createElement(SortableHeader, {
        isVisibleHeader: isVisibleHeader,
        sortingColumn: sortingColumn,
        sortingDirection: sortingDirection,
        currentColumn: columnIndex,
        header: header,
        onChange: function onChange(columnIndex, direction) {
          return _this7.handleSortStateChange(columnIndex, direction);
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this8 = this;

      var _this$props = this.props,
          width = _this$props.width,
          height = _this$props.height,
          rowStyle = _this$props.rowStyle,
          rowRootClassName = _this$props.rowRootClassName,
          onClick = _this$props.onClick,
          onDoubleClick = _this$props.onDoubleClick,
          onMouseDown = _this$props.onMouseDown,
          onMouseEnter = _this$props.onMouseEnter,
          onMouseLeave = _this$props.onMouseLeave,
          onMouseMove = _this$props.onMouseMove,
          onMouseOut = _this$props.onMouseOut,
          onMouseOver = _this$props.onMouseOver,
          onMouseUp = _this$props.onMouseUp,
          enableExpandableRows = _this$props.enableExpandableRows;
      return React.createElement(Table, _extends({
        ref: function ref(_ref) {
          return _this8._table = _ref;
        },
        columns: this.generateColumns(),
        rows: this.generateRows(),
        width: width,
        height: height,
        expandedRows: this.state.expandedRows,
        enableExpandableRows: enableExpandableRows
      }, rowStyle && {
        rowStyle: this.getRowAttributeCallback(rowStyle)
      }, rowRootClassName && {
        rowRootClassName: this.getRowAttributeCallback(rowRootClassName)
      }, onClick && {
        onClick: this.getRowEventCallback(onClick)
      }, onDoubleClick && {
        onDoubleClick: this.getRowEventCallback(onDoubleClick)
      }, onMouseDown && {
        onMouseDown: this.getRowEventCallback(onMouseDown)
      }, onMouseEnter && {
        onMouseEnter: this.getRowEventCallback(onMouseEnter)
      }, onMouseLeave && {
        onMouseLeave: this.getRowEventCallback(onMouseLeave)
      }, onMouseMove && {
        onMouseMove: this.getRowEventCallback(onMouseMove)
      }, onMouseOut && {
        onMouseOut: this.getRowEventCallback(onMouseOut)
      }, onMouseOver && {
        onMouseOver: this.getRowEventCallback(onMouseOver)
      }, onMouseUp && {
        onMouseUp: this.getRowEventCallback(onMouseUp)
      }));
    }
  }]);

  return SortableTable;
}(React.Component);

export default SortableTable;