function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
import * as React from 'react';
import PropTypes from 'prop-types';
import { StyleSheet, css, spacing, zIndex, color, breakPoint, fontFamily } from "../../../styles/theme";
import TunnelVisionHeader from "./TunnelVisionHeader";
var ESCAPE_KEY_CODE = 27;
var TAB_KEY = 9;
var LEVEL_1_PADDING = 24; // px

var LEVEL_2_PADDING = 2 * LEVEL_1_PADDING;
var WINDOW_OFFSET = 100; // %

var SLIDE_DURATION = 400; // milliseconds

var SLIDE_DIRECTION = {
  IN: -1,
  OUT: 1
};
var BORDER_WIDTH = 1;
var HEADER_HEIGHT = 72;
var TOTAL_HEADER_HEIGHT = HEADER_HEIGHT + BORDER_WIDTH;
var FOOTER_HEIGHT = 60;
var TOTAL_FOOTER_HEIGHT = FOOTER_HEIGHT + BORDER_WIDTH;
var CONFIG = {
  keyFrameSlideIn: {
    '0%': {
      transform: "translateX(".concat(WINDOW_OFFSET, "%)")
    },
    '100%': {
      transform: 'translateX(0)'
    }
  },
  keyFrameSlideOut: {
    '0%': {
      transform: 'translateX(0)'
    },
    '100%': {
      transform: "translateX(".concat(WINDOW_OFFSET, "%)")
    }
  }
};
var styles = StyleSheet.create({
  TunnelVision: {//
  },
  tunnelVisionContentContainer: _defineProperty({
    display: 'flex',
    flexWrap: 'nowrap',
    width: '100%',
    height: "calc(100% - ".concat(TOTAL_HEADER_HEIGHT, "px)"),
    maxHeight: "calc(100% - ".concat(TOTAL_HEADER_HEIGHT, "px)"),
    alignItems: 'stretch'
  }, "@media (max-width: ".concat(breakPoint.md, "px)"), {
    flexDirection: 'column'
  }),
  tunnelVisionFooterContainer: {
    height: "".concat(FOOTER_HEIGHT, "px"),
    borderTop: "1px solid ".concat(color.border),
    flex: 1,
    display: 'flex',
    alignItems: 'center',
    fontFamily: fontFamily.body,
    margin: 0
  },
  tunnelVisionContentContainerWithFooter: {
    height: "calc(100% - ".concat(TOTAL_HEADER_HEIGHT, "px - ").concat(TOTAL_FOOTER_HEIGHT, "px)"),
    maxHeight: "calc(100% - ".concat(TOTAL_HEADER_HEIGHT, "px - ").concat(TOTAL_FOOTER_HEIGHT, "px)")
  },
  tunnelVisionOverlay: {
    position: 'fixed',
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    height: '100%',
    width: '100%',
    backgroundColor: color.gray,
    opacity: 0.5,
    zIndex: zIndex.lg,
    cursor: 'pointer'
  },
  tunnelVisionWindow: _defineProperty({
    width: '100%',
    position: 'fixed',
    top: 0,
    left: 0,
    transform: 'translateZ(0)',
    bottom: 0,
    maxWidth: '100%',
    maxHeight: '100%',
    zIndex: zIndex.lg,
    backgroundColor: color.white,
    boxShadow: '0 0 3em 1em rgba(0,0,0,0.2)'
  }, "@media (max-width: ".concat(breakPoint.md, "px)"), {
    left: 0,
    marginLeft: spacing.md,
    transform: 'none'
  }),
  tunnelVisionWindowLevel1: {
    width: "calc(100% - ".concat(LEVEL_1_PADDING, "px)"),
    left: "".concat(LEVEL_1_PADDING, "px"),
    maxWidth: "calc(100% - ".concat(LEVEL_1_PADDING, "px)")
  },
  tunnelVisionWindowLevel2: {
    width: "calc(100% - ".concat(LEVEL_2_PADDING, "px)"),
    left: "".concat(LEVEL_2_PADDING, "px"),
    maxWidth: "calc(100% - ".concat(LEVEL_2_PADDING, "px)")
  },
  windowSlideIn: {
    animationName: [CONFIG.keyFrameSlideIn],
    animationDuration: "".concat(SLIDE_DURATION, "ms"),
    animationTimingFunction: 'ease'
  },
  windowSlideOut: {
    animationName: [CONFIG.keyFrameSlideOut],
    animationDuration: "".concat(SLIDE_DURATION, "ms"),
    animationTimingFunction: 'ease'
  }
});

var TunnelVision =
/*#__PURE__*/
function (_React$Component) {
  _inherits(TunnelVision, _React$Component);

  function TunnelVision() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, TunnelVision);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TunnelVision)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "defaultProps", void 0);

    _defineProperty(_assertThisInitialized(_this), "props", void 0);

    _defineProperty(_assertThisInitialized(_this), "state", {
      slideDirection: SLIDE_DIRECTION.IN,
      firstTabStop: null,
      lastTabStop: null
    });

    _defineProperty(_assertThisInitialized(_this), "handleClose", function () {
      var lastActiveElement = _this.props.lastActiveElement;

      if (_this.props.animated) {
        // wait for slide out animation before closing
        _this.setState({
          slideDirection: SLIDE_DIRECTION.OUT
        });

        setTimeout(_this.props.onClose, SLIDE_DURATION);
      } else {
        _this.props.onClose();
      }

      if (lastActiveElement && lastActiveElement.length) {
        var el = document.querySelector(".".concat(lastActiveElement));
        el && el.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleKeyPress", function (e) {
      var _this$state = _this.state,
          firstTabStop = _this$state.firstTabStop,
          lastTabStop = _this$state.lastTabStop;

      if (e.keyCode === TAB_KEY) {
        // SHIFT + TAB
        if (e.shiftKey) {
          if (document.activeElement === firstTabStop) {
            e.preventDefault();
            lastTabStop && lastTabStop.focus();
          }
        } else {
          // TAB
          if (document.activeElement === lastTabStop) {
            e.preventDefault();
            firstTabStop && firstTabStop.focus();
          }
        }
      }

      if (e.keyCode === ESCAPE_KEY_CODE) {
        _this.handleClose();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "shouldClose", function () {
      var shouldClose = typeof _this.props.shouldAllowClose === 'function' ? _this.props.shouldAllowClose(_this.handleClose) : true;

      if (shouldClose) {
        _this.handleClose();
      }
    });

    return _this;
  }

  _createClass(TunnelVision, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var tunnelVision = document.querySelector('.rc-TunnelVision');

      if (document.body) {
        document.body.style.overflow = 'hidden';
      }

      if (this.props.animated) {
        // slide in on render
        this.setState({
          slideDirection: SLIDE_DIRECTION.IN
        });
      }

      if (tunnelVision) {
        // find all focusable children
        var focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex="0"], [contenteditable]';
        var focusableElements = tunnelVision.querySelectorAll(focusableElementsString);
        focusableElements = Array.from(focusableElements);
        var firstTabStop = focusableElements[0];
        var lastTabStop = focusableElements[focusableElements.length - 1];
        this.setState({
          firstTabStop: firstTabStop,
          lastTabStop: lastTabStop
        }); // move focus to first forcasable element in tunnel view after tunnelvision slide in is complete

        setTimeout(function () {
          return firstTabStop.focus();
        }, SLIDE_DURATION);

        if (!this.props.disableKeyPress) {
          // $FlowFixMe
          document.addEventListener('keydown', this.handleKeyPress);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (document.body) {
        document.body.style.overflow = '';
      }

      if (!this.props.disableKeyPress) {
        // $FlowFixMe
        document.removeEventListener('keydown', this.handleKeyPress);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          closeElement = _this$props.closeElement,
          headerElement = _this$props.headerElement,
          footerElement = _this$props.footerElement,
          children = _this$props.children,
          level = _this$props.level,
          showCloseTooltip = _this$props.showCloseTooltip,
          animated = _this$props.animated,
          contentKey = _this$props.contentKey,
          backbuttonAriaLabel = _this$props.backbuttonAriaLabel,
          ariaLabel = _this$props.ariaLabel;
      var slideDirection = this.state.slideDirection;
      var IN = SLIDE_DIRECTION.IN,
          OUT = SLIDE_DIRECTION.OUT;
      var tunnelVisionContentContainerClassName = css(styles.tunnelVisionContentContainer, footerElement && styles.tunnelVisionContentContainerWithFooter);
      return React.createElement("div", {
        className: "rc-TunnelVision ".concat(css(styles.TunnelVision).className),
        role: "dialog",
        "aria-modal": "true",
        "aria-label": ariaLabel
      }, React.createElement("div", css(styles.tunnelVisionOverlay)), React.createElement("div", _extends({}, css(styles.tunnelVisionWindow, level === 1 && styles.tunnelVisionWindowLevel1, level === 2 && styles.tunnelVisionWindowLevel2, animated && slideDirection === IN && styles.windowSlideIn, animated && slideDirection === OUT && styles.windowSlideOut), {
        "data-classname": 'tunnelvision-window-' + this.props.level
      }), React.createElement(TunnelVisionHeader, {
        closeElement: closeElement,
        headerElement: headerElement,
        handleClose: this.shouldClose,
        showCloseTooltip: showCloseTooltip,
        backbuttonAriaLabel: backbuttonAriaLabel
      }), React.createElement("div", _extends({}, contentKey ? {
        key: contentKey
      } : {}, tunnelVisionContentContainerClassName), children), footerElement && React.createElement("div", css(styles.tunnelVisionFooterContainer), footerElement)));
    }
  }]);

  return TunnelVision;
}(React.Component);

_defineProperty(TunnelVision, "propTypes", {
  children: PropTypes.node,
  disableKeyPress: PropTypes.bool,
  animated: PropTypes.bool,
  onClose: PropTypes.func,

  /*
    "shouldAllowClose" is a function that will return a boolean to signal whether the user's closeClick should continue closing the panel or not.
    TunnelVision will also pass its "handleClose" method to "shouldAllowClose" so that "shouldAllowClose" can store the close action for later execution,
    (eg. execute "handleClose" after a user confirms they want to close the panel via a modal).
  */
  shouldAllowClose: PropTypes.func,

  /*
    "closeElement" allows the user to replace the default Tunnel Vision close button with an alternate element.  The "closeElement" will be passed
    down through TunnelVisionHeader to TunnelVisionClose for use instead of the default TunnelVisionClose icon.  Along with static class names, this
    will allow customization of TunnelVision to different layouts without creating multiple component variants that replicate the same behavior but
    implement different presentation.
  */
  closeElement: PropTypes.element,
  headerElement: PropTypes.element,
  footerElement: PropTypes.element,
  // level determines nesting of one TV inside another, used to control container styling
  level: PropTypes.number,
  showCloseTooltip: PropTypes.bool
});

_defineProperty(TunnelVision, "defaultProps", {
  disableKeyPress: false,
  animated: true,
  onClose: function onClose() {},
  level: 0,
  showCloseTooltip: false,
  lastActiveElement: '',
  ariaLabel: 'tunnel vision'
});

export default TunnelVision;