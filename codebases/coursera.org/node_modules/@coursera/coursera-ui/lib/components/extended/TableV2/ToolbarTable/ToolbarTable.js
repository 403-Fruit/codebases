function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as React from 'react';
import { css } from "../../../../styles/theme";
import TableUtil from "../Table/TableUtil";
import SelectionUtil from "../SelectionTable/SelectionUtil";
import ToolbarTableUtil from "./ToolbarTableUtil";
import ActionButton from "./ActionButton";
import TablePaginationControls from "./TablePaginationControls";
import { default as SelectionTable } from "../SelectionTable/SelectionTable";
import { default as Styles, TOOLBAR_HEIGHT, PAGINATION_HEIGHT } from "./ToolbarTableStyles";

var ToolbarTable =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ToolbarTable, _React$Component);

  function ToolbarTable(props) {
    var _this;

    _classCallCheck(this, ToolbarTable);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ToolbarTable).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "_selectionTable", void 0);

    _defineProperty(_assertThisInitialized(_this), "toggleExpandRow", function (row) {
      _this.setState({
        expandedRows: TableUtil.updateExpandedRows(_this.state.expandedRows || {}, row)
      });
    });

    _this.state = _this.generateState(props);
    return _this;
  }

  _createClass(ToolbarTable, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var toolbar = this.props.toolbar;

      if (prevProps.toolbar.length !== toolbar.length || ToolbarTableUtil.toolbarHasChanged(toolbar, prevProps.toolbar)) {
        this.setState({
          toolbar: this.generateTools(toolbar)
        });
      }
    }
  }, {
    key: "rowInfo",
    value: function rowInfo(row, callback) {
      var _this$props = this.props,
          rows = _this$props.rows,
          groups = _this$props.groups;

      var _ref = row || {},
          $groupIndex = _ref.$groupIndex,
          $rowIndex = _ref.$rowIndex,
          $isGroupTitle = _ref.$isGroupTitle;

      if (rows && typeof $rowIndex === 'number') {
        return callback(rows[$rowIndex], $rowIndex);
      } else if (groups && typeof $groupIndex === 'number' && typeof $rowIndex === 'number') {
        return callback(groups[$groupIndex].rows[$rowIndex], $groupIndex, $rowIndex);
      } else if (groups && typeof $groupIndex === 'number' && $isGroupTitle) {
        return callback(groups[$groupIndex], $groupIndex, undefined, $isGroupTitle);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      return this._selectionTable && this._selectionTable.getTable();
    }
  }, {
    key: "getRowEventCallback",
    value: function getRowEventCallback(callback) {
      var _this2 = this;

      return function (event, row) {
        return _this2.rowInfo(row, function (row, index, secondary) {
          return callback(event, row, index, secondary);
        });
      };
    }
  }, {
    key: "getRowSelectionCallback",
    value: function getRowSelectionCallback(callback) {
      var _this3 = this;

      return function (row) {
        return _this3.rowInfo(row, callback);
      };
    }
  }, {
    key: "getTableHeight",
    value: function getTableHeight() {
      var _this$props2 = this.props,
          height = _this$props2.height,
          enablePagination = _this$props2.enablePagination;
      return height !== undefined ? "".concat(height - TOOLBAR_HEIGHT - (enablePagination ? PAGINATION_HEIGHT : 0), "px") : undefined;
    }
  }, {
    key: "generateState",
    value: function generateState(props) {
      var toolbar = props.toolbar;
      return {
        toolbar: this.generateTools(toolbar),
        expandedRows: {}
      };
    }
  }, {
    key: "generateTools",
    value: function generateTools(toolbar) {
      return toolbar.map(function (tool) {
        return ToolbarTableUtil.generateTool(tool);
      });
    }
  }, {
    key: "updateFilterValue",
    value: function updateFilterValue(toolIndex, value, customUpdateHandler) {
      var _this4 = this;

      var defaultUpdateHandler = function defaultUpdateHandler() {
        var table = _this4.getTable(); // Since the filter value has changed, there will be changes in the rows, so we need to update the heights of
        // the rows.


        table && table.forceUpdateRowHeights();
        var _this4$props = _this4.props,
            rows = _this4$props.rows,
            groups = _this4$props.groups,
            onUpdateFilteredRowsAndGroups = _this4$props.onUpdateFilteredRowsAndGroups;

        if (onUpdateFilteredRowsAndGroups) {
          // Filter rows or groups
          var filteredRows = rows && _this4.filterRows(_this4.addMetaToRows(rows));

          var filteredGroups = groups && _this4.filterGroups(_this4.addMetaToGroups(groups));

          onUpdateFilteredRowsAndGroups({
            filteredGroups: filteredGroups,
            filteredRows: filteredRows
          });
        }
      };

      var updateHandler = customUpdateHandler || defaultUpdateHandler;
      this.setState(function (oldState) {
        var toolbar = oldState.toolbar.slice();
        toolbar[toolIndex].value = value;
        return {
          toolbar: toolbar
        };
      }, updateHandler);
    }
  }, {
    key: "filterRows",
    value: function filterRows(rows) {
      var toolbar = this.state.toolbar;
      return toolbar.reduce(function (rows, tool) {
        return tool.type === 'filter' ? ToolbarTableUtil.filterRowsWithTool(rows, tool) : rows;
      }, rows);
    }
  }, {
    key: "filterGroups",
    value: function filterGroups(groups) {
      var _this5 = this;

      var alwaysRenderGroupTitleRow = this.props.alwaysRenderGroupTitleRow;
      return groups.reduce(function (allGroups, group) {
        var rows = group.rows;

        var filteredRows = _this5.filterRows(rows);

        if (filteredRows.length) {
          return allGroups.concat(_objectSpread({}, group, {
            rows: filteredRows
          }));
        } else if (alwaysRenderGroupTitleRow) {
          return allGroups.concat(_objectSpread({}, group, {
            rows: []
          }));
        } else {
          return allGroups.concat([]);
        }
      }, []);
    }
  }, {
    key: "addMetaToRows",
    value: function addMetaToRows(rows) {
      return rows.map(function (row, rowIndex) {
        return _objectSpread({}, row, {
          $rowIndex: rowIndex
        });
      });
    }
  }, {
    key: "addMetaToGroups",
    value: function addMetaToGroups(groups) {
      return groups.map(function (group, groupIndex) {
        var rows = group.rows,
            rest = _objectWithoutProperties(group, ["rows"]);

        return _objectSpread({}, rest, {
          rows: rows.map(function (row, rowIndex) {
            return _objectSpread({}, row, {
              $groupIndex: groupIndex,
              $rowIndex: rowIndex
            });
          })
        });
      });
    }
  }, {
    key: "generateNoResultRow",
    value: function generateNoResultRow() {
      var _ref2;

      var _this$props3 = this.props,
          columns = _this$props3.columns,
          enableSelection = _this$props3.enableSelection;
      return _ref2 = {}, _defineProperty(_ref2, enableSelection ? 'selected' : columns[0].accessor, {
        cellContent: this.renderNoResultCell(),
        colSpan: enableSelection ? columns.length + 1 : columns.length
      }), _defineProperty(_ref2, "disabled", true), _defineProperty(_ref2, "$noResultRow", true), _ref2;
    }
  }, {
    key: "generateRowsOrGroups",
    value: function generateRowsOrGroups() {
      var _this$props4 = this.props,
          rows = _this$props4.rows,
          groups = _this$props4.groups; // Filter rows or groups

      var filteredRows = rows && this.filterRows(this.addMetaToRows(rows));
      var filteredGroups = groups && this.filterGroups(this.addMetaToGroups(groups)); // Check if there's filtered result. If not then use a single no result row

      var hasContent = filteredRows && filteredRows.length > 0 || filteredGroups && filteredGroups.length > 0;
      var generatedRows = hasContent ? filteredRows : [this.generateNoResultRow()];
      var generatedGroups = hasContent ? filteredGroups : undefined; // Return the rows/groups with meta ($rowIndex and $groupIndex)

      if (generatedRows) {
        return {
          rows: generatedRows
        };
      } else if (generatedGroups) {
        return {
          groups: generatedGroups
        };
      } else {
        throw new Error('Neither rows nor groups is specified');
      }
    }
  }, {
    key: "processColumnCellRenderers",
    value: function processColumnCellRenderers(columns) {
      var _this6 = this;

      return columns.map(function (column) {
        var _cellRenderer = column.cellRenderer;
        var obj = _cellRenderer && {
          cellRenderer: function cellRenderer(data, row) {
            return _this6.rowInfo(row, function (row, index, secondaryIndex) {
              return _cellRenderer(data, row, index, secondaryIndex, _this6.toggleExpandRow, _this6.state.expandedRows[row.key]);
            });
          }
        };
        return _objectSpread({}, column, obj);
      });
    }
  }, {
    key: "generateColumns",
    value: function generateColumns() {
      var columns = this.props.columns;
      return this.processColumnCellRenderers(columns);
    }
  }, {
    key: "renderNoResultCell",
    value: function renderNoResultCell() {
      var noResultCell = this.props.noResultCell;
      return React.createElement("div", css(Styles.noResultCell), noResultCell || 'No result');
    }
  }, {
    key: "renderFilterTool",
    value: function renderFilterTool(tool, toolIndex) {
      var _this7 = this;

      return tool.renderer("".concat(toolIndex), tool.value, function (value) {
        return _this7.updateFilterValue(toolIndex, value, tool.onUpdate);
      });
    }
  }, {
    key: "renderSelectAll",
    value: function renderSelectAll(toolIndex) {
      var _this$props5 = this.props,
          rows = _this$props5.rows,
          groups = _this$props5.groups,
          onSelect = _this$props5.onSelect,
          onDeselect = _this$props5.onDeselect; // Filter rows or groups

      var filteredRows = rows && this.filterRows(this.addMetaToRows(rows));
      var filteredGroups = groups && this.filterGroups(this.addMetaToGroups(groups));
      var props = {
        rows: filteredRows,
        groups: filteredGroups,
        onSelect: onSelect,
        onDeselect: onDeselect
      };
      var checkbox = SelectionUtil.renderHeaderSelectAllCheckbox(props);
      return React.createElement("div", _extends({
        key: toolIndex
      }, css(Styles.selectAllWrapper)), checkbox);
    }
  }, {
    key: "renderSelectionAction",
    value: function renderSelectionAction(tool, toolIndex) {
      var _this$props6 = this.props,
          rows = _this$props6.rows,
          groups = _this$props6.groups;
      var toolbar = this.state.toolbar; // Get the style of this button. If next tool is also button, remove the margin (given by css)

      var nextTool = toolbar[toolIndex + 1];
      var needMarginRight = nextTool && nextTool.type !== 'selection-action';
      var style = needMarginRight ? css(Styles.actionButtonMargin) : {}; // Generate the action button

      var selection = SelectionUtil.getSelection({
        rows: rows,
        groups: groups
      });
      var button = tool.renderer ? tool.renderer(selection) : React.createElement(ActionButton, {
        tool: tool,
        selection: selection
      });
      return React.createElement("div", _extends({
        key: toolIndex
      }, style), button);
    }
  }, {
    key: "renderGap",
    value: function renderGap(tool, toolIndex) {
      return React.createElement("div", {
        key: toolIndex
      }, tool.renderer());
    }
  }, {
    key: "renderTool",
    value: function renderTool(tool, toolIndex) {
      switch (tool.type) {
        case 'filter':
          return this.renderFilterTool(tool, toolIndex);

        case 'select-all':
          return this.renderSelectAll(toolIndex);

        case 'selection-action':
          return this.renderSelectionAction(tool, toolIndex);

        case 'gap':
          return this.renderGap(tool, toolIndex);

        case 'custom':
          return tool.renderer(toolIndex, tool.value, tool.onUpdate);

        default:
          return undefined;
      }
    }
  }, {
    key: "renderToolbar",
    value: function renderToolbar() {
      var _this8 = this;

      var toolbar = this.state.toolbar;
      return toolbar.map(function (tool, toolIndex) {
        return _this8.renderTool(tool, toolIndex);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this9 = this;

      var _this$props7 = this.props,
          width = _this$props7.width,
          height = _this$props7.height,
          maxPages = _this$props7.maxPages,
          pageCount = _this$props7.pageCount,
          enablePagination = _this$props7.enablePagination,
          currentPage = _this$props7.currentPage,
          rowStyle = _this$props7.rowStyle,
          rowRootClassName = _this$props7.rowRootClassName,
          onClick = _this$props7.onClick,
          onDoubleClick = _this$props7.onDoubleClick,
          onMouseDown = _this$props7.onMouseDown,
          onMouseEnter = _this$props7.onMouseEnter,
          onMouseLeave = _this$props7.onMouseLeave,
          onMouseMove = _this$props7.onMouseMove,
          onMouseOut = _this$props7.onMouseOut,
          onMouseOver = _this$props7.onMouseOver,
          onMouseUp = _this$props7.onMouseUp,
          onSelect = _this$props7.onSelect,
          onDeselect = _this$props7.onDeselect,
          onPageChange = _this$props7.onPageChange,
          skipRowHeightUpdates = _this$props7.skipRowHeightUpdates,
          rows = _this$props7.rows,
          groups = _this$props7.groups,
          columns = _this$props7.columns,
          noResultsCell = _this$props7.noResultsCell,
          toolbar = _this$props7.toolbar,
          rest = _objectWithoutProperties(_this$props7, ["width", "height", "maxPages", "pageCount", "enablePagination", "currentPage", "rowStyle", "rowRootClassName", "onClick", "onDoubleClick", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp", "onSelect", "onDeselect", "onPageChange", "skipRowHeightUpdates", "rows", "groups", "columns", "noResultsCell", "toolbar"]);

      return React.createElement("div", {
        style: {
          width: width,
          height: height
        }
      }, React.createElement("div", css(Styles.toolbar, 'cui-toolbar'), this.renderToolbar()), React.createElement(SelectionTable, _extends({
        ref: function ref(_ref3) {
          return _this9._selectionTable = _ref3;
        },
        width: width,
        height: skipRowHeightUpdates ? undefined : this.getTableHeight(),
        columns: this.generateColumns(),
        expandedRows: this.state.expandedRows,
        rowStyle: rowStyle,
        rowRootClassName: rowRootClassName
      }, this.generateRowsOrGroups(), onClick && {
        onClick: this.getRowEventCallback(onClick)
      }, onDoubleClick && {
        onDoubleClick: this.getRowEventCallback(onDoubleClick)
      }, onMouseDown && {
        onMouseDown: this.getRowEventCallback(onMouseDown)
      }, onMouseEnter && {
        onMouseEnter: this.getRowEventCallback(onMouseEnter)
      }, onMouseLeave && {
        onMouseLeave: this.getRowEventCallback(onMouseLeave)
      }, onMouseMove && {
        onMouseMove: this.getRowEventCallback(onMouseMove)
      }, onMouseOut && {
        onMouseOut: this.getRowEventCallback(onMouseOut)
      }, onMouseOver && {
        onMouseOver: this.getRowEventCallback(onMouseOver)
      }, onMouseUp && {
        onMouseUp: this.getRowEventCallback(onMouseUp)
      }, onSelect && {
        onSelect: this.getRowSelectionCallback(onSelect)
      }, onDeselect && {
        onDeselect: this.getRowSelectionCallback(onDeselect)
      }, rest)), enablePagination && maxPages && pageCount > 0 && React.createElement(TablePaginationControls, {
        onPageChange: onPageChange,
        maxPages: maxPages,
        pageCount: pageCount,
        currentPage: currentPage
      }));
    }
  }]);

  return ToolbarTable;
}(React.Component);

export default ToolbarTable;