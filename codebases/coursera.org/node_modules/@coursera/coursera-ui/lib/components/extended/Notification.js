function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//

/* eslint-disable react/no-unused-prop-types */
import * as React from 'react';
import PropTypes from 'prop-types';
import SvgButton from "../basic/SvgButton";
import Button from "../basic/Button";
import { StyleSheet, css, color, zIndex, spacing, font } from "../../styles/theme";
import { SvgInfoFilled, SvgCircleWarning, SvgCheckSolid, SvgError, SvgClose } from "../../svg";
import { Motion, spring } from 'react-motion'; // common styles based on type

function getTypeStyles(type) {
  var camelCaseType = type.charAt(0).toUpperCase() + type.slice(1);
  return {
    backgroundColor: color["bg".concat(camelCaseType)],
    border: "1px solid ".concat(color[type])
  };
}

var capitalizeType = function capitalizeType(type) {
  return "".concat(type.charAt(0).toUpperCase()).concat(type.slice(1));
}; // react-motion interpolation styles, see https://github.com/chenglou/react-motion


var defaultMotionStyle = {
  opacity: 1
};
var finalMotionStyle = {
  opacity: spring(0, {
    stiffness: 150
  })
};
var styles = StyleSheet.create({
  Notification: {
    width: '100%',
    padding: '11px',
    // this needs to be hardcoded because of the 1px border
    display: 'flex',
    flexDirection: 'row',
    alignItems: 'center',
    zIndex: zIndex.md,
    fontSize: font.sm,
    lineHeight: font.lg,
    minHeight: font.xxl
  },
  icon: {
    padding: spacing.sm
  },
  message: {
    paddingLeft: spacing.sm,
    flex: 1
  },
  messageNoIcon: {
    paddingLeft: 0,
    flex: 1
  },
  action: {
    padding: "0 ".concat(spacing.sm)
  },
  dismiss: {
    marginLeft: 'auto'
  },
  info: getTypeStyles('info'),
  warning: getTypeStyles('warning'),
  success: getTypeStyles('success'),
  danger: getTypeStyles('danger'),
  error: getTypeStyles('error')
}); // map icon type to component

var ICON_MAP = {
  info: SvgInfoFilled,
  warning: SvgCircleWarning,
  danger: SvgError,
  error: SvgError,
  success: SvgCheckSolid
}; // render action button

var defaultActionRenderer = function defaultActionRenderer(action, onAction) {
  return React.createElement(Button, {
    type: "link",
    size: "sm",
    label: action,
    onClick: onAction,
    htmlAttributes: {
      'aria-label': action
    }
  });
};
/**
 * A customizable Notification component to show a message with an optional
 * call-to-action and an optional dismiss.
 */


var Notification =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Notification, _React$Component);

  function Notification() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Notification);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Notification)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "state", {
      hide: false,
      showTransient: false
    });

    _defineProperty(_assertThisInitialized(_this), "renderIcon", function () {
      var _this$props = _this.props,
          type = _this$props.type,
          iconSize = _this$props.iconSize,
          iconTitle = _this$props.iconTitle;
      var Icon = ICON_MAP[type];
      return React.createElement(Icon, {
        title: iconTitle || capitalizeType(type),
        size: iconSize,
        color: color[type]
      });
    });

    _defineProperty(_assertThisInitialized(_this), "renderMessage", function () {
      var _this$props2 = _this.props,
          message = _this$props2.message,
          hideIcon = _this$props2.hideIcon;
      return React.createElement("span", css(hideIcon ? styles.messageNoIcon : styles.message), message);
    });

    _defineProperty(_assertThisInitialized(_this), "startMotion", function () {
      _this.setState({
        showTransient: true
      });
    });

    return _this;
  }

  _createClass(Notification, [{
    key: "renderDismiss",
    value: function renderDismiss() {
      return React.createElement("div", _extends({
        "data-classname": "notification-dismiss"
      }, css(styles.dismiss)), React.createElement(SvgButton, {
        type: "link",
        size: "sm",
        onClick: this.props.onDismiss,
        svgElement: React.createElement(SvgClose, {
          size: 18
        }),
        htmlAttributes: {
          'aria-label': 'Dismiss notification'
        }
      }));
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(styleOverrides) {
      var _this$props3 = this.props,
          htmlAttributes = _this$props3.htmlAttributes,
          style = _this$props3.style,
          type = _this$props3.type,
          isLite = _this$props3.isLite;
      var actionRenderer = this.props.actionRenderer || defaultActionRenderer;
      return React.createElement("div", _extends({}, htmlAttributes, css(styles.Notification, !isLite && styles[type]), {
        style: Object.assign({}, style, styleOverrides)
      }), !this.props.hideIcon && this.renderIcon(), this.renderMessage(), this.props.action && actionRenderer(this.props.action, this.props.onAction), this.props.isDismissible && this.renderDismiss());
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props4 = this.props,
          isTransient = _this$props4.isTransient,
          onDismiss = _this$props4.onDismiss,
          transientDuration = _this$props4.transientDuration;
      var showTransient = this.state.showTransient;

      if (!isTransient) {
        return this.renderComponent();
      } // special animation handling for Transient notifications


      if (!showTransient) {
        // show the regular component for `transientDuration`
        setTimeout(this.startMotion, transientDuration);
        return this.renderComponent();
      } else {
        // wrap in Motion component to trigger animation
        return React.createElement(Motion, {
          defaultStyle: defaultMotionStyle,
          style: finalMotionStyle
        }, function (_ref) {
          var opacity = _ref.opacity;

          if (opacity === 0 && onDismiss) {
            // notify client that notification is hidden
            // so they can choose to take some action, like unmount it
            onDismiss();
          } // pass interpolated opacity override to animate over


          return _this2.renderComponent({
            opacity: opacity
          });
        });
      }
    }
  }]);

  return Notification;
}(React.Component);

_defineProperty(Notification, "propTypes", {
  type: PropTypes.oneOf(['info', 'success', 'warning', 'danger', 'error']),
  // used to infer colors and icon
  icon: PropTypes.node,
  // customized icon,
  iconTitle: PropTypes.string,
  iconSize: PropTypes.number,
  // size of icon in px
  hideIcon: PropTypes.bool,
  header: PropTypes.node,
  // we may need to display a title or some timestamps on top
  content: PropTypes.node,
  // body of notification (we can use Expandable/TextTruncate)
  message: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  // notification message
  isDismissible: PropTypes.bool,
  // whether to allow dismissing the notification
  onDismiss: PropTypes.func,
  // callback when notification is dismissed, or hidden (for transient notifications)
  dismissAfter: PropTypes.number,
  // time in milliseconds to wait before dismissing notification
  action: PropTypes.node,
  // CTA node for the notification
  onAction: PropTypes.func,
  // callback for CTA node
  actionRenderer: PropTypes.func,
  // rendering an action component, pass in a render function (action, onAction) => {} for custom rendered buttons e.g. TrackedButton, SplitButton

  /* eslint-disable react/forbid-prop-types */
  htmlAttributes: PropTypes.object,
  style: PropTypes.object,
  // Override the inline-styles of the root element

  /* // eslint-enable react/forbid-prop-types */
  isThemeDark: PropTypes.bool,
  isLite: PropTypes.bool,
  // lite version of notification, with minimum styling
  isTransient: PropTypes.bool,
  // transient notifications will hide themselves after `transientDuration`,
  transientDuration: PropTypes.number // milliseconds to show transient notification for before hiding

});

_defineProperty(Notification, "defaultProps", {
  type: 'info',
  htmlAttributes: {},
  style: {},
  hideIcon: false,
  iconSize: 24,
  message: '',
  isDismissible: false,
  isTransient: false,
  action: null,
  isThemeDark: false,
  isLite: false,
  transientDuration: 4000
});

export default Notification;