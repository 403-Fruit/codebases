function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
import * as React from 'react';
import PropTypes from 'prop-types';
import { onlyUpdateForKeys } from 'recompose';
import { StyleSheet, css, color, transition, zIndex } from "../../styles/theme";
import { ToggleCheckBoxOutlineBlank, ToggleCheckBox, ToggleRadioButtonChecked, ToggleRadioButtonUnchecked, ToggleIndeterminateCheckBox } from "../../svg";
export var LABEL_POSITION = {
  left: 'left',
  right: 'right'
};

var getFocusedStateStyles = function getFocusedStateStyles() {
  var outlineColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : color.primaryText;
  return StyleSheet.create({
    focused: {
      outline: "solid 5px ".concat(outlineColor)
    }
  });
};

var styles = StyleSheet.create({
  Checkbox: {
    'marginBottom': 0,
    'whiteSpace': 'nowrap',
    'outline': 'none',
    'display': 'inline-flex',
    'position': 'relative',
    'lineHeight': 1,
    'verticalAlign': 'middle',
    'alignItems': 'center',
    ':hover': {
      borderColor: color.primary,
      color: color.primary
    },
    ':focus': {
      outline: 'auto',
      color: color.primary
    }
  },
  active: {
    cursor: 'pointer'
  },
  readOnly: {
    ':hover': {
      borderColor: color.divider,
      color: color.primaryText
    },
    ':focus': {
      borderColor: color.divider,
      color: color.primaryText
    }
  },
  interactiveStyle: {},
  disabled: {
    color: color.secondaryText
  },
  btn: {
    'padding': '0.7rem 2rem',
    'border': "1px solid ".concat(color.divider),
    'minWidth': 72,
    ':hover': {
      color: color.primary,
      borderColor: color.primary
    }
  },
  btnChecked: {
    color: color.primary,
    borderColor: color.primary
  },
  btnDisabled: {
    'color': color.secondaryText,
    'backgroundColor': color.bgGray,
    ':hover': {
      borderColor: color.divider,
      color: color.secondaryText
    },
    ':focus': {
      outline: 'auto',
      color: color.secondaryText
    }
  },
  btnDisabledChecked: {
    'color': color.secondaryText,
    'backgroundColor': color.disabled,
    'borderColor': color.divider,
    ':hover': {
      borderColor: color.divider,
      color: color.secondaryText
    },
    ':focus': {
      outline: 'auto',
      color: color.secondaryText
    }
  },
  btnReadOnlyChecked: {
    ':hover': {
      borderColor: color.primary,
      color: color.primary
    }
  },
  iconContainer: {
    display: 'inline-block',
    transition: transition.easeOut()
  },
  input: {
    'position': 'absolute',
    'left': 0,
    'top': 0,
    'bottom': 0,
    'right': 0,
    'width': '100%',
    'height': '100%',
    'zIndex': zIndex.lg,
    'opacity': 0,
    ':focus': {
      outline: 'auto'
    }
  },
  flex1: {
    flex: 1
  },
  isFullWidth: {
    width: '100%'
  }
});

var CheckboxBase =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(CheckboxBase, _React$PureComponent);

  function CheckboxBase(props) {
    var _this;

    _classCallCheck(this, CheckboxBase);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CheckboxBase).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "_uncheckedColor", void 0);

    _defineProperty(_assertThisInitialized(_this), "_uncheckedHoverColor", void 0);

    _defineProperty(_assertThisInitialized(_this), "_checkedColor", void 0);

    _defineProperty(_assertThisInitialized(_this), "_checkedHoverColor", void 0);

    _defineProperty(_assertThisInitialized(_this), "_disabledColor", void 0);

    _defineProperty(_assertThisInitialized(_this), "onChange", function (e) {
      if (_this.props.readOnly) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }

      var checked = e.target.checked; // Set the state with onChange callback after that

      _this.setState(function (prevState) {
        return {
          indeterminate: false,
          checked: checked
        };
      }, function () {
        if (_this.props.onChange) {
          _this.props.onChange({
            target: _objectSpread({}, _this.props, {
              value: _this.props.value,
              checked: checked
            }),
            stopPropagation: function stopPropagation() {
              e.stopPropagation();
            },
            preventDefault: function preventDefault() {
              e.preventDefault();
            }
          });
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onFocus", function (e) {
      if (_this.props.onFocus) {
        _this.props.onFocus(e);
      }

      _this.setState({
        focused: true
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onBlur", function (e) {
      if (_this.props.onBlur) {
        _this.props.onBlur(e);
      }

      _this.setState({
        focused: false
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseLeave", function () {
      _this.setState({
        hovered: false
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onMouseEnter", function () {
      _this.setState({
        hovered: true
      });
    });

    var uncheckedColor = props.uncheckedColor,
        uncheckedHoverColor = props.uncheckedHoverColor,
        checkedColor = props.checkedColor,
        checkedHoverColor = props.checkedHoverColor,
        disabledColor = props.disabledColor,
        isThemeDark = props.isThemeDark;
    _this._uncheckedColor = uncheckedColor || color["border".concat(isThemeDark ? 'ThemeDark' : '')];
    _this._uncheckedHoverColor = uncheckedHoverColor || color.primary;
    _this._checkedColor = checkedColor || color.primary;
    _this._checkedHoverColor = checkedHoverColor || color.darkPrimary;
    _this._disabledColor = disabledColor || color["disabled".concat(isThemeDark ? 'ThemeDark' : '')];
    _this.state = {
      indeterminate: !!props.indeterminate,
      checked: !!props.checked,
      hovered: false,
      focused: false
    };
    return _this;
  }

  _createClass(CheckboxBase, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if ('checked' in nextProps && nextProps.checked !== this.state.checked) {
        this.setState({
          checked: nextProps.checked
        });
      }

      if ('indeterminate' in nextProps && nextProps.indeterminate !== this.state.indeterminate) {
        this.setState({
          indeterminate: nextProps.indeterminate
        });
      }

      if ('checkedColor' in nextProps && nextProps.checkedColor && nextProps.checkedColor !== this._checkedColor) {
        this._checkedColor = nextProps.checkedColor;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          disabled = _this$props.disabled,
          htmlAttributes = _this$props.htmlAttributes,
          isFullWidth = _this$props.isFullWidth,
          isRadio = _this$props.isRadio,
          isRadioButton = _this$props.isRadioButton,
          labelPosition = _this$props.labelPosition,
          name = _this$props.name,
          readOnly = _this$props.readOnly,
          size = _this$props.size,
          style = _this$props.style,
          tabIndex = _this$props.tabIndex,
          value = _this$props.value,
          ariaLabel = _this$props.ariaLabel,
          inputHtmlAttributes = _this$props.inputHtmlAttributes;
      var hovered = this.state.hovered;
      var checked = 'checked' in this.props ? this.props.checked : this.state.checked;
      var indeterminate = 'indeterminate' in this.props ? this.props.indeterminate : this.state.indeterminate;
      var Tag;
      var iconColor = checked ? this._checkedColor : this._uncheckedColor;
      var iconHoverColor = checked ? this._checkedHoverColor : this._uncheckedHoverColor;

      if (disabled) {
        iconColor = this._disabledColor;
        iconHoverColor = this._disabledColor;
      } else if (readOnly && !checked) {
        iconColor = this._uncheckedColor;
        iconHoverColor = this._uncheckedColor;
      }

      if (indeterminate) {
        Tag = ToggleIndeterminateCheckBox;
      } else if (isRadio) {
        Tag = checked ? ToggleRadioButtonChecked : ToggleRadioButtonUnchecked;
      } else {
        Tag = checked ? ToggleCheckBox : ToggleCheckBoxOutlineBlank;
      }

      var checkboxElement = React.createElement("span", css(styles.iconContainer, this.state.focused && getFocusedStateStyles(iconColor).focused), React.createElement(Tag, {
        size: size,
        color: iconColor,
        hoverColor: iconHoverColor,
        hovered: hovered,
        suppressTitle: true
      }));
      var type = isRadio ? 'radio' : 'checkbox';
      return React.createElement("label", _extends({}, css(styles.Checkbox, 'cui-Checkbox', checked && 'cui-isChecked', isRadioButton && styles.btn, isRadioButton && checked && styles.btnChecked, isRadioButton && disabled && styles.btnDisabled, isRadioButton && checked && disabled && styles.btnDisabledChecked, readOnly && styles.readOnly, isRadioButton && checked && readOnly && styles.btnReadOnlyChecked, !disabled && !readOnly && styles.active, !disabled && !readOnly && 'cui-active', isFullWidth && styles.isFullWidth), htmlAttributes, {
        style: style,
        onMouseEnter: this.onMouseEnter,
        onMouseLeave: this.onMouseLeave
      }), labelPosition === LABEL_POSITION.right && !isRadioButton && checkboxElement, React.createElement("input", _extends({}, css(styles.input, !disabled && !readOnly && styles.active), inputHtmlAttributes, {
        value: value,
        name: name,
        type: type,
        "aria-label": ariaLabel,
        readOnly: readOnly,
        disabled: disabled,
        tabIndex: tabIndex,
        checked: checked,
        onClick: this.props.onClick,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onChange: this.onChange
      })), children && React.createElement("span", css('p-x-1s font-weight-normal', styles.flex1, disabled && styles.disabled), children), labelPosition === LABEL_POSITION.left && !isRadioButton && checkboxElement);
    }
  }]);

  return CheckboxBase;
}(React.PureComponent);

_defineProperty(CheckboxBase, "propTypes", {
  htmlAttributes: PropTypes.object,
  name: PropTypes.string,
  children: PropTypes.node,
  value: PropTypes.oneOfType([PropTypes.number.isRequired, PropTypes.string.isRequired]),
  style: PropTypes.object,
  labelPosition: PropTypes.oneOf(Object.keys(LABEL_POSITION)),
  tabIndex: PropTypes.number,
  readOnly: PropTypes.bool,
  disabled: PropTypes.bool,
  // isRadio uses svg icon and isRadioButton uses secondary Button
  isRadio: PropTypes.bool,
  isRadioButton: PropTypes.bool,
  isFullWidth: PropTypes.bool,
  checked: PropTypes.bool,
  size: PropTypes.number,
  isThemeDark: PropTypes.bool,
  // If true, it will overwrite isChecked
  // As soon as user starts to interact, it will set to false
  indeterminate: PropTypes.bool,
  uncheckedColor: PropTypes.string,
  uncheckedHoverColor: PropTypes.string,
  checkedColor: PropTypes.string,
  checkedHoverColor: PropTypes.string,
  disabledColor: PropTypes.string,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  onChange: PropTypes.func,
  onClick: PropTypes.func,

  /**
   * Can be used to quickly set label for screen readers
   */
  ariaLabel: PropTypes.string,

  /**
   * Allows to pass custom input props
   */
  inputHtmlAttributes: PropTypes.object
});

_defineProperty(CheckboxBase, "defaultProps", {
  style: {},
  htmlAttributes: {},
  size: 24,
  tabIndex: 0,
  labelPosition: 'right',
  onFocus: function onFocus() {},
  onBlur: function onBlur() {},
  onChange: function onChange() {}
});

export default onlyUpdateForKeys(['onChange', 'checked', 'indeterminate', 'disabled', 'value', 'children', 'checkedColor'])(CheckboxBase);