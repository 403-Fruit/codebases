'use strict';

var _agent = require('./agent');

var _utils = require('./utils');

var SEGMENT_PROXY = 'analyticsevents.udacity.com/v1';
var CALL_TIMEOUT = 300;

module.exports = {
    init: function init(segmentWriteKey) {
        var useProxy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (window.analytics) {
            if (window.analytics.load) {
                window.analytics.load(segmentWriteKey);
                if (useProxy) {
                    window.analytics.ready(function() {
                        window.analytics._integrations['Segment.io'].options.apiHost = SEGMENT_PROXY;
                        window.analytics.page();
                    });
                }
            } else {
                throw new Error('Segment has already been loaded');
            }
        } else {
            throw new Error('Missing Segment snippet in index.html');
        }
    },
    track: function track(eventName, opts, integrations, callback) {
        return callAndPromisifySegmentFn('track', eventName, opts, integrations, callback);
    },
    page: function page(eventName, opts, integrations, callback) {
        return callAndPromisifySegmentFn('page', eventName, opts, integrations, callback);
    },
    identify: function identify(traits, callback) {
        var traitsCopy = Object.assign({}, traits);
        delete traitsCopy.id;
        return callAndPromisifySegmentFn('identify', traits.id, traitsCopy, null, callback);
    },


    createAgent: _agent.createAgent
};

/**
 * This promisifies the segment analytics call, which allows using promises instead of the `callback`
 * function (while still supporting the `callback` argument).
 */
function callAndPromisifySegmentFn(segmentFnName, arg0, arg1, arg2, callback) {
    return new Promise(function(resolve, reject) {
        if (!window.analytics) {
            reject(new Error('Missing window.analytics'));
            return;
        }

        var isCompleted = false;

        function complete() {
            if (!isCompleted) {
                isCompleted = true;

                if ((0, _utils.isFunction)(callback)) {
                    callback.apply(this, arguments);
                }

                resolve(arguments);
            }
        }

        window.analytics[segmentFnName](arg0, arg1, arg2, complete);

        // In case the analytics callback is never called (such as when a service like Ghostery stubs
        // out the entire `window.analytics` object to a noop), we'll guarantee to complete after a short
        // timeout
        setTimeout(complete, CALL_TIMEOUT);
    });
}